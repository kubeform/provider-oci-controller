// Copyright (c) 2017, 2021, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

package oci

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/url"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/hashicorp/terraform-exec/tfexec"

	oci_dns "github.com/oracle/oci-go-sdk/v45/dns"

	"github.com/hashicorp/hcl2/hclwrite"

	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"

	oci_core "github.com/oracle/oci-go-sdk/v45/core"
	oci_identity "github.com/oracle/oci-go-sdk/v45/identity"
	oci_load_balancer "github.com/oracle/oci-go-sdk/v45/loadbalancer"
)

var isInitDone bool
var initLock sync.Mutex

type TerraformResourceHints struct {
	// Information about this resource
	resourceClass        string // The name of the resource class (e.g. oci_core_vcn)
	resourceAbbreviation string // An abbreviated version of the resource class used for generating shorter resource names (e.g. vcn)

	// Hints to help with discovering this resource using data sources
	datasourceClass              string                  // The name of the data source class to use for discovering resources (e.g. oci_core_vcns)
	datasourceItemsAttr          string                  // The attribute with the data source that contains the discovered resources returned by the data source (e.g. virtual_networks)
	isDatasourceCollection       bool                    // True if list datasource is modeled as a collection with `items` field under datasourceItemsAttr
	requireResourceRefresh       bool                    // Whether to use the resource to fill in missing information from datasource (e.g. when datasources only return summary information)
	discoverableLifecycleStates  []string                // List of lifecycle states that should be discovered. If empty, then all lifecycle states are discoverable.
	processDiscoveredResourcesFn ProcessOCIResourcesFunc // Custom function for processing resources discovered by the data source
	alwaysExportable             bool                    // Some resources always need to be exportable, regardless of whether they are being targeted for export
	isDataSource                 bool
	getIdFn                      func(*OCIResource) (string, error) // If the resource has no OCID generated by services, then implement this to generate one from the OCIResource. Typically used for composite IDs.

	// Override function for discovering resources. To be used when there is no datasource implementation to help with discovery.
	findResourcesOverrideFn func(*resourceDiscoveryContext, *TerraformResourceAssociation, *OCIResource, *TerraformResourceGraph) ([]*OCIResource, error)

	// Hints to help with generating HCL representation from this resource
	getHCLStringOverrideFn func(*strings.Builder, *OCIResource, map[string]string) error // Custom function for generating HCL syntax for the resource

	// Hints for adding default value to HCL representation for attributes not found in resource discovery
	defaultValuesForMissingAttributes map[string]interface{}

	// Hints for adding resource attributes to `ignore_changes` in HCL representation
	// This is added to avoid plan failure/diff for attributes that service does not return in read response
	// The attributes references are interpolated in case of nested attributes
	ignorableRequiredMissingAttributes map[string]bool
}

func (h *TerraformResourceHints) DiscoversWithSingularDatasource() bool {
	return h.datasourceItemsAttr == ""
}

type TerraformResourceAssociation struct {
	*TerraformResourceHints
	datasourceQueryParams map[string]string // Mapping of data source inputs and the source attribute from a parent resource
}

// Wrapper around string value to differentiate strings from interpolations
// Differentiation needed to write oci_resource.resource_name vs "oci_resource.resource_name" for v0.12
type InterpolationString struct {
	resourceReference string
	interpolation     string
	value             string
}

type ResourceDiscoveryError struct {
	resourceType   string
	parentResource string
	error          error
	resourceGraph  *TerraformResourceGraph
}

type ErrorList struct {
	errors []*ResourceDiscoveryError
}

/*  ctxLock is the common lock for the whole struct
WARN: Make sure NOT to pass resourceDiscoveryContext as value,
as that would copy the struct and locks should not be copied
*/
type resourceDiscoveryContext struct {
	ctxLock                     sync.Mutex // common lock for the whole context, make sure to acquire the lock before modifying any field in the resourceDiscoveryContext
	terraformProviderBinaryPath string
	terraformCLIPath            string
	terraform                   *tfexec.Terraform
	clients                     *OracleClients
	expectedResourceIds         map[string]bool
	tenancyOcid                 string
	discoveredResources         []*OCIResource
	summaryStatements           []string
	targetSpecificResources     bool
	resourceHintsLookup         map[string]*TerraformResourceHints
	*ExportCommandArgs
	errorList                    ErrorList
	missingAttributesPerResource map[string][]string
	isImportError                bool // flag indicates if there was an import failure and if reference map needs to be updated
	state                        interface{}
}

// Resource discovery Exit status
type Status int

const (
	// Exit statuses
	StatusSuccess Status = iota
	StatusFail
	StatusPartialSuccess Status = 64

	// Tags to filter resources
	OracleTagsCreatedBy           = "Oracle-Tags.CreatedBy"
	OkeTagValue                   = "oke"
	ResourceCreatedByInstancePool = "oci:compute:instancepool"
)

func (ctx *resourceDiscoveryContext) addErrorToList(error *ResourceDiscoveryError) {
	ctx.ctxLock.Lock()
	defer ctx.ctxLock.Unlock()
	ctx.errorList.errors = append(ctx.errorList.errors, error)

}

func (ctx *resourceDiscoveryContext) postValidate() {
	// Check that all expected resource IDs were found, if any were given
	var missingResourceIds []string
	for resourceId, found := range ctx.expectedResourceIds {
		if !found {
			missingResourceIds = append(missingResourceIds, resourceId)
		}
	}

	if len(missingResourceIds) > 0 {
		ctx.summaryStatements = append(ctx.summaryStatements, "")
		ctx.summaryStatements = append(ctx.summaryStatements, "Warning: The following resource IDs were not found.")
		for _, resourceId := range missingResourceIds {
			ctx.summaryStatements = append(ctx.summaryStatements, fmt.Sprintf("- %s", resourceId))
		}
		rdError := &ResourceDiscoveryError{
			"",
			"",
			fmt.Errorf("[ERROR] one or more expected resource ids were not found"),
			nil}

		ctx.addErrorToList(rdError)
	}
}

func (ctx *resourceDiscoveryContext) printSummary() {

	ctx.summaryStatements = append(ctx.summaryStatements, "=== COMPLETED ===")

	for _, statement := range ctx.summaryStatements {
		Logln(green(statement))
	}
}

func (ctx *resourceDiscoveryContext) printErrors() {
	Logln(yellow("\n\n[WARN] Resource discovery finished with errors listed below:\n"))
	for _, resourceDiscoveryError := range ctx.errorList.errors {
		if resourceDiscoveryError.resourceType == "" || ctx.targetSpecificResources {
			Logln(yellow(resourceDiscoveryError.error.Error()))

		} else if resourceDiscoveryError.parentResource == "export" {
			Logln(yellow(fmt.Sprintf("Error discovering `%s` resources: %s", resourceDiscoveryError.resourceType, resourceDiscoveryError.error.Error())))

		} else {
			Logln(yellow(fmt.Sprintf("Error discovering `%s` resources for %s: %s", resourceDiscoveryError.resourceType, resourceDiscoveryError.parentResource, resourceDiscoveryError.error.Error())))
		}
		/* log child resources if exist and were not discovered because of error in parent resource discovery*/
		if resourceDiscoveryError.resourceGraph != nil && !ctx.targetSpecificResources {
			var notFoundChildren []string
			getNotFoundChildren(resourceDiscoveryError.resourceType, resourceDiscoveryError.resourceGraph, &notFoundChildren)
			if len(notFoundChildren) > 0 {
				Logln(yellow(fmt.Sprintf("\tFollowing child resources were also not discovered due to parent error: %v", strings.Join(notFoundChildren, ", "))))
			}
		}
	}
}

func getNotFoundChildren(parent string, resourceGraph *TerraformResourceGraph, children *[]string) {
	childResources, exists := (*resourceGraph)[parent]
	if exists {
		for _, child := range childResources {
			*children = append(*children, child.resourceClass)
			// Avoid recursion if a resource can be nested within itself e.g. compartments
			if child.resourceClass != parent {
				getNotFoundChildren(child.resourceClass, resourceGraph, children)
			}
		}
	}
}

func createResourceDiscoveryContext(clients *OracleClients, args *ExportCommandArgs, tenancyOcid string) (*resourceDiscoveryContext, error) {

	result := &resourceDiscoveryContext{
		clients:             clients,
		ExportCommandArgs:   args,
		tenancyOcid:         tenancyOcid,
		discoveredResources: []*OCIResource{},
		summaryStatements:   []string{},
		errorList: ErrorList{
			errors: []*ResourceDiscoveryError{},
		},
		targetSpecificResources: false,
		resourceHintsLookup:     createResourceHintsLookupMap(),
	}
	// Use user provided terraform-provider-oci executable
	if pluginDir := getEnvSettingWithBlankDefault("provider_bin_path"); pluginDir != "" {
		result.terraformProviderBinaryPath = pluginDir
		Logf("[INFO] terraform provider binary path (pluginDir) set using `provider_bin_path`: '%s'", result.terraformProviderBinaryPath)
	}

	if *result.CompartmentId == "" {
		*result.CompartmentId = tenancyOcid
		vars["tenancy_ocid"] = fmt.Sprintf("\"%s\"", tenancyOcid)
		referenceMap[tenancyOcid] = tfHclVersion.getVarHclString("tenancy_ocid")
	} else {
		vars["compartment_ocid"] = fmt.Sprintf("\"%s\"", *result.CompartmentId)
		referenceMap[*result.CompartmentId] = tfHclVersion.getVarHclString("compartment_ocid")
	}

	result.expectedResourceIds = convertStringSliceToSet(args.IDs, true)

	re := regexp.MustCompile(`oci_([^:]+):(.+$)`)

	for id := range result.expectedResourceIds {
		subMatchAll := re.FindStringSubmatch(id)
		if subMatchAll != nil && len(subMatchAll) == 3 {
			result.targetSpecificResources = true
			break
		}
	}
	// validate terraform version and initialize terraform for import - only required if generating state file
	if args.GenerateState {
		if tf, terraformCLIPath, err := createTerraformStruct(args); err != nil {
			return result, err
		} else {
			result.terraform = tf
			result.terraformCLIPath = terraformCLIPath
		}
	}
	return result, nil
}

type resourceDiscoveryStep interface {
	discover() error
	getOmittedResources() []*OCIResource
	writeTmpConfigurationForImport() error
	writeConfiguration() error
	writeTmpState() error
	mergeGeneratedStateFile() error
	getDiscoveredResources() []*OCIResource
}

type resourceDiscoveryBaseStep struct {
	ctx                 *resourceDiscoveryContext
	name                string
	discoveredResources []*OCIResource
	omittedResources    []*OCIResource
	tempState           interface{}
}

func (r *resourceDiscoveryBaseStep) writeTmpState() error {

	// Run terraform init if not already done
	if !isInitDone {
		Debugf("[DEBUG] acquiring lock to run terraform init")
		initLock.Lock()
		// Check for existence of .terraform folder to make sure init is not run already by another thread
		if _, err := os.Stat(fmt.Sprintf("%s%s.terraform", *r.ctx.OutputDir, string(os.PathSeparator))); os.IsNotExist(err) {
			// Run init command if not already run
			Debugf("[DEBUG] writeTmpState: running init")
			backgroundCtx := context.Background()

			var initArgs []tfexec.InitOption

			if r.ctx.terraformProviderBinaryPath != "" {
				Logf("[INFO] plugin dir set to: '%s'", r.ctx.terraformProviderBinaryPath)
				initArgs = append(initArgs, tfexec.PluginDir(r.ctx.terraformProviderBinaryPath))
			}

			if err := r.ctx.terraform.Init(backgroundCtx, initArgs...); err != nil {
				return err
			}
			isInitDone = true
		}
		initLock.Unlock()
		Debugf("[DEBUG] releasing lock")
	}

	stateOutputFile := fmt.Sprintf("%s%s%s%s%s%s%s", *r.ctx.OutputDir, string(os.PathSeparator), "tmp", string(os.PathSeparator), r.name, string(os.PathSeparator), defaultStateFilename)
	tmpStateOutputFile := fmt.Sprintf("%s%s%s%s%s%s%s", *r.ctx.OutputDir, string(os.PathSeparator), "tmp", string(os.PathSeparator), r.name, string(os.PathSeparator), defaultTmpStateFile)

	if err := os.RemoveAll(tmpStateOutputFile); err != nil {
		Logf("[WARN] unable to delete existing tmp state file %s", tmpStateOutputFile)
		return err
	}

	isAllDataSources := true
	for _, resource := range r.discoveredResources {
		importResource(r.ctx, resource, tmpStateOutputFile)
		if resource.terraformTypeInfo != nil && !resource.terraformTypeInfo.isDataSource {
			isAllDataSources = false
		}
	}

	// The found resource only include the data sources (ADs and namespaces) that resource discovery adds
	if isAllDataSources {
		return nil
	}

	if _, err := os.Stat(tmpStateOutputFile); !os.IsNotExist(err) {
		if err := os.Rename(tmpStateOutputFile, stateOutputFile); err != nil {
			return err
		}
	} else {
		Logf("[WARN] temporary state file %s not found for %s: %s", stateOutputFile, r.name, err.Error())
		return nil
	}

	if jsonState, err := ioutil.ReadFile(stateOutputFile); err != nil {
		return err
	} else {
		if err := json.Unmarshal(jsonState, &r.tempState); err != nil {
			return err
		}
	}

	return nil

}

// writeTmpConfigurationForImport writes temporary configuration to run terraform import on the discovered resources
// It only writes the resource block and skips the resource fields
// The configuration will be discarded and written again after import is completed for all resources
func (r *resourceDiscoveryBaseStep) writeTmpConfigurationForImport() error {

	configOutputFile := fmt.Sprintf("%s%s%s.tf", *r.ctx.OutputDir, string(os.PathSeparator), r.name)
	tmpConfigOutputFile := fmt.Sprintf("%s%s%s.tf.tmp", *r.ctx.OutputDir, string(os.PathSeparator), r.name)

	file, err := os.OpenFile(tmpConfigOutputFile, os.O_CREATE|os.O_RDWR, 0666)
	if err != nil {
		return err
	}

	// Build the HCL config
	builder := &strings.Builder{}
	builder.WriteString("## This is tmp config to run import for resources\n\n")
	for _, resource := range r.discoveredResources {
		if resource.terraformTypeInfo != nil && resource.terraformTypeInfo.isDataSource {
			builder.WriteString(fmt.Sprintf("data %s %s {}\n\n", resource.terraformClass, resource.terraformName))
		} else {
			builder.WriteString(fmt.Sprintf("resource %s %s {}\n\n", resource.terraformClass, resource.terraformName))
		}
		r.ctx.ctxLock.Lock()
		r.ctx.discoveredResources = append(r.ctx.discoveredResources, resource)
		r.ctx.ctxLock.Unlock()
	}

	_, err = file.WriteString(string(builder.String()))
	if err != nil {
		_ = file.Close()
		return err
	}

	if fErr := file.Close(); fErr != nil {
		return fErr
	}

	if err := os.Rename(tmpConfigOutputFile, configOutputFile); err != nil {
		return err
	}
	return nil
}

func (r *resourceDiscoveryBaseStep) writeConfiguration() error {
	configOutputFile := fmt.Sprintf("%s%s%s.tf", *r.ctx.OutputDir, string(os.PathSeparator), r.name)
	tmpConfigOutputFile := fmt.Sprintf("%s%s%s.tf.tmp", *r.ctx.OutputDir, string(os.PathSeparator), r.name)

	file, err := os.OpenFile(tmpConfigOutputFile, os.O_CREATE|os.O_RDWR, 0666)
	if err != nil {
		return err
	}

	// Build the HCL config
	// Note that we still build a TF file even if no resources were discovered for this TF file.
	// A user may run this command multiple times and may see stale resources if we don't overwrite the file with
	// an empty one.
	builder := &strings.Builder{}
	builder.WriteString("## This configuration was generated by terraform-provider-oci\n\n")

	exportedResourceCount := 0
	for _, resource := range r.discoveredResources {

		// Skip writing the config for resources for which import command failed
		if !resource.isErrorResource {
			Logf("[INFO] ===> Generating resource '%s'", resource.getTerraformReference())
			if err := resource.getHCLString(builder, referenceMap); err != nil {
				_ = file.Close()
				return err
			}

			if resource.terraformTypeInfo != nil && len(resource.terraformTypeInfo.ignorableRequiredMissingAttributes) > 0 {
				attributes := make([]string, 0, len(resource.terraformTypeInfo.ignorableRequiredMissingAttributes))
				for attribute := range resource.terraformTypeInfo.ignorableRequiredMissingAttributes {
					attributes = append(attributes, attribute)
				}
				missingAttributesPerResourceLock.Lock()
				if r.ctx.missingAttributesPerResource == nil {
					r.ctx.missingAttributesPerResource = make(map[string][]string)
				}
				r.ctx.missingAttributesPerResource[resource.getTerraformReference()] = attributes
				missingAttributesPerResourceLock.Unlock()
			}

			r.ctx.discoveredResources = append(r.ctx.discoveredResources, resource)
			exportedResourceCount++
		} else {
			// remove missing attributes info if present for a failed resource
			missingAttributesPerResourceLock.Lock()
			if _, ok := r.ctx.missingAttributesPerResource[resource.getTerraformReference()]; ok {
				delete(r.ctx.missingAttributesPerResource, resource.getTerraformReference())
			}
			missingAttributesPerResourceLock.Unlock()
		}
	}

	// Format the HCL config
	formattedString := hclwrite.Format([]byte(builder.String()))

	_, err = file.WriteString(string(formattedString))
	if err != nil {
		_ = file.Close()
		return err
	}

	if fErr := file.Close(); fErr != nil {
		return fErr
	}

	if err := os.Rename(tmpConfigOutputFile, configOutputFile); err != nil {
		return err
	}

	if r.ctx.targetSpecificResources {
		r.ctx.summaryStatements = append(r.ctx.summaryStatements, fmt.Sprintf("Found %d resources. Generated under '%s'", exportedResourceCount, configOutputFile))
	} else {
		r.ctx.summaryStatements = append(r.ctx.summaryStatements, fmt.Sprintf("Found %d '%s' resources. Generated under '%s'", exportedResourceCount, r.name, configOutputFile))
	}
	return nil
}

func (r *resourceDiscoveryBaseStep) getOmittedResources() []*OCIResource {
	return r.omittedResources
}

func (r *resourceDiscoveryBaseStep) getDiscoveredResources() []*OCIResource {
	return r.discoveredResources
}

type resourceDiscoveryWithGraph struct {
	resourceDiscoveryBaseStep
	root          *OCIResource
	resourceGraph TerraformResourceGraph
}

func (r *resourceDiscoveryWithGraph) discover() error {
	var err error
	var ociResources []*OCIResource

	ociResources, err = findResources(r.ctx, r.root, r.resourceGraph)
	if err != nil {
		return err
	}

	// Filter out omitted resources from export
	r.discoveredResources = []*OCIResource{}
	r.omittedResources = []*OCIResource{}
	for _, resource := range ociResources {
		if !resource.omitFromExport {

			refMapLock.Lock()
			referenceMap[resource.id] = resource.getHclReferenceIdString()
			refMapLock.Unlock()

			r.discoveredResources = append(r.discoveredResources, resource)
		} else {
			r.omittedResources = append(r.omittedResources, resource)
		}
	}
	Logf("[INFO] Discovery complete for step root %s", r.name)
	return nil
}

type resourceDiscoveryWithTargetIds struct {
	resourceDiscoveryBaseStep
	exportIds map[string]string // map of IDs and their respective resource types
}

func createResourceHintsLookupMap() map[string]*TerraformResourceHints {
	result := map[string]*TerraformResourceHints{}

	for _, graphCollection := range []map[string]TerraformResourceGraph{compartmentResourceGraphs, tenancyResourceGraphs} {
		for _, graph := range graphCollection {
			for _, associations := range graph {
				for _, assoc := range associations {
					result[assoc.resourceClass] = assoc.TerraformResourceHints
				}
			}
		}
	}
	return result
}

func (ctx *resourceDiscoveryContext) getResourceHint(resourceClass string) (*TerraformResourceHints, error) {
	if hints, exists := ctx.resourceHintsLookup[resourceClass]; exists {
		return hints, nil
	}

	// If no resource hint could be found, just return a simple hint for now to unblock
	return nil, fmt.Errorf("[ERROR] resource type '%s' is not supported by resource discovery", resourceClass)
}

func (r *resourceDiscoveryWithTargetIds) discover() error {
	sortedIds := make([]string, len(r.ctx.expectedResourceIds))
	idx := 0
	for id, _ := range r.ctx.expectedResourceIds {
		sortedIds[idx] = id
		idx++
	}
	sort.Strings(sortedIds)

	re := regexp.MustCompile(`(oci_[^:]+):(.+$)`)

	for _, id := range sortedIds {
		subMatchAll := re.FindStringSubmatch(id)
		if len(subMatchAll) != 3 {
			Logf("[WARN] Encountered invalid ID tuple '%s'", id)
			continue
		}

		resourceClass := subMatchAll[1]
		resourceId, _ := url.PathUnescape(subMatchAll[2])

		Logf("===> Finding resource with ID '%s' and type '%s'", resourceId, resourceClass)
		resourceSchema, exists := resourcesMap[resourceClass]
		if !exists || resourceSchema.Read == nil {
			Logf("[WARN] No valid resource schema could be found. Skipping.")
			continue
		}

		d := resourceSchema.Data(nil)
		d.SetId(resourceId)
		if err := resourceSchema.Read(d, r.ctx.clients); err != nil {
			Logf("[WARN] Unable to read resource due to error: %v", err)
			continue
		}

		if d.Id() == "" {
			Logf("[WARN] Resource ID was voided because resource could not be found. Skipping.")
			continue
		}

		resourceHint, err := r.ctx.getResourceHint(resourceClass)
		if err != nil {
			continue
		}
		ociResource, err := getOciResource(d, resourceSchema.Schema, *r.ctx.CompartmentId, resourceHint, resourceId)
		if err != nil {
			return err
		}

		if resourceHint.processDiscoveredResourcesFn != nil {
			processResults, err := resourceHint.processDiscoveredResourcesFn(r.ctx, []*OCIResource{ociResource})
			if err != nil {
				return err
			}

			if len(processResults) != 1 {
				Logf("[WARN] processing of single resource resulted in %v resources being returned", len(processResults))
				continue
			}
			ociResource = processResults[0]
		}

		if ociResource.terraformName, err = generateTerraformNameFromResource(ociResource.sourceAttributes, resourceSchema.Schema); err != nil {
			terraformName := fmt.Sprintf("export_%s", resourceHint.resourceAbbreviation)
			if count, resourceNameExists := resourceNameCount[terraformName]; resourceNameExists {
				resourceNameCount[terraformName] = count + 1
				terraformName = fmt.Sprintf("%s_%d", terraformName, count)
			} else {
				resourceNameCount[terraformName] = 1
			}
			ociResource.terraformName = terraformName
		}

		r.discoveredResources = append(r.discoveredResources, ociResource)

		r.ctx.expectedResourceIds[id] = true
		// expectedResourceIds contains tuples in case of export using ids and for related resources the ids will not be a tuple
		//delete(r.ctx.expectedResourceIds, id)
		//r.ctx.expectedResourceIds[ociResource.id] = true

		if _, hasRelatedResources := exportRelatedResourcesGraph[resourceHint.resourceClass]; hasRelatedResources && r.ctx.IsExportWithRelatedResources {
			Logf("[INFO] resource discovery: finding related resources for %s\n", resourceHint.resourceClass)
			ociResources, err := findResources(r.ctx, ociResource, exportRelatedResourcesGraph)
			if err != nil {
				return err
			}
			/*
				 1. Current closure graph generates only related resources but we may need to filter resources in future as the graph grows
					Because hints use datasources and if data source does not take parent param then it may generate unrelated resources
				 2. With current implementation, resource.omitFromExport will be true for child resources but we do not filter resources. If we add filtering to handle #1,
				 	then logic to set resource.omitFromExport will also need update to handle related resources
			*/
			r.discoveredResources = append(r.discoveredResources, ociResources...)
		}
		// Add resource reference to referenceMap for discovered resources
		// If there are more than 1 resources found, this will help generate the possible references if the resources are linked
		for _, resource := range r.discoveredResources {
			referenceMap[resource.id] = resource.getHclReferenceIdString()
		}
	}
	return nil
}

type TerraformResourceGraph map[string][]TerraformResourceAssociation

type ProcessOCIResourcesFunc func(*resourceDiscoveryContext, []*OCIResource) ([]*OCIResource, error)

func init() {
	// TODO: The following changes to resource hints are deviations from what can currently be handled by the core resource discovery/generation logic
	// We should strive to eliminate these deviations by either improving the core logic or code generator

	exportObjectStorageNamespaceHints.isDataSource = true
	exportIdentityAvailabilityDomainHints.isDataSource = true

	// Custom overrides for generating composite Load Balancer IDs within the resource discovery framework
	exportLoadBalancerBackendHints.processDiscoveredResourcesFn = processLoadBalancerBackends
	exportLoadBalancerBackendSetHints.processDiscoveredResourcesFn = processLoadBalancerBackendSets
	exportLoadBalancerCertificateHints.processDiscoveredResourcesFn = processLoadBalancerCertificates
	exportLoadBalancerHostnameHints.processDiscoveredResourcesFn = processLoadBalancerHostnames
	exportLoadBalancerListenerHints.findResourcesOverrideFn = findLoadBalancerListeners
	exportLoadBalancerListenerHints.processDiscoveredResourcesFn = processLoadBalancerListeners
	exportLoadBalancerPathRouteSetHints.processDiscoveredResourcesFn = processLoadBalancerPathRouteSets
	exportLoadBalancerRuleSetHints.processDiscoveredResourcesFn = processLoadBalancerRuleSets
	exportLoadBalancerLoadBalancerRoutingPolicyHints.processDiscoveredResourcesFn = processLoadBalancerRoutingPolicies

	exportCoreBootVolumeHints.processDiscoveredResourcesFn = filterSourcedBootVolumes
	exportCoreCrossConnectGroupHints.discoverableLifecycleStates = append(exportCoreCrossConnectGroupHints.discoverableLifecycleStates, string(oci_core.CrossConnectGroupLifecycleStateInactive))
	exportCoreDhcpOptionsHints.processDiscoveredResourcesFn = processDefaultDhcpOptions
	exportCoreImageHints.processDiscoveredResourcesFn = filterCustomImages

	exportCoreInstanceHints.discoverableLifecycleStates = append(exportCoreInstanceHints.discoverableLifecycleStates, string(oci_core.InstanceLifecycleStateStopped))
	exportCoreInstanceHints.processDiscoveredResourcesFn = processInstances
	exportCorePublicIpHints.processDiscoveredResourcesFn = processCorePublicIp
	exportCorePrivateIpHints.processDiscoveredResourcesFn = processPrivateIps
	exportCoreInstanceHints.requireResourceRefresh = true
	exportCoreNetworkSecurityGroupSecurityRuleHints.datasourceClass = "oci_core_network_security_group_security_rules"
	exportCoreNetworkSecurityGroupSecurityRuleHints.datasourceItemsAttr = "security_rules"
	exportCoreNetworkSecurityGroupSecurityRuleHints.processDiscoveredResourcesFn = processNetworkSecurityGroupRules
	exportCoreRouteTableHints.processDiscoveredResourcesFn = processDefaultRouteTables
	exportCoreSecurityListHints.processDiscoveredResourcesFn = processDefaultSecurityLists
	exportCoreVcnHints.processDiscoveredResourcesFn = processCoreVcns
	exportCoreVnicAttachmentHints.requireResourceRefresh = true
	exportCoreVnicAttachmentHints.processDiscoveredResourcesFn = filterSecondaryVnicAttachments
	exportCoreVolumeGroupHints.processDiscoveredResourcesFn = processVolumeGroups

	exportDatabaseAutonomousContainerDatabaseHints.requireResourceRefresh = true
	exportDatabaseAutonomousDatabaseHints.requireResourceRefresh = true
	exportDatabaseAutonomousDatabaseHints.processDiscoveredResourcesFn = processAutonomousDatabaseSource

	exportDatabaseAutonomousExadataInfrastructureHints.requireResourceRefresh = true

	exportDatabaseDbSystemHints.requireResourceRefresh = true
	exportDatabaseDbSystemHints.processDiscoveredResourcesFn = processDbSystems

	exportDatabaseDbHomeHints.processDiscoveredResourcesFn = filterPrimaryDbHomes
	exportDatabaseDbHomeHints.requireResourceRefresh = true

	exportDatabaseDatabaseHints.requireResourceRefresh = true
	exportDatabaseDatabaseHints.processDiscoveredResourcesFn = filterPrimaryDatabases

	exportDatabaseDatabaseHints.defaultValuesForMissingAttributes = map[string]interface{}{
		"source": "NONE",
	}
	exportDatabaseDatabaseHints.processDiscoveredResourcesFn = processDatabases

	exportDatabaseExadataInfrastructureHints.processDiscoveredResourcesFn = processDatabaseExadataInfrastructures

	exportDatascienceModelHints.defaultValuesForMissingAttributes = map[string]interface{}{
		"artifact_content_length": "0",
	}
	exportIdentityAvailabilityDomainHints.resourceAbbreviation = "ad"
	exportIdentityAvailabilityDomainHints.alwaysExportable = true
	exportIdentityAvailabilityDomainHints.processDiscoveredResourcesFn = processAvailabilityDomains
	exportIdentityAvailabilityDomainHints.getHCLStringOverrideFn = getAvailabilityDomainHCLDatasource
	exportIdentityAuthenticationPolicyHints.processDiscoveredResourcesFn = processIdentityAuthenticationPolicies
	exportIdentityTagHints.findResourcesOverrideFn = findIdentityTags
	exportIdentityTagHints.processDiscoveredResourcesFn = processTagDefinitions

	exportLoggingLogHints.getIdFn = getLogId

	exportObjectStorageNamespaceHints.processDiscoveredResourcesFn = processObjectStorageNamespace
	exportObjectStorageNamespaceHints.getHCLStringOverrideFn = getObjectStorageNamespaceHCLDatasource
	exportObjectStorageNamespaceHints.alwaysExportable = true
	exportObjectStorageObjectHints.requireResourceRefresh = true
	exportObjectStoragePreauthenticatedRequestHints.processDiscoveredResourcesFn = processObjectStoragePreauthenticatedRequest
	exportObjectStorageReplicationPolicyHints.processDiscoveredResourcesFn = processObjectStorageReplicationPolicy

	exportStreamingStreamHints.processDiscoveredResourcesFn = processStreamingStream

	exportContainerengineNodePoolHints.processDiscoveredResourcesFn = processContainerengineNodePool

	exportNosqlIndexHints.processDiscoveredResourcesFn = processNosqlIndex

	exportFileStorageMountTargetHints.requireResourceRefresh = true

	exportKmsKeyHints.processDiscoveredResourcesFn = processKmsKey
	exportKmsKeyVersionHints.processDiscoveredResourcesFn = processKmsKeyVersion

	exportDnsRrsetHints.findResourcesOverrideFn = findDnsRrset
	exportDnsRrsetHints.processDiscoveredResourcesFn = processDnsRrset

	exportMysqlMysqlBackupHints.requireResourceRefresh = true
	exportMysqlMysqlBackupHints.processDiscoveredResourcesFn = filterMysqlBackups
	exportMysqlMysqlDbSystemHints.processDiscoveredResourcesFn = processMysqlDbSystem

	// Custom overrides for generating composite Network Load Balancer IDs within the resource discovery framework
	exportNetworkLoadBalancerBackendHints.processDiscoveredResourcesFn = processNetworkLoadBalancerBackends
	exportNetworkLoadBalancerBackendSetHints.processDiscoveredResourcesFn = processNetworkLoadBalancerBackendSets
	exportNetworkLoadBalancerListenerHints.processDiscoveredResourcesFn = processNetworkLoadBalancerListeners

	exportCoreDrgRouteDistributionStatementHints.datasourceClass = "oci_core_drg_route_distribution_statements"
	exportCoreDrgRouteDistributionStatementHints.datasourceItemsAttr = "drg_route_distribution_statements"
	exportCoreDrgRouteDistributionStatementHints.processDiscoveredResourcesFn = processDrgRouteDistributionStatements

	exportCoreDrgRouteTableRouteRuleHints.datasourceClass = "oci_core_drg_route_table_route_rules"
	exportCoreDrgRouteTableRouteRuleHints.datasourceItemsAttr = "drg_route_rules"
	exportCoreDrgRouteTableRouteRuleHints.processDiscoveredResourcesFn = processDrgRouteTableRouteRules
}

var loadBalancerCertificateNameMap map[string]map[string]string // helper map to generate references for certificate names, stores certificate name to certificate name interpolation

func processDnsRrset(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {

	for _, record := range resources {
		if record.parent == nil {
			continue
		}
		// Populate config file from compositeId
		record.compartmentId = record.parent.compartmentId
		domain, rtype, zoneNameOrId, _, _, err := parseRrsetCompositeId(record.id)
		if err == nil {
			record.sourceAttributes["domain"] = domain
			record.sourceAttributes["rtype"] = rtype
			record.sourceAttributes["zone_name_or_id"] = zoneNameOrId
		}
	}
	return resources, nil
}

func findDnsRrset(ctx *resourceDiscoveryContext, tfMeta *TerraformResourceAssociation, parent *OCIResource, resourceGraph *TerraformResourceGraph) (resources []*OCIResource, err error) {
	// Rrset is singular datasource only
	// and need to use GetZoneRecordsRequest to list all records
	zoneId := parent.id
	request := oci_dns.GetZoneRecordsRequest{}
	request.ZoneNameOrId = &zoneId
	response, err := ctx.clients.dnsClient().GetZoneRecords(context.Background(), request)

	if err != nil {
		return resources, err
	}

	for _, record := range response.Items {
		recordResource := resourcesMap[tfMeta.resourceClass]
		d := recordResource.TestResourceData()
		zoneId := parent.id
		domain := record.Domain
		rtype := record.Rtype
		d.SetId(getRrsetCompositeId(*domain, *rtype, zoneId))
		if err := recordResource.Read(d, ctx.clients); err != nil {
			rdError := &ResourceDiscoveryError{tfMeta.resourceClass, parent.terraformName, err, resourceGraph}
			ctx.addErrorToList(rdError)
			continue
		}
		resource := &OCIResource{
			compartmentId:    parent.compartmentId,
			sourceAttributes: convertResourceDataToMap(recordResource.Schema, d),
			rawResource:      record,
			TerraformResource: TerraformResource{
				id:             d.Id(),
				terraformClass: tfMeta.resourceClass,
				terraformName:  fmt.Sprintf("%s_%s", parent.parent.terraformName, *record.RecordHash),
			},
			getHclStringFn: getHclStringFromGenericMap,
			parent:         parent,
		}
		resources = append(resources, resource)
	}

	return resources, err
}

// Custom functions to alter behavior of resource discovery and resource HCL representation

func getModelProvenanceId(resource *OCIResource) (string, error) {
	modelId := resource.parent.id

	return getModelProvenanceCompositeId(modelId), nil
}

func processCorePublicIp(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	publicIps := []*OCIResource{}

	for _, publicIp := range resources {

		if lifeTime, exists := publicIp.sourceAttributes["lifetime"].(string); exists {
			// this is public IP created by NAT gateway
			if lifeTime == "EPHEMERAL" {
				continue
			}
		}
		publicIps = append(publicIps, publicIp)
	}

	return publicIps, nil
}

func processContainerengineNodePool(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, nodePool := range resources {
		// subnet_ids and quantity_per_subnet are deprecated and conflict with node_config_details
		if _, exists := nodePool.sourceAttributes["node_config_details"]; exists {
			if _, ok := nodePool.sourceAttributes["subnet_ids"]; ok {
				delete(nodePool.sourceAttributes, "subnet_ids")
			}
			if _, ok := nodePool.sourceAttributes["quantity_per_subnet"]; ok {
				delete(nodePool.sourceAttributes, "quantity_per_subnet")
			}
		}
	}
	return resources, nil
}

func processStreamingStream(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, streamingStream := range resources {
		// compartment_id conflict with stream_pool_id
		if _, exists := streamingStream.sourceAttributes["compartment_id"]; exists {
			if _, ok := streamingStream.sourceAttributes["stream_pool_id"]; ok {
				delete(streamingStream.sourceAttributes, "stream_pool_id")
			}
		}
	}
	return resources, nil
}

func processNosqlIndex(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, index := range resources {
		if index.parent == nil {
			continue
		}
		index.sourceAttributes["table_name_or_id"] = index.parent.id
	}
	return resources, nil
}

func processKmsKey(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, resource := range resources {
		if resource.parent == nil {
			continue
		}
		resource.sourceAttributes["management_endpoint"] = resource.parent.sourceAttributes["management_endpoint"].(string)
		var resourceSchema *schema.ResourceData = resource.rawResource.(*schema.ResourceData)
		resource.sourceAttributes["id"] = resourceSchema.Id()
	}
	return resources, nil
}

func processKmsKeyVersion(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, resource := range resources {
		if resource.parent == nil {
			continue
		}
		resource.sourceAttributes["management_endpoint"] = resource.parent.sourceAttributes["management_endpoint"].(string)
		resource.importId = resource.id
	}
	return resources, nil
}

// Custom functions to alter behavior of resource discovery and resource HCL representation

func processPrivateIps(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	privateIps := []*OCIResource{}

	for _, privateIp := range resources {

		if privateIp.hasFreeformTag(ResourceCreatedByInstancePool) {
			continue
		}

		// OKE will add tagging support, for now we rely on Automatic default tags for tenancies created after December 17, 2019
		if privateIp.hasDefinedTag(OracleTagsCreatedBy, OkeTagValue) {
			continue
		}

		privateIps = append(privateIps, privateIp)
	}

	return privateIps, nil
}

func processInstances(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	results := []*OCIResource{}

	for _, instance := range resources {
		// Omit any resources that were launched by an instance pool. Those shouldn't be managed by Terraform as they are created
		// and managed through the instance pool resource instead.
		if instance.hasFreeformTag(ResourceCreatedByInstancePool) {
			continue
		}

		// OKE will add tagging support, for now we rely on Automatic default tags for tenancies created after December 17, 2019
		if instance.hasDefinedTag(OracleTagsCreatedBy, OkeTagValue) {
			continue
		}

		// Ensure the boot volume created by this instance can be referenced elsewhere by adding it to the reference map
		if bootVolumeId, exists := instance.sourceAttributes["boot_volume_id"]; exists {
			if bootVolumeIdStr, ok := bootVolumeId.(string); ok {
				refMapLock.Lock()
				referenceMap[bootVolumeIdStr] = tfHclVersion.getDoubleExpHclString(instance.getTerraformReference(), "boot_volume_id")
				refMapLock.Unlock()
			}
		}

		if rawSourceDetailsList, sourceDetailsExist := instance.sourceAttributes["source_details"]; sourceDetailsExist {
			if sourceDetailList, ok := rawSourceDetailsList.([]interface{}); ok && len(sourceDetailList) > 0 {
				if sourceDetails, ok := sourceDetailList[0].(map[string]interface{}); ok {
					if imageId, ok := instance.sourceAttributes["image"].(string); ok {
						sourceDetails["source_id"] = imageId

						// The image OCID may be different if it's in a different tenancy or region, add a variable for users to specify
						imageVarName := fmt.Sprintf("%s_source_image_id", instance.terraformName)
						vars[imageVarName] = fmt.Sprintf("\"%s\"", imageId)
						refMapLock.Lock()
						referenceMap[imageId] = tfHclVersion.getVarHclString(imageVarName)
						refMapLock.Unlock()
					}

					// Workaround for service limitation. Service returns 47GB size for boot volume but LaunchInstance can only
					// accept sizes 50GB and above. If such a situation arises, fall back to service default values for boot volume size.
					if bootVolumeSizeInGbs, exists := sourceDetails["boot_volume_size_in_gbs"]; exists {
						bootVolumeSize, err := strconv.ParseInt(bootVolumeSizeInGbs.(string), 10, 64)
						if err != nil {
							return resources, err
						}

						if bootVolumeSize < 50 {
							delete(sourceDetails, "boot_volume_size_in_gbs")
						}
					}
				}
			}
		}

		results = append(results, instance)
	}

	return results, nil
}

func filterSecondaryVnicAttachments(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	results := []*OCIResource{}

	for _, attachment := range resources {
		// Filter out any primary vnics, as it's not necessary to create separate TF resources for those.
		datasourceSchema := datasourcesMap["oci_core_vnic"]
		if vnicReadFn := datasourceSchema.Read; vnicReadFn != nil {
			d := datasourceSchema.TestResourceData()
			d.Set("vnic_id", attachment.sourceAttributes["vnic_id"].(string))
			if err := vnicReadFn(d, ctx.clients); err != nil {
				return results, err
			}

			if isPrimaryVnic, ok := d.GetOkExists("is_primary"); ok && isPrimaryVnic.(bool) {
				continue
			}
		}
		results = append(results, attachment)
	}

	return results, nil
}

func filterMysqlBackups(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	results := []*OCIResource{}

	// Filter out Mysql Backups that are automatically created. We cannot operate on "Automatic" backups.
	for _, backup := range resources {
		sourceDetails, exists := backup.sourceAttributes["creation_type"]

		if exists && sourceDetails.(string) == "AUTOMATIC" {
			continue
		}

		results = append(results, backup)
	}

	return results, nil
}

// TODO: remove this when service fixes source
func processMysqlDbSystem(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, dbSystem := range resources {
		if source, exists := dbSystem.sourceAttributes["source"]; exists {
			if sourceList := source.([]interface{}); len(sourceList) > 0 {
				if sourceMap, ok := sourceList[0].(map[string]interface{}); ok {
					if sourceMap["source_type"].(string) == "NONE" {
						delete(dbSystem.sourceAttributes, "source")
					}
				}
			}
		}
	}

	return resources, nil
}

func filterSourcedBootVolumes(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	results := []*OCIResource{}

	// Filter out boot volumes that don't have source details. We cannot create boot volumes unless they have source details.
	for _, bootVolume := range resources {
		sourceDetails, exists := bootVolume.sourceAttributes["source_details"]
		if !exists {
			continue
		}

		if sourceDetailsList, ok := sourceDetails.([]interface{}); !ok || len(sourceDetailsList) == 0 {
			continue
		}

		results = append(results, bootVolume)
	}

	return results, nil
}

func processAvailabilityDomains(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for idx, ad := range resources {
		ad.sourceAttributes["index"] = idx + 1

		adName, ok := ad.sourceAttributes["name"].(string)
		if !ok || adName == "" {
			return resources, fmt.Errorf("[ERROR] availability domain at index '%v' has no name\n", idx)
		}
		refMapLock.Lock()
		referenceMap[adName] = tfHclVersion.getDataSourceHclString(ad.getTerraformReference(), "name")
		refMapLock.Unlock()
	}

	return resources, nil
}

func processObjectStorageNamespace(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, ns := range resources {
		namespaceName, ok := ns.sourceAttributes["namespace"].(string)
		if !ok || namespaceName == "" {
			return resources, fmt.Errorf("[ERROR] object storage namespace data source has no name\n")
		}
		refMapLock.Lock()
		referenceMap[namespaceName] = tfHclVersion.getDataSourceHclString(ns.getTerraformReference(), "namespace")
		refMapLock.Unlock()
	}

	return resources, nil
}

func getAvailabilityDomainHCLDatasource(builder *strings.Builder, ociRes *OCIResource, varMap map[string]string) error {
	builder.WriteString(fmt.Sprintf("data %s %s {\n", ociRes.terraformClass, ociRes.terraformName))

	builder.WriteString(fmt.Sprintf("compartment_id = %v\n", varMap[ociRes.compartmentId]))

	adIndex, ok := ociRes.sourceAttributes["index"]
	if !ok {
		return fmt.Errorf("[ERROR] no index found for availability domain '%s'", ociRes.getTerraformReference())
	}
	builder.WriteString(fmt.Sprintf("ad_number = \"%v\"\n", adIndex.(int)))
	builder.WriteString("}\n")

	return nil
}

func getObjectStorageNamespaceHCLDatasource(builder *strings.Builder, ociRes *OCIResource, varMap map[string]string) error {
	builder.WriteString(fmt.Sprintf("data %s %s {\n", ociRes.terraformClass, ociRes.terraformName))
	builder.WriteString(fmt.Sprintf("compartment_id = %v\n", varMap[ociRes.compartmentId]))
	builder.WriteString("}\n")

	return nil
}

func filterCustomImages(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	results := []*OCIResource{}

	// Filter out official images that are predefined by Oracle. We cannot manage such images in Terraform.
	// Official images have a null or empty compartment ID.
	for _, image := range resources {
		compartmentId, exists := image.sourceAttributes["compartment_id"]
		if !exists {
			continue
		}

		if compartmentIdString, ok := compartmentId.(string); !ok || len(compartmentIdString) == 0 {
			continue
		}

		results = append(results, image)
	}

	return results, nil
}

func processVolumeGroups(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	// Replace the volume group's source details volume list with the actual volume list
	// The source details only captures the list of volumes that were known when the group was created.
	// Additional volumes may have been added since and should be part of the source_details that we generate.
	// TODO: This is a shortcoming that should be addressed by the service and/or the Terraform
	for _, group := range resources {
		volumeIdsRaw, exists := group.sourceAttributes["volume_ids"]
		if !exists {
			continue
		}

		if volumeIds, ok := volumeIdsRaw.([]interface{}); ok && len(volumeIds) > 0 {
			sourceDetailsRaw, detailsExist := group.sourceAttributes["source_details"]
			if !detailsExist {
				continue
			}

			sourceDetails := sourceDetailsRaw.([]interface{})[0].(map[string]interface{})
			sourceDetails["volume_ids"] = volumeIds
		}
	}

	return resources, nil
}

func processLoadBalancerBackendSets(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, backendSet := range resources {
		if backendSet.parent == nil {
			continue
		}

		backendSetName := backendSet.sourceAttributes["name"].(string)
		backendSet.id = getBackendSetCompositeId(backendSetName, backendSet.parent.id)
		backendSet.sourceAttributes["load_balancer_id"] = backendSet.parent.id
	}

	return resources, nil
}

func processLoadBalancerBackends(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, backend := range resources {
		if backend.parent == nil {
			continue
		}

		backend.id = getBackendCompositeId(backend.sourceAttributes["name"].(string), backend.parent.sourceAttributes["name"].(string), backend.parent.sourceAttributes["load_balancer_id"].(string))
		backend.sourceAttributes["load_balancer_id"] = backend.parent.sourceAttributes["load_balancer_id"].(string)

		// Don't use references to parent resources if they will be omitted from final result
		if !backend.parent.omitFromExport {
			backend.sourceAttributes["backendset_name"] = InterpolationString{
				resourceReference: backend.parent.getTerraformReference(),
				interpolation:     tfHclVersion.getDoubleExpHclString(backend.parent.getTerraformReference(), "name"),
				value:             backend.parent.sourceAttributes["name"].(string),
			}
		} else {
			backend.sourceAttributes["backendset_name"] = backend.parent.sourceAttributes["name"].(string)
		}
	}

	return resources, nil
}

func processLoadBalancerHostnames(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, hostname := range resources {
		if hostname.parent == nil {
			continue
		}

		hostname.id = getHostnameCompositeId(hostname.parent.id, hostname.sourceAttributes["name"].(string))
		hostname.sourceAttributes["load_balancer_id"] = hostname.parent.id
	}

	return resources, nil
}

func processLoadBalancerPathRouteSets(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, pathRouteSet := range resources {
		if pathRouteSet.parent == nil {
			continue
		}

		pathRouteSet.id = getPathRouteSetCompositeId(pathRouteSet.parent.id, pathRouteSet.sourceAttributes["name"].(string))
		pathRouteSet.sourceAttributes["load_balancer_id"] = pathRouteSet.parent.id
	}

	return resources, nil
}

func processLoadBalancerRoutingPolicies(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, routingPolicy := range resources {
		if routingPolicy.parent == nil {
			continue
		}

		routingPolicy.id = getLoadBalancerRoutingPolicyCompositeId(routingPolicy.parent.id, routingPolicy.sourceAttributes["name"].(string))
		routingPolicy.sourceAttributes["load_balancer_id"] = routingPolicy.parent.id
	}

	return resources, nil
}

func processLoadBalancerRuleSets(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, ruleSet := range resources {
		if ruleSet.parent == nil {
			continue
		}

		ruleSet.id = getRuleSetCompositeId(ruleSet.parent.id, ruleSet.sourceAttributes["name"].(string))
		ruleSet.sourceAttributes["load_balancer_id"] = ruleSet.parent.id
	}

	return resources, nil
}

func processLoadBalancerCertificates(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, certificate := range resources {
		if certificate.parent == nil {
			continue
		}

		certificate.id = getCertificateCompositeId(certificate.sourceAttributes["certificate_name"].(string), certificate.parent.id)
		certificate.sourceAttributes["load_balancer_id"] = certificate.parent.id

		// add certificate name and interpolation to loadBalancerCertificateNameMap
		if loadBalancerCertificateNameMap == nil {
			loadBalancerCertificateNameMap = make(map[string]map[string]string)
		}
		_, ok := loadBalancerCertificateNameMap[certificate.parent.id]
		if !ok {
			loadBalancerCertificateNameMap[certificate.parent.id] = make(map[string]string)
		}

		if certificateName, ok := certificate.sourceAttributes["certificate_name"].(string); ok {
			loadBalancerCertificateNameMap[certificate.parent.id][certificateName] = tfHclVersion.getDoubleExpHclString(certificate.getTerraformReference(), "certificate_name")
		}
	}

	return resources, nil
}

func processObjectStoragePreauthenticatedRequest(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, resource := range resources {
		if resource.parent == nil {
			continue
		}
		resource.sourceAttributes["bucket"] = resource.parent.sourceAttributes["name"].(string)
		resource.sourceAttributes["namespace"] = resource.parent.sourceAttributes["namespace"].(string)

		// Check if time is already in RFC3339Nano format
		timeExpires, err := time.Parse(time.RFC3339Nano, resource.sourceAttributes["time_expires"].(string))
		if err != nil {
			// parse time using format in time.String()
			timeExpires, err = time.Parse("2006-01-02 15:04:05.999999999 -0700 MST", resource.sourceAttributes["time_expires"].(string))
			if err != nil {
				return resources, err
			}
			// Format to RFC3339Nano
			resource.sourceAttributes["time_expires"] = timeExpires.Format(time.RFC3339Nano)
		}

	}
	return resources, nil
}

func processAutonomousDatabaseSource(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, resource := range resources {
		if resource.sourceAttributes["is_refreshable_clone"] == true {
			resource.sourceAttributes["source"] = "CLONE_TO_REFRESHABLE"
		}
	}
	return resources, nil
}

func processObjectStorageReplicationPolicy(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, resource := range resources {
		if resource.parent == nil {
			continue
		}
		resource.sourceAttributes["bucket"] = resource.parent.sourceAttributes["name"].(string)
		resource.sourceAttributes["namespace"] = resource.parent.sourceAttributes["namespace"].(string)
	}
	return resources, nil
}

func processNetworkLoadBalancerBackendSets(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, backendSet := range resources {
		if backendSet.parent == nil {
			continue
		}

		backendSetName := backendSet.sourceAttributes["name"].(string)
		backendSet.id = getNlbBackendSetCompositeId(backendSetName, backendSet.parent.id)
		backendSet.sourceAttributes["network_load_balancer_id"] = backendSet.parent.id
	}

	return resources, nil
}

func processNetworkLoadBalancerBackends(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, backend := range resources {
		if backend.parent == nil {
			continue
		}

		backend.id = getNlbBackendCompositeId(backend.sourceAttributes["name"].(string), backend.parent.sourceAttributes["name"].(string), backend.parent.sourceAttributes["network_load_balancer_id"].(string))
		backend.sourceAttributes["network_load_balancer_id"] = backend.parent.sourceAttributes["network_load_balancer_id"].(string)

		// Don't use references to parent resources if they will be omitted from final result
		if !backend.parent.omitFromExport {
			backend.sourceAttributes["backend_set_name"] = InterpolationString{
				resourceReference: backend.parent.getTerraformReference(),
				interpolation:     tfHclVersion.getDoubleExpHclString(backend.parent.getTerraformReference(), "name"),
				value:             backend.parent.sourceAttributes["name"].(string),
			}
		} else {
			backend.sourceAttributes["backend_set_name"] = backend.parent.sourceAttributes["name"].(string)
		}
	}

	return resources, nil
}

func processNetworkLoadBalancerListeners(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, listener := range resources {
		if listener.parent == nil {
			continue
		}

		listenerName := listener.sourceAttributes["name"].(string)
		listener.id = getNlbListenerCompositeId(listenerName, listener.parent.sourceAttributes["network_load_balancer_id"].(string))
		listener.sourceAttributes["network_load_balancer_id"] = listener.parent.sourceAttributes["network_load_balancer_id"].(string)

		// Don't use references to parent resources if they will be omitted from final result
		if !listener.parent.omitFromExport {
			listener.sourceAttributes["default_backend_set_name"] = InterpolationString{
				resourceReference: listener.parent.getTerraformReference(),
				interpolation:     tfHclVersion.getDoubleExpHclString(listener.parent.getTerraformReference(), "name"),
				value:             listener.parent.sourceAttributes["name"].(string),
			}
		} else {
			listener.sourceAttributes["default_backend_set_name"] = listener.parent.sourceAttributes["name"].(string)
		}
	}

	return resources, nil
}

func findIdentityTags(ctx *resourceDiscoveryContext, tfMeta *TerraformResourceAssociation, parent *OCIResource, resourceGraph *TerraformResourceGraph) ([]*OCIResource, error) {
	// List on Tags does not return validator, and resource Read requires tagNamespaceId
	// which is also not returned in Summary response. Tags also do not have composite id in state.
	// Getting tags using ListTagsRequest and the calling tagResource.Read
	tagNamespaceId := parent.id
	request := oci_identity.ListTagsRequest{}

	request.TagNamespaceId = &tagNamespaceId

	request.RequestMetadata.RetryPolicy = getRetryPolicy(true, "identity")
	results := []*OCIResource{}

	response, err := ctx.clients.identityClient().ListTags(context.Background(), request)
	if err != nil {
		return results, err
	}

	request.Page = response.OpcNextPage

	for request.Page != nil {
		listResponse, err := ctx.clients.identityClient().ListTags(context.Background(), request)
		if err != nil {
			return results, err
		}

		response.Items = append(response.Items, listResponse.Items...)
		request.Page = listResponse.OpcNextPage
	}

	for _, tag := range response.Items {
		tagResource := resourcesMap[tfMeta.resourceClass]

		d := tagResource.TestResourceData()
		d.SetId(getIdentityTagCompositeId(*tag.Name, parent.id))

		if err := tagResource.Read(d, ctx.clients); err != nil {
			rdError := &ResourceDiscoveryError{tfMeta.resourceClass, parent.terraformName, err, resourceGraph}
			ctx.addErrorToList(rdError)
			continue
		}

		resource := &OCIResource{
			compartmentId:    parent.compartmentId,
			sourceAttributes: convertResourceDataToMap(tagResource.Schema, d),
			rawResource:      tag,
			TerraformResource: TerraformResource{
				id:             d.Id(),
				terraformClass: tfMeta.resourceClass,
			},
			getHclStringFn: getHclStringFromGenericMap,
			parent:         parent,
		}

		if resource.terraformName, err = generateTerraformNameFromResource(resource.sourceAttributes, tagResource.Schema); err != nil {
			resource.terraformName = fmt.Sprintf("%s_%s", parent.parent.terraformName, *tag.Name)
		}

		results = append(results, resource)
	}

	return results, nil

}

func findLoadBalancerListeners(ctx *resourceDiscoveryContext, tfMeta *TerraformResourceAssociation, parent *OCIResource, resourceGraph *TerraformResourceGraph) ([]*OCIResource, error) {
	loadBalancerId := parent.sourceAttributes["load_balancer_id"].(string)
	backendSetName := parent.sourceAttributes["name"].(string)

	request := oci_load_balancer.GetLoadBalancerRequest{}
	request.LoadBalancerId = &loadBalancerId
	request.RequestMetadata.RetryPolicy = getRetryPolicy(true, "load_balancer")

	response, err := ctx.clients.loadBalancerClient().GetLoadBalancer(context.Background(), request)
	if err != nil {
		return nil, err
	}

	listenerResource := resourcesMap[tfMeta.resourceClass]

	results := []*OCIResource{}
	for listenerName, listener := range response.LoadBalancer.Listeners {
		if *listener.DefaultBackendSetName != backendSetName {
			continue
		}

		d := listenerResource.TestResourceData()
		d.SetId(getListenerCompositeId(listenerName, loadBalancerId))

		// This calls into the listener resource's Read fn which has the unfortunate implementation of
		// calling GetLoadBalancer and looping through the listeners to find the expected one. So this entire method
		// may require O(n^^2) time. However, the benefits of having Read populate the ResourceData struct is better than duplicating it here.
		if err := listenerResource.Read(d, ctx.clients); err != nil {
			// add error to the errorList and continue discovering rest of the resources
			rdError := &ResourceDiscoveryError{tfMeta.resourceClass, parent.terraformName, err, resourceGraph}
			ctx.addErrorToList(rdError)
			continue
		}

		resource := &OCIResource{
			compartmentId:    parent.compartmentId,
			sourceAttributes: convertResourceDataToMap(listenerResource.Schema, d),
			rawResource:      listener,
			TerraformResource: TerraformResource{
				id:             d.Id(),
				terraformClass: tfMeta.resourceClass,
				terraformName:  fmt.Sprintf("%s_%s", parent.parent.terraformName, listenerName),
			},
			getHclStringFn: getHclStringFromGenericMap,
			parent:         parent,
		}

		if !parent.omitFromExport {
			resource.sourceAttributes["default_backend_set_name"] = InterpolationString{
				resourceReference: parent.getTerraformReference(),
				interpolation:     tfHclVersion.getDoubleExpHclString(parent.getTerraformReference(), "name"),
				value:             parent.sourceAttributes["name"].(string),
			}
		} else {
			resource.sourceAttributes["default_backend_set_name"] = parent.sourceAttributes["name"].(string)
		}
		results = append(results, resource)
	}

	return results, nil
}

func processLoadBalancerListeners(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {

	for _, resource := range resources {
		if resource.parent == nil {
			continue
		}
		if sslConfiguration, ok := resource.sourceAttributes["ssl_configuration"].([]interface{}); ok && len(sslConfiguration) > 0 {
			if sslConfig, ok := sslConfiguration[0].(map[string]interface{}); ok {
				if certificateName, ok := sslConfig["certificate_name"]; ok {
					// check if we have expected ResourceIds set, is load balancer certificate id expected
					if ctx.expectedResourceIds != nil && len(ctx.expectedResourceIds) > 0 {
						certificateId := getCertificateCompositeId(certificateName.(string), resource.sourceAttributes["load_balancer_id"].(string))
						if _, ok = ctx.expectedResourceIds[certificateId]; !ok {
							continue
						}
					}
					sslConfig["certificate_name"] = InterpolationString{
						resource.parent.getTerraformReference(),
						loadBalancerCertificateNameMap[resource.parent.parent.id][sslConfig["certificate_name"].(string)],
						sslConfig["certificate_name"].(string),
					}
				}
			}
		}
	}
	return resources, nil
}

func processTagDefinitions(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, resource := range resources {
		if resource.parent == nil {
			resource.importId = fmt.Sprintf("tagNamespaces/%s/tags/%s", resource.sourceAttributes["tag_namespace_id"], resource.sourceAttributes["name"].(string))
			continue
		}

		resource.sourceAttributes["tag_namespace_id"] = resource.parent.id
		resource.importId = fmt.Sprintf("tagNamespaces/%s/tags/%s", resource.parent.id, resource.sourceAttributes["name"].(string))
		resource.id = resource.importId
	}
	return resources, nil
}

func processNetworkSecurityGroupRules(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, resource := range resources {
		if resource.parent == nil {
			continue
		}

		resource.sourceAttributes["network_security_group_id"] = resource.parent.id
	}
	return resources, nil
}

func processDrgRouteDistributionStatements(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, resource := range resources {
		if resource.parent == nil {
			continue
		}
		resource.sourceAttributes["drg_route_distribution_id"] = resource.parent.id
	}
	return resources, nil
}

func processDrgRouteTableRouteRules(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	for _, resource := range resources {
		if resource.parent == nil {
			continue
		}
		resource.sourceAttributes["drg_route_table_id"] = resource.parent.id
	}
	return resources, nil
}

func filterPrimaryDbHomes(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	// No need to filter if db homes are in vm cluster
	if len(resources) > 0 && resources[0].parent != nil && resources[0].parent.terraformClass == "oci_database_vm_cluster" {
		return resources, nil
	}
	results := []*OCIResource{}
	for _, resource := range resources {
		if resource.parent == nil {
			continue
		}
		// If we found a db home that matches the db system's primary home, then don't return it as part of result
		if dbSystem := resource.parent; dbSystem != nil {
			if dbHomes, ok := dbSystem.sourceAttributes["db_home"].([]interface{}); ok && len(dbHomes) > 0 {
				if primaryDbHome, ok := dbHomes[0].(map[string]interface{}); ok {
					if primaryDbHomeId, ok := primaryDbHome["id"]; ok && primaryDbHomeId.(string) == resource.id {
						continue
					}
				}
			}
		}
		// Fix db version to remove the PSU date from versions with 18+ major version
		if dbVersion, ok := resource.sourceAttributes["db_version"].(string); ok {
			resource.sourceAttributes["db_version"] = getValidDbVersion(dbVersion)
		}
		results = append(results, resource)
	}
	return results, nil
}

func filterPrimaryDatabases(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	results := []*OCIResource{}
	for _, resource := range resources {
		if resource.parent == nil {
			continue
		}
		// Only return database resources that don't match the database ID of the dbHome resource.
		if databases, ok := resource.parent.sourceAttributes["database"].([]interface{}); ok && len(databases) > 0 {
			if primaryDatabase, ok := databases[0].(map[string]interface{}); ok {
				if primaryDatabaseId, ok := primaryDatabase["id"]; ok && primaryDatabaseId.(string) != resource.id {
					results = append(results, resource)
				}
			}
		}
	}
	return results, nil
}

func processIdentityAuthenticationPolicies(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	// Add composite id as the resource's import ID
	for _, resource := range resources {
		resource.importId = getAuthenticationPolicyCompositeId(resource.compartmentId)
		resource.id = resource.importId
	}
	return resources, nil
}

func processDefaultSecurityLists(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	// Default security lists need to be handled as default resources
	for _, resource := range resources {
		if resource.parent == nil {
			continue
		}

		if resource.id == resource.parent.sourceAttributes["default_security_list_id"].(string) {
			resource.sourceAttributes["manage_default_resource_id"] = resource.id
			resource.TerraformResource.terraformClass = "oci_core_default_security_list"

			// Don't use references to parent resources if they will be omitted from final result
			if !resource.parent.omitFromExport {
				resource.TerraformResource.terraformReferenceIdString = fmt.Sprintf("%s.%s", resource.parent.getTerraformReference(), "default_security_list_id")
			}
		}
	}
	return resources, nil
}

func processDefaultRouteTables(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	// Default route tables need to be handled as default resources
	for _, resource := range resources {
		if resource.parent == nil {
			continue
		}

		if resource.id == resource.parent.sourceAttributes["default_route_table_id"].(string) {
			resource.sourceAttributes["manage_default_resource_id"] = resource.id
			resource.TerraformResource.terraformClass = "oci_core_default_route_table"

			// Don't use references to parent resources if they will be omitted from final result
			if !resource.parent.omitFromExport {
				resource.TerraformResource.terraformReferenceIdString = fmt.Sprintf("%s.%s", resource.parent.getTerraformReference(), "default_route_table_id")
			}
		}
	}
	return resources, nil
}

func processDefaultDhcpOptions(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	// Default dhcp options need to be handled as default resources
	for _, resource := range resources {
		if resource.parent == nil {
			continue
		}

		if resource.id == resource.parent.sourceAttributes["default_dhcp_options_id"].(string) {
			resource.sourceAttributes["manage_default_resource_id"] = resource.id
			resource.TerraformResource.terraformClass = "oci_core_default_dhcp_options"

			// Don't use references to parent resources if they will be omitted from final result
			if !resource.parent.omitFromExport {
				resource.TerraformResource.terraformReferenceIdString = fmt.Sprintf("%s.%s", resource.parent.getTerraformReference(), "default_dhcp_options_id")
			}
		}
	}
	return resources, nil
}

func processDbSystems(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	// Fix db version to remove the PSU date from versions with 18+ major version
	for _, resource := range resources {
		if dbHomes, ok := resource.sourceAttributes["db_home"].([]interface{}); ok {
			if dbHome, ok := dbHomes[0].(map[string]interface{}); ok {
				if dbVersion, ok := dbHome["db_version"].(string); ok {
					dbHome["db_version"] = getValidDbVersion(dbVersion)
				}
			}
		}
	}
	return resources, nil
}

func processDatabases(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	// Fix database db version to remove the PSU date from versions with 18+ major version
	for _, resource := range resources {
		if databases, ok := resource.sourceAttributes["database"].([]interface{}); ok {
			if database, ok := databases[0].(map[string]interface{}); ok {
				if dbVersion, ok := database["db_version"].(string); ok {
					database["db_version"] = getValidDbVersion(dbVersion)
				}
			}
		}
	}
	return resources, nil
}

func processDatabaseExadataInfrastructures(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	// Remove weeks_of_month if there is no item in response
	for _, resource := range resources {
		if maintenanceWindow, ok := resource.sourceAttributes["maintenance_window"].([]interface{}); ok {
			if mWindow, ok := maintenanceWindow[0].(map[string]interface{}); ok {
				if weeksOfMonth, ok := mWindow["weeks_of_month"].([]interface{}); ok && len(weeksOfMonth) == 0 {
					delete(mWindow, "weeks_of_month")
				}
			}
		}
	}
	return resources, nil
}

func getValidDbVersion(dbVersion string) string {
	/*
		For 11.2.0.4, 12.1.0.2 and 12.2.0.1, the PSU is added as the 5th digit. So when the customer specifies either of these,
		service will be returning 11.2.0.4.xxxxxx where the last part is the PSU version.
		For 18.0.0.0 and 19.0.0.0 onwards, the second digit specifies the PSU version and the fifth digit specifies the date for that PSU.
		(The PSU-date pair change hand in hand)
		* For pre 18 versions, service returns 5th digit in response and 5 digit version is valid for create
		* For 18+ versions, service will return PSU date but only 4 digit version is valid for create.
		* Resource discovery will keep only 4 digits in config and dbVersionDiffSuppress will handle the diff
	*/
	parts := strings.Split(dbVersion, ".")
	if strings.Compare(parts[0], "18") == 1 {
		return strings.Join(parts[0:4], ".")
	}
	return dbVersion
}

func getLogId(resource *OCIResource) (string, error) {
	logId, ok := resource.sourceAttributes["id"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find log_id for Log")
	}
	logGroupId := resource.parent.id
	return getLogCompositeId(logGroupId, logId), nil
}

func processCoreVcns(ctx *resourceDiscoveryContext, resources []*OCIResource) ([]*OCIResource, error) {
	// remove deprecated cidr_block field from discovered vcns,
	// either cidr_block or cidr_blocks should be specified in config
	// service returns the cidr_block value in cidr_blocks field
	for _, resource := range resources {
		if _, ok := resource.sourceAttributes["cidr_block"].(string); ok {
			delete(resource.sourceAttributes, "cidr_block")
		}
	}
	return resources, nil
}

/*
mergeState merges 2 json state files
*/
func mergeState(state1 interface{}, state2 interface{}) (interface{}, error) {

	state1Bytes, _ := json.MarshalIndent(state1, "", "\t")
	state2Bytes, _ := json.MarshalIndent(state2, "", "\t")

	out1 := map[string]interface{}{}
	if err := json.Unmarshal(state1Bytes, &out1); err != nil {
		return out1, fmt.Errorf("[ERROR] error occurred while generating state file for resource discovery: %s", err.Error())
	}

	out2 := map[string]interface{}{}
	if err := json.Unmarshal(state2Bytes, &out2); err != nil {
		return out1, fmt.Errorf("[ERROR] error occurred while generating state file for resource discovery: %s", err.Error())
	}

	state1resources, _ := out1["resources"].([]interface{})
	state2resources, _ := out2["resources"].([]interface{})

	out1["resources"] = append(state1resources, state2resources...)

	return out1, nil

}

func (r *resourceDiscoveryBaseStep) mergeGeneratedStateFile() error {
	if r.tempState == nil {
		return nil
	}
	Debugf("[DEBUG] merging state file for %s", r.name)
	if r.ctx.state == nil {
		// if state exists for the step, initialize the final state
		r.ctx.state = r.tempState
	} else {
		// merge the state for step to final state
		r.ctx.state, _ = mergeState(r.ctx.state, r.tempState)
	}

	return nil

}
