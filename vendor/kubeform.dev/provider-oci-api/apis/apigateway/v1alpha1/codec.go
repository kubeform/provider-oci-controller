/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecification{}).Type1()):                                                                        DeploymentSpecSpecificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationLoggingPolicies{}).Type1()):                                                         DeploymentSpecSpecificationLoggingPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationLoggingPoliciesAccessLog{}).Type1()):                                                DeploymentSpecSpecificationLoggingPoliciesAccessLogCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationLoggingPoliciesExecutionLog{}).Type1()):                                             DeploymentSpecSpecificationLoggingPoliciesExecutionLogCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPolicies{}).Type1()):                                                         DeploymentSpecSpecificationRequestPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesAuthentication{}).Type1()):                                           DeploymentSpecSpecificationRequestPoliciesAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys{}).Type1()):                                 DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeysCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesCors{}).Type1()):                                                     DeploymentSpecSpecificationRequestPoliciesCorsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesMutualTls{}).Type1()):                                                DeploymentSpecSpecificationRequestPoliciesMutualTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesRateLimiting{}).Type1()):                                             DeploymentSpecSpecificationRequestPoliciesRateLimitingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesBackend{}).Type1()):                                                           DeploymentSpecSpecificationRoutesBackendCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesLoggingPolicies{}).Type1()):                                                   DeploymentSpecSpecificationRoutesLoggingPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog{}).Type1()):                                          DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLogCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog{}).Type1()):                                       DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLogCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPolicies{}).Type1()):                                                   DeploymentSpecSpecificationRoutesRequestPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization{}).Type1()):                                      DeploymentSpecSpecificationRoutesRequestPoliciesAuthorizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation{}).Type1()):                                     DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesCors{}).Type1()):                                               DeploymentSpecSpecificationRoutesRequestPoliciesCorsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations{}).Type1()):                              DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders{}).Type1()):                 DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders{}).Type1()):                 DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders{}).Type1()):                    DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations{}).Type1()):                                  DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations{}).Type1()):                      DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters{}).Type1()): DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters{}).Type1()): DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters{}).Type1()):    DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations{}).Type1()):                          DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup{}).Type1()):                                DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePolicies{}).Type1()):                                                  DeploymentSpecSpecificationRoutesResponsePoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations{}).Type1()):                             DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders{}).Type1()):                DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders{}).Type1()):                DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders{}).Type1()):                   DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore{}).Type1()):                                DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStoreCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewaySpecResponseCacheDetails{}).Type1()):                                                                    GatewaySpecResponseCacheDetailsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecification{}).Type1()):                                                                        DeploymentSpecSpecificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationLoggingPolicies{}).Type1()):                                                         DeploymentSpecSpecificationLoggingPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationLoggingPoliciesAccessLog{}).Type1()):                                                DeploymentSpecSpecificationLoggingPoliciesAccessLogCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationLoggingPoliciesExecutionLog{}).Type1()):                                             DeploymentSpecSpecificationLoggingPoliciesExecutionLogCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPolicies{}).Type1()):                                                         DeploymentSpecSpecificationRequestPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesAuthentication{}).Type1()):                                           DeploymentSpecSpecificationRequestPoliciesAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys{}).Type1()):                                 DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeysCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesCors{}).Type1()):                                                     DeploymentSpecSpecificationRequestPoliciesCorsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesMutualTls{}).Type1()):                                                DeploymentSpecSpecificationRequestPoliciesMutualTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesRateLimiting{}).Type1()):                                             DeploymentSpecSpecificationRequestPoliciesRateLimitingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesBackend{}).Type1()):                                                           DeploymentSpecSpecificationRoutesBackendCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesLoggingPolicies{}).Type1()):                                                   DeploymentSpecSpecificationRoutesLoggingPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog{}).Type1()):                                          DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLogCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog{}).Type1()):                                       DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLogCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPolicies{}).Type1()):                                                   DeploymentSpecSpecificationRoutesRequestPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization{}).Type1()):                                      DeploymentSpecSpecificationRoutesRequestPoliciesAuthorizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation{}).Type1()):                                     DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesCors{}).Type1()):                                               DeploymentSpecSpecificationRoutesRequestPoliciesCorsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations{}).Type1()):                              DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders{}).Type1()):                 DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders{}).Type1()):                 DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders{}).Type1()):                    DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations{}).Type1()):                                  DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations{}).Type1()):                      DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters{}).Type1()): DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters{}).Type1()): DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters{}).Type1()):    DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations{}).Type1()):                          DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup{}).Type1()):                                DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePolicies{}).Type1()):                                                  DeploymentSpecSpecificationRoutesResponsePoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations{}).Type1()):                             DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders{}).Type1()):                DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders{}).Type1()):                DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders{}).Type1()):                   DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore{}).Type1()):                                DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStoreCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewaySpecResponseCacheDetails{}).Type1()):                                                                    GatewaySpecResponseCacheDetailsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationCodec struct {
}

func (DeploymentSpecSpecificationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecification)(ptr) == nil
}

func (DeploymentSpecSpecificationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecification)(ptr)
	var objs []DeploymentSpecSpecification
	if obj != nil {
		objs = []DeploymentSpecSpecification{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecification{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecification)(ptr) = DeploymentSpecSpecification{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecification

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecification{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecification)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecification)(ptr) = DeploymentSpecSpecification{}
			}
		} else {
			*(*DeploymentSpecSpecification)(ptr) = DeploymentSpecSpecification{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecification

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecification{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecification)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecification)(ptr) = DeploymentSpecSpecification{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecification", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationLoggingPoliciesCodec struct {
}

func (DeploymentSpecSpecificationLoggingPoliciesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationLoggingPolicies)(ptr) == nil
}

func (DeploymentSpecSpecificationLoggingPoliciesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationLoggingPolicies)(ptr)
	var objs []DeploymentSpecSpecificationLoggingPolicies
	if obj != nil {
		objs = []DeploymentSpecSpecificationLoggingPolicies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationLoggingPolicies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationLoggingPoliciesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationLoggingPolicies)(ptr) = DeploymentSpecSpecificationLoggingPolicies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationLoggingPolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationLoggingPolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationLoggingPolicies)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationLoggingPolicies)(ptr) = DeploymentSpecSpecificationLoggingPolicies{}
			}
		} else {
			*(*DeploymentSpecSpecificationLoggingPolicies)(ptr) = DeploymentSpecSpecificationLoggingPolicies{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationLoggingPolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationLoggingPolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationLoggingPolicies)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationLoggingPolicies)(ptr) = DeploymentSpecSpecificationLoggingPolicies{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationLoggingPolicies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationLoggingPoliciesAccessLogCodec struct {
}

func (DeploymentSpecSpecificationLoggingPoliciesAccessLogCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationLoggingPoliciesAccessLog)(ptr) == nil
}

func (DeploymentSpecSpecificationLoggingPoliciesAccessLogCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationLoggingPoliciesAccessLog)(ptr)
	var objs []DeploymentSpecSpecificationLoggingPoliciesAccessLog
	if obj != nil {
		objs = []DeploymentSpecSpecificationLoggingPoliciesAccessLog{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationLoggingPoliciesAccessLog{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationLoggingPoliciesAccessLogCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationLoggingPoliciesAccessLog)(ptr) = DeploymentSpecSpecificationLoggingPoliciesAccessLog{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationLoggingPoliciesAccessLog

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationLoggingPoliciesAccessLog{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationLoggingPoliciesAccessLog)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationLoggingPoliciesAccessLog)(ptr) = DeploymentSpecSpecificationLoggingPoliciesAccessLog{}
			}
		} else {
			*(*DeploymentSpecSpecificationLoggingPoliciesAccessLog)(ptr) = DeploymentSpecSpecificationLoggingPoliciesAccessLog{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationLoggingPoliciesAccessLog

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationLoggingPoliciesAccessLog{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationLoggingPoliciesAccessLog)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationLoggingPoliciesAccessLog)(ptr) = DeploymentSpecSpecificationLoggingPoliciesAccessLog{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationLoggingPoliciesAccessLog", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationLoggingPoliciesExecutionLogCodec struct {
}

func (DeploymentSpecSpecificationLoggingPoliciesExecutionLogCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationLoggingPoliciesExecutionLog)(ptr) == nil
}

func (DeploymentSpecSpecificationLoggingPoliciesExecutionLogCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationLoggingPoliciesExecutionLog)(ptr)
	var objs []DeploymentSpecSpecificationLoggingPoliciesExecutionLog
	if obj != nil {
		objs = []DeploymentSpecSpecificationLoggingPoliciesExecutionLog{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationLoggingPoliciesExecutionLog{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationLoggingPoliciesExecutionLogCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationLoggingPoliciesExecutionLog)(ptr) = DeploymentSpecSpecificationLoggingPoliciesExecutionLog{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationLoggingPoliciesExecutionLog

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationLoggingPoliciesExecutionLog{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationLoggingPoliciesExecutionLog)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationLoggingPoliciesExecutionLog)(ptr) = DeploymentSpecSpecificationLoggingPoliciesExecutionLog{}
			}
		} else {
			*(*DeploymentSpecSpecificationLoggingPoliciesExecutionLog)(ptr) = DeploymentSpecSpecificationLoggingPoliciesExecutionLog{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationLoggingPoliciesExecutionLog

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationLoggingPoliciesExecutionLog{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationLoggingPoliciesExecutionLog)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationLoggingPoliciesExecutionLog)(ptr) = DeploymentSpecSpecificationLoggingPoliciesExecutionLog{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationLoggingPoliciesExecutionLog", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRequestPoliciesCodec struct {
}

func (DeploymentSpecSpecificationRequestPoliciesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRequestPolicies)(ptr) == nil
}

func (DeploymentSpecSpecificationRequestPoliciesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRequestPolicies)(ptr)
	var objs []DeploymentSpecSpecificationRequestPolicies
	if obj != nil {
		objs = []DeploymentSpecSpecificationRequestPolicies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPolicies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRequestPoliciesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRequestPolicies)(ptr) = DeploymentSpecSpecificationRequestPolicies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRequestPolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRequestPolicies)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRequestPolicies)(ptr) = DeploymentSpecSpecificationRequestPolicies{}
			}
		} else {
			*(*DeploymentSpecSpecificationRequestPolicies)(ptr) = DeploymentSpecSpecificationRequestPolicies{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRequestPolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRequestPolicies)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRequestPolicies)(ptr) = DeploymentSpecSpecificationRequestPolicies{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRequestPolicies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRequestPoliciesAuthenticationCodec struct {
}

func (DeploymentSpecSpecificationRequestPoliciesAuthenticationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRequestPoliciesAuthentication)(ptr) == nil
}

func (DeploymentSpecSpecificationRequestPoliciesAuthenticationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRequestPoliciesAuthentication)(ptr)
	var objs []DeploymentSpecSpecificationRequestPoliciesAuthentication
	if obj != nil {
		objs = []DeploymentSpecSpecificationRequestPoliciesAuthentication{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesAuthentication{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRequestPoliciesAuthenticationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRequestPoliciesAuthentication)(ptr) = DeploymentSpecSpecificationRequestPoliciesAuthentication{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRequestPoliciesAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRequestPoliciesAuthentication)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRequestPoliciesAuthentication)(ptr) = DeploymentSpecSpecificationRequestPoliciesAuthentication{}
			}
		} else {
			*(*DeploymentSpecSpecificationRequestPoliciesAuthentication)(ptr) = DeploymentSpecSpecificationRequestPoliciesAuthentication{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRequestPoliciesAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRequestPoliciesAuthentication)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRequestPoliciesAuthentication)(ptr) = DeploymentSpecSpecificationRequestPoliciesAuthentication{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRequestPoliciesAuthentication", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeysCodec struct {
}

func (DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeysCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys)(ptr) == nil
}

func (DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeysCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys)(ptr)
	var objs []DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys
	if obj != nil {
		objs = []DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeysCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys)(ptr) = DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys)(ptr) = DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys{}
			}
		} else {
			*(*DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys)(ptr) = DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys)(ptr) = DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRequestPoliciesAuthenticationPublicKeys", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRequestPoliciesCorsCodec struct {
}

func (DeploymentSpecSpecificationRequestPoliciesCorsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRequestPoliciesCors)(ptr) == nil
}

func (DeploymentSpecSpecificationRequestPoliciesCorsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRequestPoliciesCors)(ptr)
	var objs []DeploymentSpecSpecificationRequestPoliciesCors
	if obj != nil {
		objs = []DeploymentSpecSpecificationRequestPoliciesCors{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesCors{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRequestPoliciesCorsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRequestPoliciesCors)(ptr) = DeploymentSpecSpecificationRequestPoliciesCors{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRequestPoliciesCors

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesCors{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRequestPoliciesCors)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRequestPoliciesCors)(ptr) = DeploymentSpecSpecificationRequestPoliciesCors{}
			}
		} else {
			*(*DeploymentSpecSpecificationRequestPoliciesCors)(ptr) = DeploymentSpecSpecificationRequestPoliciesCors{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRequestPoliciesCors

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesCors{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRequestPoliciesCors)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRequestPoliciesCors)(ptr) = DeploymentSpecSpecificationRequestPoliciesCors{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRequestPoliciesCors", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRequestPoliciesMutualTlsCodec struct {
}

func (DeploymentSpecSpecificationRequestPoliciesMutualTlsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRequestPoliciesMutualTls)(ptr) == nil
}

func (DeploymentSpecSpecificationRequestPoliciesMutualTlsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRequestPoliciesMutualTls)(ptr)
	var objs []DeploymentSpecSpecificationRequestPoliciesMutualTls
	if obj != nil {
		objs = []DeploymentSpecSpecificationRequestPoliciesMutualTls{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesMutualTls{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRequestPoliciesMutualTlsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRequestPoliciesMutualTls)(ptr) = DeploymentSpecSpecificationRequestPoliciesMutualTls{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRequestPoliciesMutualTls

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesMutualTls{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRequestPoliciesMutualTls)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRequestPoliciesMutualTls)(ptr) = DeploymentSpecSpecificationRequestPoliciesMutualTls{}
			}
		} else {
			*(*DeploymentSpecSpecificationRequestPoliciesMutualTls)(ptr) = DeploymentSpecSpecificationRequestPoliciesMutualTls{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRequestPoliciesMutualTls

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesMutualTls{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRequestPoliciesMutualTls)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRequestPoliciesMutualTls)(ptr) = DeploymentSpecSpecificationRequestPoliciesMutualTls{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRequestPoliciesMutualTls", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRequestPoliciesRateLimitingCodec struct {
}

func (DeploymentSpecSpecificationRequestPoliciesRateLimitingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRequestPoliciesRateLimiting)(ptr) == nil
}

func (DeploymentSpecSpecificationRequestPoliciesRateLimitingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRequestPoliciesRateLimiting)(ptr)
	var objs []DeploymentSpecSpecificationRequestPoliciesRateLimiting
	if obj != nil {
		objs = []DeploymentSpecSpecificationRequestPoliciesRateLimiting{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesRateLimiting{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRequestPoliciesRateLimitingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRequestPoliciesRateLimiting)(ptr) = DeploymentSpecSpecificationRequestPoliciesRateLimiting{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRequestPoliciesRateLimiting

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesRateLimiting{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRequestPoliciesRateLimiting)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRequestPoliciesRateLimiting)(ptr) = DeploymentSpecSpecificationRequestPoliciesRateLimiting{}
			}
		} else {
			*(*DeploymentSpecSpecificationRequestPoliciesRateLimiting)(ptr) = DeploymentSpecSpecificationRequestPoliciesRateLimiting{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRequestPoliciesRateLimiting

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRequestPoliciesRateLimiting{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRequestPoliciesRateLimiting)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRequestPoliciesRateLimiting)(ptr) = DeploymentSpecSpecificationRequestPoliciesRateLimiting{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRequestPoliciesRateLimiting", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesBackendCodec struct {
}

func (DeploymentSpecSpecificationRoutesBackendCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesBackend)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesBackendCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesBackend)(ptr)
	var objs []DeploymentSpecSpecificationRoutesBackend
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesBackend{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesBackend{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesBackendCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesBackend)(ptr) = DeploymentSpecSpecificationRoutesBackend{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesBackend

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesBackend{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesBackend)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesBackend)(ptr) = DeploymentSpecSpecificationRoutesBackend{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesBackend)(ptr) = DeploymentSpecSpecificationRoutesBackend{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesBackend

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesBackend{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesBackend)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesBackend)(ptr) = DeploymentSpecSpecificationRoutesBackend{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesBackend", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesLoggingPoliciesCodec struct {
}

func (DeploymentSpecSpecificationRoutesLoggingPoliciesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesLoggingPolicies)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesLoggingPoliciesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesLoggingPolicies)(ptr)
	var objs []DeploymentSpecSpecificationRoutesLoggingPolicies
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesLoggingPolicies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesLoggingPolicies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesLoggingPoliciesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesLoggingPolicies)(ptr) = DeploymentSpecSpecificationRoutesLoggingPolicies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesLoggingPolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesLoggingPolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesLoggingPolicies)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesLoggingPolicies)(ptr) = DeploymentSpecSpecificationRoutesLoggingPolicies{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesLoggingPolicies)(ptr) = DeploymentSpecSpecificationRoutesLoggingPolicies{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesLoggingPolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesLoggingPolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesLoggingPolicies)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesLoggingPolicies)(ptr) = DeploymentSpecSpecificationRoutesLoggingPolicies{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesLoggingPolicies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLogCodec struct {
}

func (DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLogCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLogCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog)(ptr)
	var objs []DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLogCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog)(ptr) = DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog)(ptr) = DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog)(ptr) = DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog)(ptr) = DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesLoggingPoliciesAccessLog", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLogCodec struct {
}

func (DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLogCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLogCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog)(ptr)
	var objs []DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLogCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog)(ptr) = DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog)(ptr) = DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog)(ptr) = DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog)(ptr) = DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesLoggingPoliciesExecutionLog", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesRequestPoliciesCodec struct {
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesRequestPolicies)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesRequestPolicies)(ptr)
	var objs []DeploymentSpecSpecificationRoutesRequestPolicies
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesRequestPolicies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPolicies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesRequestPolicies)(ptr) = DeploymentSpecSpecificationRoutesRequestPolicies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesRequestPolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesRequestPolicies)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesRequestPolicies)(ptr) = DeploymentSpecSpecificationRoutesRequestPolicies{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPolicies)(ptr) = DeploymentSpecSpecificationRoutesRequestPolicies{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesRequestPolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesRequestPolicies)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPolicies)(ptr) = DeploymentSpecSpecificationRoutesRequestPolicies{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesRequestPolicies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesRequestPoliciesAuthorizationCodec struct {
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesAuthorizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesAuthorizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization)(ptr)
	var objs []DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesAuthorizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesRequestPoliciesAuthorization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidationCodec struct {
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation)(ptr)
	var objs []DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesRequestPoliciesBodyValidation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesRequestPoliciesCorsCodec struct {
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesCorsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesRequestPoliciesCors)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesCorsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesRequestPoliciesCors)(ptr)
	var objs []DeploymentSpecSpecificationRoutesRequestPoliciesCors
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesRequestPoliciesCors{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesCors{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesCorsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesRequestPoliciesCors)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesCors{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesRequestPoliciesCors

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesCors{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesCors)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesCors)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesCors{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesCors)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesCors{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesRequestPoliciesCors

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesCors{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesRequestPoliciesCors)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesCors)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesCors{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesRequestPoliciesCors", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsCodec struct {
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations)(ptr)
	var objs []DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformations", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeadersCodec struct {
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders)(ptr)
	var objs []DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsFilterHeaders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeadersCodec struct {
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders)(ptr)
	var objs []DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsRenameHeaders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeadersCodec struct {
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders)(ptr)
	var objs []DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesRequestPoliciesHeaderTransformationsSetHeaders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidationsCodec struct {
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidationsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidationsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations)(ptr)
	var objs []DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidationsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesRequestPoliciesHeaderValidations", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsCodec struct {
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations)(ptr)
	var objs []DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformations", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParametersCodec struct {
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters)(ptr)
	var objs []DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsFilterQueryParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParametersCodec struct {
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters)(ptr)
	var objs []DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsRenameQueryParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParametersCodec struct {
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters)(ptr)
	var objs []DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterTransformationsSetQueryParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidationsCodec struct {
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidationsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidationsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations)(ptr)
	var objs []DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidationsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesRequestPoliciesQueryParameterValidations", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookupCodec struct {
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookupCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookupCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup)(ptr)
	var objs []DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookupCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup)(ptr) = DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesRequestPoliciesResponseCacheLookup", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesResponsePoliciesCodec struct {
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesResponsePolicies)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesResponsePolicies)(ptr)
	var objs []DeploymentSpecSpecificationRoutesResponsePolicies
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesResponsePolicies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePolicies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesResponsePolicies)(ptr) = DeploymentSpecSpecificationRoutesResponsePolicies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesResponsePolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesResponsePolicies)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesResponsePolicies)(ptr) = DeploymentSpecSpecificationRoutesResponsePolicies{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesResponsePolicies)(ptr) = DeploymentSpecSpecificationRoutesResponsePolicies{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesResponsePolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesResponsePolicies)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesResponsePolicies)(ptr) = DeploymentSpecSpecificationRoutesResponsePolicies{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesResponsePolicies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsCodec struct {
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations)(ptr)
	var objs []DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformations", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeadersCodec struct {
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders)(ptr)
	var objs []DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsFilterHeaders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeadersCodec struct {
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders)(ptr)
	var objs []DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsRenameHeaders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeadersCodec struct {
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders)(ptr)
	var objs []DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesResponsePoliciesHeaderTransformationsSetHeaders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStoreCodec struct {
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStoreCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore)(ptr) == nil
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStoreCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore)(ptr)
	var objs []DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore
	if obj != nil {
		objs = []DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStoreCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore{}
			}
		} else {
			*(*DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore)(ptr) = obj
		} else {
			*(*DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore)(ptr) = DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore{}
		}
	default:
		iter.ReportError("decode DeploymentSpecSpecificationRoutesResponsePoliciesResponseCacheStore", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewaySpecResponseCacheDetailsCodec struct {
}

func (GatewaySpecResponseCacheDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewaySpecResponseCacheDetails)(ptr) == nil
}

func (GatewaySpecResponseCacheDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewaySpecResponseCacheDetails)(ptr)
	var objs []GatewaySpecResponseCacheDetails
	if obj != nil {
		objs = []GatewaySpecResponseCacheDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewaySpecResponseCacheDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewaySpecResponseCacheDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewaySpecResponseCacheDetails)(ptr) = GatewaySpecResponseCacheDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewaySpecResponseCacheDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewaySpecResponseCacheDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewaySpecResponseCacheDetails)(ptr) = objs[0]
			} else {
				*(*GatewaySpecResponseCacheDetails)(ptr) = GatewaySpecResponseCacheDetails{}
			}
		} else {
			*(*GatewaySpecResponseCacheDetails)(ptr) = GatewaySpecResponseCacheDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GatewaySpecResponseCacheDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewaySpecResponseCacheDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GatewaySpecResponseCacheDetails)(ptr) = obj
		} else {
			*(*GatewaySpecResponseCacheDetails)(ptr) = GatewaySpecResponseCacheDetails{}
		}
	default:
		iter.ReportError("decode GatewaySpecResponseCacheDetails", "unexpected JSON type")
	}
}
