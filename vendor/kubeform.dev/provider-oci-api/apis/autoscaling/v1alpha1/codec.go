/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecAutoScalingResources{}).Type1()):         AutoScalingConfigurationSpecAutoScalingResourcesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesCapacity{}).Type1()):             AutoScalingConfigurationSpecPoliciesCapacityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesExecutionSchedule{}).Type1()):    AutoScalingConfigurationSpecPoliciesExecutionScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesResourceAction{}).Type1()):       AutoScalingConfigurationSpecPoliciesResourceActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesRulesAction{}).Type1()):          AutoScalingConfigurationSpecPoliciesRulesActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesRulesMetric{}).Type1()):          AutoScalingConfigurationSpecPoliciesRulesMetricCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesRulesMetricThreshold{}).Type1()): AutoScalingConfigurationSpecPoliciesRulesMetricThresholdCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecAutoScalingResources{}).Type1()):         AutoScalingConfigurationSpecAutoScalingResourcesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesCapacity{}).Type1()):             AutoScalingConfigurationSpecPoliciesCapacityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesExecutionSchedule{}).Type1()):    AutoScalingConfigurationSpecPoliciesExecutionScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesResourceAction{}).Type1()):       AutoScalingConfigurationSpecPoliciesResourceActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesRulesAction{}).Type1()):          AutoScalingConfigurationSpecPoliciesRulesActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesRulesMetric{}).Type1()):          AutoScalingConfigurationSpecPoliciesRulesMetricCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesRulesMetricThreshold{}).Type1()): AutoScalingConfigurationSpecPoliciesRulesMetricThresholdCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AutoScalingConfigurationSpecAutoScalingResourcesCodec struct {
}

func (AutoScalingConfigurationSpecAutoScalingResourcesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoScalingConfigurationSpecAutoScalingResources)(ptr) == nil
}

func (AutoScalingConfigurationSpecAutoScalingResourcesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoScalingConfigurationSpecAutoScalingResources)(ptr)
	var objs []AutoScalingConfigurationSpecAutoScalingResources
	if obj != nil {
		objs = []AutoScalingConfigurationSpecAutoScalingResources{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecAutoScalingResources{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoScalingConfigurationSpecAutoScalingResourcesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoScalingConfigurationSpecAutoScalingResources)(ptr) = AutoScalingConfigurationSpecAutoScalingResources{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoScalingConfigurationSpecAutoScalingResources

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecAutoScalingResources{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoScalingConfigurationSpecAutoScalingResources)(ptr) = objs[0]
			} else {
				*(*AutoScalingConfigurationSpecAutoScalingResources)(ptr) = AutoScalingConfigurationSpecAutoScalingResources{}
			}
		} else {
			*(*AutoScalingConfigurationSpecAutoScalingResources)(ptr) = AutoScalingConfigurationSpecAutoScalingResources{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutoScalingConfigurationSpecAutoScalingResources

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecAutoScalingResources{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutoScalingConfigurationSpecAutoScalingResources)(ptr) = obj
		} else {
			*(*AutoScalingConfigurationSpecAutoScalingResources)(ptr) = AutoScalingConfigurationSpecAutoScalingResources{}
		}
	default:
		iter.ReportError("decode AutoScalingConfigurationSpecAutoScalingResources", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoScalingConfigurationSpecPoliciesCapacityCodec struct {
}

func (AutoScalingConfigurationSpecPoliciesCapacityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoScalingConfigurationSpecPoliciesCapacity)(ptr) == nil
}

func (AutoScalingConfigurationSpecPoliciesCapacityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoScalingConfigurationSpecPoliciesCapacity)(ptr)
	var objs []AutoScalingConfigurationSpecPoliciesCapacity
	if obj != nil {
		objs = []AutoScalingConfigurationSpecPoliciesCapacity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesCapacity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoScalingConfigurationSpecPoliciesCapacityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoScalingConfigurationSpecPoliciesCapacity)(ptr) = AutoScalingConfigurationSpecPoliciesCapacity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoScalingConfigurationSpecPoliciesCapacity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesCapacity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoScalingConfigurationSpecPoliciesCapacity)(ptr) = objs[0]
			} else {
				*(*AutoScalingConfigurationSpecPoliciesCapacity)(ptr) = AutoScalingConfigurationSpecPoliciesCapacity{}
			}
		} else {
			*(*AutoScalingConfigurationSpecPoliciesCapacity)(ptr) = AutoScalingConfigurationSpecPoliciesCapacity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutoScalingConfigurationSpecPoliciesCapacity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesCapacity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutoScalingConfigurationSpecPoliciesCapacity)(ptr) = obj
		} else {
			*(*AutoScalingConfigurationSpecPoliciesCapacity)(ptr) = AutoScalingConfigurationSpecPoliciesCapacity{}
		}
	default:
		iter.ReportError("decode AutoScalingConfigurationSpecPoliciesCapacity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoScalingConfigurationSpecPoliciesExecutionScheduleCodec struct {
}

func (AutoScalingConfigurationSpecPoliciesExecutionScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoScalingConfigurationSpecPoliciesExecutionSchedule)(ptr) == nil
}

func (AutoScalingConfigurationSpecPoliciesExecutionScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoScalingConfigurationSpecPoliciesExecutionSchedule)(ptr)
	var objs []AutoScalingConfigurationSpecPoliciesExecutionSchedule
	if obj != nil {
		objs = []AutoScalingConfigurationSpecPoliciesExecutionSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesExecutionSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoScalingConfigurationSpecPoliciesExecutionScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoScalingConfigurationSpecPoliciesExecutionSchedule)(ptr) = AutoScalingConfigurationSpecPoliciesExecutionSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoScalingConfigurationSpecPoliciesExecutionSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesExecutionSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoScalingConfigurationSpecPoliciesExecutionSchedule)(ptr) = objs[0]
			} else {
				*(*AutoScalingConfigurationSpecPoliciesExecutionSchedule)(ptr) = AutoScalingConfigurationSpecPoliciesExecutionSchedule{}
			}
		} else {
			*(*AutoScalingConfigurationSpecPoliciesExecutionSchedule)(ptr) = AutoScalingConfigurationSpecPoliciesExecutionSchedule{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutoScalingConfigurationSpecPoliciesExecutionSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesExecutionSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutoScalingConfigurationSpecPoliciesExecutionSchedule)(ptr) = obj
		} else {
			*(*AutoScalingConfigurationSpecPoliciesExecutionSchedule)(ptr) = AutoScalingConfigurationSpecPoliciesExecutionSchedule{}
		}
	default:
		iter.ReportError("decode AutoScalingConfigurationSpecPoliciesExecutionSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoScalingConfigurationSpecPoliciesResourceActionCodec struct {
}

func (AutoScalingConfigurationSpecPoliciesResourceActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoScalingConfigurationSpecPoliciesResourceAction)(ptr) == nil
}

func (AutoScalingConfigurationSpecPoliciesResourceActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoScalingConfigurationSpecPoliciesResourceAction)(ptr)
	var objs []AutoScalingConfigurationSpecPoliciesResourceAction
	if obj != nil {
		objs = []AutoScalingConfigurationSpecPoliciesResourceAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesResourceAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoScalingConfigurationSpecPoliciesResourceActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoScalingConfigurationSpecPoliciesResourceAction)(ptr) = AutoScalingConfigurationSpecPoliciesResourceAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoScalingConfigurationSpecPoliciesResourceAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesResourceAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoScalingConfigurationSpecPoliciesResourceAction)(ptr) = objs[0]
			} else {
				*(*AutoScalingConfigurationSpecPoliciesResourceAction)(ptr) = AutoScalingConfigurationSpecPoliciesResourceAction{}
			}
		} else {
			*(*AutoScalingConfigurationSpecPoliciesResourceAction)(ptr) = AutoScalingConfigurationSpecPoliciesResourceAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutoScalingConfigurationSpecPoliciesResourceAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesResourceAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutoScalingConfigurationSpecPoliciesResourceAction)(ptr) = obj
		} else {
			*(*AutoScalingConfigurationSpecPoliciesResourceAction)(ptr) = AutoScalingConfigurationSpecPoliciesResourceAction{}
		}
	default:
		iter.ReportError("decode AutoScalingConfigurationSpecPoliciesResourceAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoScalingConfigurationSpecPoliciesRulesActionCodec struct {
}

func (AutoScalingConfigurationSpecPoliciesRulesActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoScalingConfigurationSpecPoliciesRulesAction)(ptr) == nil
}

func (AutoScalingConfigurationSpecPoliciesRulesActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoScalingConfigurationSpecPoliciesRulesAction)(ptr)
	var objs []AutoScalingConfigurationSpecPoliciesRulesAction
	if obj != nil {
		objs = []AutoScalingConfigurationSpecPoliciesRulesAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesRulesAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoScalingConfigurationSpecPoliciesRulesActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoScalingConfigurationSpecPoliciesRulesAction)(ptr) = AutoScalingConfigurationSpecPoliciesRulesAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoScalingConfigurationSpecPoliciesRulesAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesRulesAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoScalingConfigurationSpecPoliciesRulesAction)(ptr) = objs[0]
			} else {
				*(*AutoScalingConfigurationSpecPoliciesRulesAction)(ptr) = AutoScalingConfigurationSpecPoliciesRulesAction{}
			}
		} else {
			*(*AutoScalingConfigurationSpecPoliciesRulesAction)(ptr) = AutoScalingConfigurationSpecPoliciesRulesAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutoScalingConfigurationSpecPoliciesRulesAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesRulesAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutoScalingConfigurationSpecPoliciesRulesAction)(ptr) = obj
		} else {
			*(*AutoScalingConfigurationSpecPoliciesRulesAction)(ptr) = AutoScalingConfigurationSpecPoliciesRulesAction{}
		}
	default:
		iter.ReportError("decode AutoScalingConfigurationSpecPoliciesRulesAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoScalingConfigurationSpecPoliciesRulesMetricCodec struct {
}

func (AutoScalingConfigurationSpecPoliciesRulesMetricCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoScalingConfigurationSpecPoliciesRulesMetric)(ptr) == nil
}

func (AutoScalingConfigurationSpecPoliciesRulesMetricCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoScalingConfigurationSpecPoliciesRulesMetric)(ptr)
	var objs []AutoScalingConfigurationSpecPoliciesRulesMetric
	if obj != nil {
		objs = []AutoScalingConfigurationSpecPoliciesRulesMetric{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesRulesMetric{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoScalingConfigurationSpecPoliciesRulesMetricCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoScalingConfigurationSpecPoliciesRulesMetric)(ptr) = AutoScalingConfigurationSpecPoliciesRulesMetric{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoScalingConfigurationSpecPoliciesRulesMetric

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesRulesMetric{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoScalingConfigurationSpecPoliciesRulesMetric)(ptr) = objs[0]
			} else {
				*(*AutoScalingConfigurationSpecPoliciesRulesMetric)(ptr) = AutoScalingConfigurationSpecPoliciesRulesMetric{}
			}
		} else {
			*(*AutoScalingConfigurationSpecPoliciesRulesMetric)(ptr) = AutoScalingConfigurationSpecPoliciesRulesMetric{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutoScalingConfigurationSpecPoliciesRulesMetric

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesRulesMetric{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutoScalingConfigurationSpecPoliciesRulesMetric)(ptr) = obj
		} else {
			*(*AutoScalingConfigurationSpecPoliciesRulesMetric)(ptr) = AutoScalingConfigurationSpecPoliciesRulesMetric{}
		}
	default:
		iter.ReportError("decode AutoScalingConfigurationSpecPoliciesRulesMetric", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoScalingConfigurationSpecPoliciesRulesMetricThresholdCodec struct {
}

func (AutoScalingConfigurationSpecPoliciesRulesMetricThresholdCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoScalingConfigurationSpecPoliciesRulesMetricThreshold)(ptr) == nil
}

func (AutoScalingConfigurationSpecPoliciesRulesMetricThresholdCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoScalingConfigurationSpecPoliciesRulesMetricThreshold)(ptr)
	var objs []AutoScalingConfigurationSpecPoliciesRulesMetricThreshold
	if obj != nil {
		objs = []AutoScalingConfigurationSpecPoliciesRulesMetricThreshold{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesRulesMetricThreshold{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoScalingConfigurationSpecPoliciesRulesMetricThresholdCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoScalingConfigurationSpecPoliciesRulesMetricThreshold)(ptr) = AutoScalingConfigurationSpecPoliciesRulesMetricThreshold{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoScalingConfigurationSpecPoliciesRulesMetricThreshold

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesRulesMetricThreshold{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoScalingConfigurationSpecPoliciesRulesMetricThreshold)(ptr) = objs[0]
			} else {
				*(*AutoScalingConfigurationSpecPoliciesRulesMetricThreshold)(ptr) = AutoScalingConfigurationSpecPoliciesRulesMetricThreshold{}
			}
		} else {
			*(*AutoScalingConfigurationSpecPoliciesRulesMetricThreshold)(ptr) = AutoScalingConfigurationSpecPoliciesRulesMetricThreshold{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutoScalingConfigurationSpecPoliciesRulesMetricThreshold

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoScalingConfigurationSpecPoliciesRulesMetricThreshold{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutoScalingConfigurationSpecPoliciesRulesMetricThreshold)(ptr) = obj
		} else {
			*(*AutoScalingConfigurationSpecPoliciesRulesMetricThreshold)(ptr) = AutoScalingConfigurationSpecPoliciesRulesMetricThreshold{}
		}
	default:
		iter.ReportError("decode AutoScalingConfigurationSpecPoliciesRulesMetricThreshold", "unexpected JSON type")
	}
}
