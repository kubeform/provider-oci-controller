/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateConfig{}).Type1()):                                            ManagementCertificateSpecCertificateConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateConfigSubject{}).Type1()):                                     ManagementCertificateSpecCertificateConfigSubjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateConfigValidity{}).Type1()):                                    ManagementCertificateSpecCertificateConfigValidityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateRevocationListDetails{}).Type1()):                             ManagementCertificateSpecCertificateRevocationListDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig{}).Type1()):          ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCurrentVersion{}).Type1()):                                               ManagementCertificateSpecCurrentVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCurrentVersionRevocationStatus{}).Type1()):                               ManagementCertificateSpecCurrentVersionRevocationStatusCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCurrentVersionValidity{}).Type1()):                                       ManagementCertificateSpecCurrentVersionValidityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecSubject{}).Type1()):                                                      ManagementCertificateSpecSubjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateAuthorityConfig{}).Type1()):                          ManagementCertificateAuthoritySpecCertificateAuthorityConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject{}).Type1()):                   ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity{}).Type1()):                  ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateRevocationListDetails{}).Type1()):                    ManagementCertificateAuthoritySpecCertificateRevocationListDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig{}).Type1()): ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCurrentVersion{}).Type1()):                                      ManagementCertificateAuthoritySpecCurrentVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus{}).Type1()):                      ManagementCertificateAuthoritySpecCurrentVersionRevocationStatusCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCurrentVersionValidity{}).Type1()):                              ManagementCertificateAuthoritySpecCurrentVersionValidityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecSubject{}).Type1()):                                             ManagementCertificateAuthoritySpecSubjectCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateConfig{}).Type1()):                                            ManagementCertificateSpecCertificateConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateConfigSubject{}).Type1()):                                     ManagementCertificateSpecCertificateConfigSubjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateConfigValidity{}).Type1()):                                    ManagementCertificateSpecCertificateConfigValidityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateRevocationListDetails{}).Type1()):                             ManagementCertificateSpecCertificateRevocationListDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig{}).Type1()):          ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCurrentVersion{}).Type1()):                                               ManagementCertificateSpecCurrentVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCurrentVersionRevocationStatus{}).Type1()):                               ManagementCertificateSpecCurrentVersionRevocationStatusCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCurrentVersionValidity{}).Type1()):                                       ManagementCertificateSpecCurrentVersionValidityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecSubject{}).Type1()):                                                      ManagementCertificateSpecSubjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateAuthorityConfig{}).Type1()):                          ManagementCertificateAuthoritySpecCertificateAuthorityConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject{}).Type1()):                   ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity{}).Type1()):                  ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateRevocationListDetails{}).Type1()):                    ManagementCertificateAuthoritySpecCertificateRevocationListDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig{}).Type1()): ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCurrentVersion{}).Type1()):                                      ManagementCertificateAuthoritySpecCurrentVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus{}).Type1()):                      ManagementCertificateAuthoritySpecCurrentVersionRevocationStatusCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCurrentVersionValidity{}).Type1()):                              ManagementCertificateAuthoritySpecCurrentVersionValidityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecSubject{}).Type1()):                                             ManagementCertificateAuthoritySpecSubjectCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ManagementCertificateSpecCertificateConfigCodec struct {
}

func (ManagementCertificateSpecCertificateConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateSpecCertificateConfig)(ptr) == nil
}

func (ManagementCertificateSpecCertificateConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateSpecCertificateConfig)(ptr)
	var objs []ManagementCertificateSpecCertificateConfig
	if obj != nil {
		objs = []ManagementCertificateSpecCertificateConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateSpecCertificateConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateSpecCertificateConfig)(ptr) = ManagementCertificateSpecCertificateConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateSpecCertificateConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateSpecCertificateConfig)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateSpecCertificateConfig)(ptr) = ManagementCertificateSpecCertificateConfig{}
			}
		} else {
			*(*ManagementCertificateSpecCertificateConfig)(ptr) = ManagementCertificateSpecCertificateConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateSpecCertificateConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateSpecCertificateConfig)(ptr) = obj
		} else {
			*(*ManagementCertificateSpecCertificateConfig)(ptr) = ManagementCertificateSpecCertificateConfig{}
		}
	default:
		iter.ReportError("decode ManagementCertificateSpecCertificateConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateSpecCertificateConfigSubjectCodec struct {
}

func (ManagementCertificateSpecCertificateConfigSubjectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateSpecCertificateConfigSubject)(ptr) == nil
}

func (ManagementCertificateSpecCertificateConfigSubjectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateSpecCertificateConfigSubject)(ptr)
	var objs []ManagementCertificateSpecCertificateConfigSubject
	if obj != nil {
		objs = []ManagementCertificateSpecCertificateConfigSubject{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateConfigSubject{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateSpecCertificateConfigSubjectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateSpecCertificateConfigSubject)(ptr) = ManagementCertificateSpecCertificateConfigSubject{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateSpecCertificateConfigSubject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateConfigSubject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateSpecCertificateConfigSubject)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateSpecCertificateConfigSubject)(ptr) = ManagementCertificateSpecCertificateConfigSubject{}
			}
		} else {
			*(*ManagementCertificateSpecCertificateConfigSubject)(ptr) = ManagementCertificateSpecCertificateConfigSubject{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateSpecCertificateConfigSubject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateConfigSubject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateSpecCertificateConfigSubject)(ptr) = obj
		} else {
			*(*ManagementCertificateSpecCertificateConfigSubject)(ptr) = ManagementCertificateSpecCertificateConfigSubject{}
		}
	default:
		iter.ReportError("decode ManagementCertificateSpecCertificateConfigSubject", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateSpecCertificateConfigValidityCodec struct {
}

func (ManagementCertificateSpecCertificateConfigValidityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateSpecCertificateConfigValidity)(ptr) == nil
}

func (ManagementCertificateSpecCertificateConfigValidityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateSpecCertificateConfigValidity)(ptr)
	var objs []ManagementCertificateSpecCertificateConfigValidity
	if obj != nil {
		objs = []ManagementCertificateSpecCertificateConfigValidity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateConfigValidity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateSpecCertificateConfigValidityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateSpecCertificateConfigValidity)(ptr) = ManagementCertificateSpecCertificateConfigValidity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateSpecCertificateConfigValidity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateConfigValidity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateSpecCertificateConfigValidity)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateSpecCertificateConfigValidity)(ptr) = ManagementCertificateSpecCertificateConfigValidity{}
			}
		} else {
			*(*ManagementCertificateSpecCertificateConfigValidity)(ptr) = ManagementCertificateSpecCertificateConfigValidity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateSpecCertificateConfigValidity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateConfigValidity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateSpecCertificateConfigValidity)(ptr) = obj
		} else {
			*(*ManagementCertificateSpecCertificateConfigValidity)(ptr) = ManagementCertificateSpecCertificateConfigValidity{}
		}
	default:
		iter.ReportError("decode ManagementCertificateSpecCertificateConfigValidity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateSpecCertificateRevocationListDetailsCodec struct {
}

func (ManagementCertificateSpecCertificateRevocationListDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateSpecCertificateRevocationListDetails)(ptr) == nil
}

func (ManagementCertificateSpecCertificateRevocationListDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateSpecCertificateRevocationListDetails)(ptr)
	var objs []ManagementCertificateSpecCertificateRevocationListDetails
	if obj != nil {
		objs = []ManagementCertificateSpecCertificateRevocationListDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateRevocationListDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateSpecCertificateRevocationListDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateSpecCertificateRevocationListDetails)(ptr) = ManagementCertificateSpecCertificateRevocationListDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateSpecCertificateRevocationListDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateRevocationListDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateSpecCertificateRevocationListDetails)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateSpecCertificateRevocationListDetails)(ptr) = ManagementCertificateSpecCertificateRevocationListDetails{}
			}
		} else {
			*(*ManagementCertificateSpecCertificateRevocationListDetails)(ptr) = ManagementCertificateSpecCertificateRevocationListDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateSpecCertificateRevocationListDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateRevocationListDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateSpecCertificateRevocationListDetails)(ptr) = obj
		} else {
			*(*ManagementCertificateSpecCertificateRevocationListDetails)(ptr) = ManagementCertificateSpecCertificateRevocationListDetails{}
		}
	default:
		iter.ReportError("decode ManagementCertificateSpecCertificateRevocationListDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfigCodec struct {
}

func (ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig)(ptr) == nil
}

func (ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig)(ptr)
	var objs []ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig
	if obj != nil {
		objs = []ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig)(ptr) = ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig)(ptr) = ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig{}
			}
		} else {
			*(*ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig)(ptr) = ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig)(ptr) = obj
		} else {
			*(*ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig)(ptr) = ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig{}
		}
	default:
		iter.ReportError("decode ManagementCertificateSpecCertificateRevocationListDetailsObjectStorageConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateSpecCurrentVersionCodec struct {
}

func (ManagementCertificateSpecCurrentVersionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateSpecCurrentVersion)(ptr) == nil
}

func (ManagementCertificateSpecCurrentVersionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateSpecCurrentVersion)(ptr)
	var objs []ManagementCertificateSpecCurrentVersion
	if obj != nil {
		objs = []ManagementCertificateSpecCurrentVersion{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCurrentVersion{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateSpecCurrentVersionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateSpecCurrentVersion)(ptr) = ManagementCertificateSpecCurrentVersion{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateSpecCurrentVersion

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCurrentVersion{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateSpecCurrentVersion)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateSpecCurrentVersion)(ptr) = ManagementCertificateSpecCurrentVersion{}
			}
		} else {
			*(*ManagementCertificateSpecCurrentVersion)(ptr) = ManagementCertificateSpecCurrentVersion{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateSpecCurrentVersion

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCurrentVersion{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateSpecCurrentVersion)(ptr) = obj
		} else {
			*(*ManagementCertificateSpecCurrentVersion)(ptr) = ManagementCertificateSpecCurrentVersion{}
		}
	default:
		iter.ReportError("decode ManagementCertificateSpecCurrentVersion", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateSpecCurrentVersionRevocationStatusCodec struct {
}

func (ManagementCertificateSpecCurrentVersionRevocationStatusCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateSpecCurrentVersionRevocationStatus)(ptr) == nil
}

func (ManagementCertificateSpecCurrentVersionRevocationStatusCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateSpecCurrentVersionRevocationStatus)(ptr)
	var objs []ManagementCertificateSpecCurrentVersionRevocationStatus
	if obj != nil {
		objs = []ManagementCertificateSpecCurrentVersionRevocationStatus{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCurrentVersionRevocationStatus{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateSpecCurrentVersionRevocationStatusCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateSpecCurrentVersionRevocationStatus)(ptr) = ManagementCertificateSpecCurrentVersionRevocationStatus{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateSpecCurrentVersionRevocationStatus

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCurrentVersionRevocationStatus{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateSpecCurrentVersionRevocationStatus)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateSpecCurrentVersionRevocationStatus)(ptr) = ManagementCertificateSpecCurrentVersionRevocationStatus{}
			}
		} else {
			*(*ManagementCertificateSpecCurrentVersionRevocationStatus)(ptr) = ManagementCertificateSpecCurrentVersionRevocationStatus{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateSpecCurrentVersionRevocationStatus

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCurrentVersionRevocationStatus{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateSpecCurrentVersionRevocationStatus)(ptr) = obj
		} else {
			*(*ManagementCertificateSpecCurrentVersionRevocationStatus)(ptr) = ManagementCertificateSpecCurrentVersionRevocationStatus{}
		}
	default:
		iter.ReportError("decode ManagementCertificateSpecCurrentVersionRevocationStatus", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateSpecCurrentVersionValidityCodec struct {
}

func (ManagementCertificateSpecCurrentVersionValidityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateSpecCurrentVersionValidity)(ptr) == nil
}

func (ManagementCertificateSpecCurrentVersionValidityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateSpecCurrentVersionValidity)(ptr)
	var objs []ManagementCertificateSpecCurrentVersionValidity
	if obj != nil {
		objs = []ManagementCertificateSpecCurrentVersionValidity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCurrentVersionValidity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateSpecCurrentVersionValidityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateSpecCurrentVersionValidity)(ptr) = ManagementCertificateSpecCurrentVersionValidity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateSpecCurrentVersionValidity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCurrentVersionValidity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateSpecCurrentVersionValidity)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateSpecCurrentVersionValidity)(ptr) = ManagementCertificateSpecCurrentVersionValidity{}
			}
		} else {
			*(*ManagementCertificateSpecCurrentVersionValidity)(ptr) = ManagementCertificateSpecCurrentVersionValidity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateSpecCurrentVersionValidity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecCurrentVersionValidity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateSpecCurrentVersionValidity)(ptr) = obj
		} else {
			*(*ManagementCertificateSpecCurrentVersionValidity)(ptr) = ManagementCertificateSpecCurrentVersionValidity{}
		}
	default:
		iter.ReportError("decode ManagementCertificateSpecCurrentVersionValidity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateSpecSubjectCodec struct {
}

func (ManagementCertificateSpecSubjectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateSpecSubject)(ptr) == nil
}

func (ManagementCertificateSpecSubjectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateSpecSubject)(ptr)
	var objs []ManagementCertificateSpecSubject
	if obj != nil {
		objs = []ManagementCertificateSpecSubject{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecSubject{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateSpecSubjectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateSpecSubject)(ptr) = ManagementCertificateSpecSubject{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateSpecSubject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecSubject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateSpecSubject)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateSpecSubject)(ptr) = ManagementCertificateSpecSubject{}
			}
		} else {
			*(*ManagementCertificateSpecSubject)(ptr) = ManagementCertificateSpecSubject{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateSpecSubject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateSpecSubject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateSpecSubject)(ptr) = obj
		} else {
			*(*ManagementCertificateSpecSubject)(ptr) = ManagementCertificateSpecSubject{}
		}
	default:
		iter.ReportError("decode ManagementCertificateSpecSubject", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateAuthoritySpecCertificateAuthorityConfigCodec struct {
}

func (ManagementCertificateAuthoritySpecCertificateAuthorityConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateAuthoritySpecCertificateAuthorityConfig)(ptr) == nil
}

func (ManagementCertificateAuthoritySpecCertificateAuthorityConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateAuthoritySpecCertificateAuthorityConfig)(ptr)
	var objs []ManagementCertificateAuthoritySpecCertificateAuthorityConfig
	if obj != nil {
		objs = []ManagementCertificateAuthoritySpecCertificateAuthorityConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateAuthorityConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateAuthoritySpecCertificateAuthorityConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfig)(ptr) = ManagementCertificateAuthoritySpecCertificateAuthorityConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateAuthoritySpecCertificateAuthorityConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateAuthorityConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfig)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfig)(ptr) = ManagementCertificateAuthoritySpecCertificateAuthorityConfig{}
			}
		} else {
			*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfig)(ptr) = ManagementCertificateAuthoritySpecCertificateAuthorityConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateAuthoritySpecCertificateAuthorityConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateAuthorityConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfig)(ptr) = obj
		} else {
			*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfig)(ptr) = ManagementCertificateAuthoritySpecCertificateAuthorityConfig{}
		}
	default:
		iter.ReportError("decode ManagementCertificateAuthoritySpecCertificateAuthorityConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubjectCodec struct {
}

func (ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubjectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject)(ptr) == nil
}

func (ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubjectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject)(ptr)
	var objs []ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject
	if obj != nil {
		objs = []ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubjectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject)(ptr) = ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject)(ptr) = ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject{}
			}
		} else {
			*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject)(ptr) = ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject)(ptr) = obj
		} else {
			*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject)(ptr) = ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject{}
		}
	default:
		iter.ReportError("decode ManagementCertificateAuthoritySpecCertificateAuthorityConfigSubject", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidityCodec struct {
}

func (ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity)(ptr) == nil
}

func (ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity)(ptr)
	var objs []ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity
	if obj != nil {
		objs = []ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity)(ptr) = ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity)(ptr) = ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity{}
			}
		} else {
			*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity)(ptr) = ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity)(ptr) = obj
		} else {
			*(*ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity)(ptr) = ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity{}
		}
	default:
		iter.ReportError("decode ManagementCertificateAuthoritySpecCertificateAuthorityConfigValidity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateAuthoritySpecCertificateRevocationListDetailsCodec struct {
}

func (ManagementCertificateAuthoritySpecCertificateRevocationListDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateAuthoritySpecCertificateRevocationListDetails)(ptr) == nil
}

func (ManagementCertificateAuthoritySpecCertificateRevocationListDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateAuthoritySpecCertificateRevocationListDetails)(ptr)
	var objs []ManagementCertificateAuthoritySpecCertificateRevocationListDetails
	if obj != nil {
		objs = []ManagementCertificateAuthoritySpecCertificateRevocationListDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateRevocationListDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateAuthoritySpecCertificateRevocationListDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateAuthoritySpecCertificateRevocationListDetails)(ptr) = ManagementCertificateAuthoritySpecCertificateRevocationListDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateAuthoritySpecCertificateRevocationListDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateRevocationListDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateAuthoritySpecCertificateRevocationListDetails)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateAuthoritySpecCertificateRevocationListDetails)(ptr) = ManagementCertificateAuthoritySpecCertificateRevocationListDetails{}
			}
		} else {
			*(*ManagementCertificateAuthoritySpecCertificateRevocationListDetails)(ptr) = ManagementCertificateAuthoritySpecCertificateRevocationListDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateAuthoritySpecCertificateRevocationListDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateRevocationListDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateAuthoritySpecCertificateRevocationListDetails)(ptr) = obj
		} else {
			*(*ManagementCertificateAuthoritySpecCertificateRevocationListDetails)(ptr) = ManagementCertificateAuthoritySpecCertificateRevocationListDetails{}
		}
	default:
		iter.ReportError("decode ManagementCertificateAuthoritySpecCertificateRevocationListDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfigCodec struct {
}

func (ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig)(ptr) == nil
}

func (ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig)(ptr)
	var objs []ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig
	if obj != nil {
		objs = []ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig)(ptr) = ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig)(ptr) = ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig{}
			}
		} else {
			*(*ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig)(ptr) = ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig)(ptr) = obj
		} else {
			*(*ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig)(ptr) = ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig{}
		}
	default:
		iter.ReportError("decode ManagementCertificateAuthoritySpecCertificateRevocationListDetailsObjectStorageConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateAuthoritySpecCurrentVersionCodec struct {
}

func (ManagementCertificateAuthoritySpecCurrentVersionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateAuthoritySpecCurrentVersion)(ptr) == nil
}

func (ManagementCertificateAuthoritySpecCurrentVersionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateAuthoritySpecCurrentVersion)(ptr)
	var objs []ManagementCertificateAuthoritySpecCurrentVersion
	if obj != nil {
		objs = []ManagementCertificateAuthoritySpecCurrentVersion{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCurrentVersion{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateAuthoritySpecCurrentVersionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateAuthoritySpecCurrentVersion)(ptr) = ManagementCertificateAuthoritySpecCurrentVersion{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateAuthoritySpecCurrentVersion

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCurrentVersion{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateAuthoritySpecCurrentVersion)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateAuthoritySpecCurrentVersion)(ptr) = ManagementCertificateAuthoritySpecCurrentVersion{}
			}
		} else {
			*(*ManagementCertificateAuthoritySpecCurrentVersion)(ptr) = ManagementCertificateAuthoritySpecCurrentVersion{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateAuthoritySpecCurrentVersion

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCurrentVersion{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateAuthoritySpecCurrentVersion)(ptr) = obj
		} else {
			*(*ManagementCertificateAuthoritySpecCurrentVersion)(ptr) = ManagementCertificateAuthoritySpecCurrentVersion{}
		}
	default:
		iter.ReportError("decode ManagementCertificateAuthoritySpecCurrentVersion", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateAuthoritySpecCurrentVersionRevocationStatusCodec struct {
}

func (ManagementCertificateAuthoritySpecCurrentVersionRevocationStatusCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus)(ptr) == nil
}

func (ManagementCertificateAuthoritySpecCurrentVersionRevocationStatusCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus)(ptr)
	var objs []ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus
	if obj != nil {
		objs = []ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateAuthoritySpecCurrentVersionRevocationStatusCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus)(ptr) = ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus)(ptr) = ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus{}
			}
		} else {
			*(*ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus)(ptr) = ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus)(ptr) = obj
		} else {
			*(*ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus)(ptr) = ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus{}
		}
	default:
		iter.ReportError("decode ManagementCertificateAuthoritySpecCurrentVersionRevocationStatus", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateAuthoritySpecCurrentVersionValidityCodec struct {
}

func (ManagementCertificateAuthoritySpecCurrentVersionValidityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateAuthoritySpecCurrentVersionValidity)(ptr) == nil
}

func (ManagementCertificateAuthoritySpecCurrentVersionValidityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateAuthoritySpecCurrentVersionValidity)(ptr)
	var objs []ManagementCertificateAuthoritySpecCurrentVersionValidity
	if obj != nil {
		objs = []ManagementCertificateAuthoritySpecCurrentVersionValidity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCurrentVersionValidity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateAuthoritySpecCurrentVersionValidityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateAuthoritySpecCurrentVersionValidity)(ptr) = ManagementCertificateAuthoritySpecCurrentVersionValidity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateAuthoritySpecCurrentVersionValidity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCurrentVersionValidity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateAuthoritySpecCurrentVersionValidity)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateAuthoritySpecCurrentVersionValidity)(ptr) = ManagementCertificateAuthoritySpecCurrentVersionValidity{}
			}
		} else {
			*(*ManagementCertificateAuthoritySpecCurrentVersionValidity)(ptr) = ManagementCertificateAuthoritySpecCurrentVersionValidity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateAuthoritySpecCurrentVersionValidity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecCurrentVersionValidity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateAuthoritySpecCurrentVersionValidity)(ptr) = obj
		} else {
			*(*ManagementCertificateAuthoritySpecCurrentVersionValidity)(ptr) = ManagementCertificateAuthoritySpecCurrentVersionValidity{}
		}
	default:
		iter.ReportError("decode ManagementCertificateAuthoritySpecCurrentVersionValidity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementCertificateAuthoritySpecSubjectCodec struct {
}

func (ManagementCertificateAuthoritySpecSubjectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementCertificateAuthoritySpecSubject)(ptr) == nil
}

func (ManagementCertificateAuthoritySpecSubjectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementCertificateAuthoritySpecSubject)(ptr)
	var objs []ManagementCertificateAuthoritySpecSubject
	if obj != nil {
		objs = []ManagementCertificateAuthoritySpecSubject{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecSubject{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementCertificateAuthoritySpecSubjectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementCertificateAuthoritySpecSubject)(ptr) = ManagementCertificateAuthoritySpecSubject{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementCertificateAuthoritySpecSubject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecSubject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementCertificateAuthoritySpecSubject)(ptr) = objs[0]
			} else {
				*(*ManagementCertificateAuthoritySpecSubject)(ptr) = ManagementCertificateAuthoritySpecSubject{}
			}
		} else {
			*(*ManagementCertificateAuthoritySpecSubject)(ptr) = ManagementCertificateAuthoritySpecSubject{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementCertificateAuthoritySpecSubject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementCertificateAuthoritySpecSubject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementCertificateAuthoritySpecSubject)(ptr) = obj
		} else {
			*(*ManagementCertificateAuthoritySpecSubject)(ptr) = ManagementCertificateAuthoritySpecSubject{}
		}
	default:
		iter.ReportError("decode ManagementCertificateAuthoritySpecSubject", "unexpected JSON type")
	}
}
