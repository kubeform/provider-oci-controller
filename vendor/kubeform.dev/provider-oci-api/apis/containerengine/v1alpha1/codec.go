/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEndpointConfig{}).Type1()):                    ClusterSpecEndpointConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEndpoints{}).Type1()):                         ClusterSpecEndpointsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecImagePolicyConfig{}).Type1()):                 ClusterSpecImagePolicyConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMetadata{}).Type1()):                          ClusterSpecMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptions{}).Type1()):                           ClusterSpecOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsAddOns{}).Type1()):                     ClusterSpecOptionsAddOnsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsAdmissionControllerOptions{}).Type1()): ClusterSpecOptionsAdmissionControllerOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsKubernetesNetworkConfig{}).Type1()):    ClusterSpecOptionsKubernetesNetworkConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsPersistentVolumeConfig{}).Type1()):     ClusterSpecOptionsPersistentVolumeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsServiceLbConfig{}).Type1()):            ClusterSpecOptionsServiceLbConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigDetails{}).Type1()):                NodePoolSpecNodeConfigDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeShapeConfig{}).Type1()):                  NodePoolSpecNodeShapeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeSource{}).Type1()):                       NodePoolSpecNodeSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeSourceDetails{}).Type1()):                NodePoolSpecNodeSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodesError{}).Type1()):                       NodePoolSpecNodesErrorCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEndpointConfig{}).Type1()):                    ClusterSpecEndpointConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEndpoints{}).Type1()):                         ClusterSpecEndpointsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecImagePolicyConfig{}).Type1()):                 ClusterSpecImagePolicyConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMetadata{}).Type1()):                          ClusterSpecMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptions{}).Type1()):                           ClusterSpecOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsAddOns{}).Type1()):                     ClusterSpecOptionsAddOnsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsAdmissionControllerOptions{}).Type1()): ClusterSpecOptionsAdmissionControllerOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsKubernetesNetworkConfig{}).Type1()):    ClusterSpecOptionsKubernetesNetworkConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsPersistentVolumeConfig{}).Type1()):     ClusterSpecOptionsPersistentVolumeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsServiceLbConfig{}).Type1()):            ClusterSpecOptionsServiceLbConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigDetails{}).Type1()):                NodePoolSpecNodeConfigDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeShapeConfig{}).Type1()):                  NodePoolSpecNodeShapeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeSource{}).Type1()):                       NodePoolSpecNodeSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeSourceDetails{}).Type1()):                NodePoolSpecNodeSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodesError{}).Type1()):                       NodePoolSpecNodesErrorCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ClusterSpecEndpointConfigCodec struct {
}

func (ClusterSpecEndpointConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecEndpointConfig)(ptr) == nil
}

func (ClusterSpecEndpointConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecEndpointConfig)(ptr)
	var objs []ClusterSpecEndpointConfig
	if obj != nil {
		objs = []ClusterSpecEndpointConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEndpointConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecEndpointConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecEndpointConfig)(ptr) = ClusterSpecEndpointConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecEndpointConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEndpointConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecEndpointConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecEndpointConfig)(ptr) = ClusterSpecEndpointConfig{}
			}
		} else {
			*(*ClusterSpecEndpointConfig)(ptr) = ClusterSpecEndpointConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecEndpointConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEndpointConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecEndpointConfig)(ptr) = obj
		} else {
			*(*ClusterSpecEndpointConfig)(ptr) = ClusterSpecEndpointConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecEndpointConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecEndpointsCodec struct {
}

func (ClusterSpecEndpointsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecEndpoints)(ptr) == nil
}

func (ClusterSpecEndpointsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecEndpoints)(ptr)
	var objs []ClusterSpecEndpoints
	if obj != nil {
		objs = []ClusterSpecEndpoints{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEndpoints{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecEndpointsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecEndpoints)(ptr) = ClusterSpecEndpoints{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecEndpoints

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEndpoints{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecEndpoints)(ptr) = objs[0]
			} else {
				*(*ClusterSpecEndpoints)(ptr) = ClusterSpecEndpoints{}
			}
		} else {
			*(*ClusterSpecEndpoints)(ptr) = ClusterSpecEndpoints{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecEndpoints

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEndpoints{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecEndpoints)(ptr) = obj
		} else {
			*(*ClusterSpecEndpoints)(ptr) = ClusterSpecEndpoints{}
		}
	default:
		iter.ReportError("decode ClusterSpecEndpoints", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecImagePolicyConfigCodec struct {
}

func (ClusterSpecImagePolicyConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecImagePolicyConfig)(ptr) == nil
}

func (ClusterSpecImagePolicyConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecImagePolicyConfig)(ptr)
	var objs []ClusterSpecImagePolicyConfig
	if obj != nil {
		objs = []ClusterSpecImagePolicyConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecImagePolicyConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecImagePolicyConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecImagePolicyConfig)(ptr) = ClusterSpecImagePolicyConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecImagePolicyConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecImagePolicyConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecImagePolicyConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecImagePolicyConfig)(ptr) = ClusterSpecImagePolicyConfig{}
			}
		} else {
			*(*ClusterSpecImagePolicyConfig)(ptr) = ClusterSpecImagePolicyConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecImagePolicyConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecImagePolicyConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecImagePolicyConfig)(ptr) = obj
		} else {
			*(*ClusterSpecImagePolicyConfig)(ptr) = ClusterSpecImagePolicyConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecImagePolicyConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecMetadataCodec struct {
}

func (ClusterSpecMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecMetadata)(ptr) == nil
}

func (ClusterSpecMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecMetadata)(ptr)
	var objs []ClusterSpecMetadata
	if obj != nil {
		objs = []ClusterSpecMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecMetadata)(ptr) = ClusterSpecMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecMetadata)(ptr) = objs[0]
			} else {
				*(*ClusterSpecMetadata)(ptr) = ClusterSpecMetadata{}
			}
		} else {
			*(*ClusterSpecMetadata)(ptr) = ClusterSpecMetadata{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecMetadata)(ptr) = obj
		} else {
			*(*ClusterSpecMetadata)(ptr) = ClusterSpecMetadata{}
		}
	default:
		iter.ReportError("decode ClusterSpecMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecOptionsCodec struct {
}

func (ClusterSpecOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecOptions)(ptr) == nil
}

func (ClusterSpecOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecOptions)(ptr)
	var objs []ClusterSpecOptions
	if obj != nil {
		objs = []ClusterSpecOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecOptions)(ptr) = ClusterSpecOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecOptions)(ptr) = objs[0]
			} else {
				*(*ClusterSpecOptions)(ptr) = ClusterSpecOptions{}
			}
		} else {
			*(*ClusterSpecOptions)(ptr) = ClusterSpecOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecOptions)(ptr) = obj
		} else {
			*(*ClusterSpecOptions)(ptr) = ClusterSpecOptions{}
		}
	default:
		iter.ReportError("decode ClusterSpecOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecOptionsAddOnsCodec struct {
}

func (ClusterSpecOptionsAddOnsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecOptionsAddOns)(ptr) == nil
}

func (ClusterSpecOptionsAddOnsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecOptionsAddOns)(ptr)
	var objs []ClusterSpecOptionsAddOns
	if obj != nil {
		objs = []ClusterSpecOptionsAddOns{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsAddOns{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecOptionsAddOnsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecOptionsAddOns)(ptr) = ClusterSpecOptionsAddOns{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecOptionsAddOns

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsAddOns{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecOptionsAddOns)(ptr) = objs[0]
			} else {
				*(*ClusterSpecOptionsAddOns)(ptr) = ClusterSpecOptionsAddOns{}
			}
		} else {
			*(*ClusterSpecOptionsAddOns)(ptr) = ClusterSpecOptionsAddOns{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecOptionsAddOns

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsAddOns{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecOptionsAddOns)(ptr) = obj
		} else {
			*(*ClusterSpecOptionsAddOns)(ptr) = ClusterSpecOptionsAddOns{}
		}
	default:
		iter.ReportError("decode ClusterSpecOptionsAddOns", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecOptionsAdmissionControllerOptionsCodec struct {
}

func (ClusterSpecOptionsAdmissionControllerOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecOptionsAdmissionControllerOptions)(ptr) == nil
}

func (ClusterSpecOptionsAdmissionControllerOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecOptionsAdmissionControllerOptions)(ptr)
	var objs []ClusterSpecOptionsAdmissionControllerOptions
	if obj != nil {
		objs = []ClusterSpecOptionsAdmissionControllerOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsAdmissionControllerOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecOptionsAdmissionControllerOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecOptionsAdmissionControllerOptions)(ptr) = ClusterSpecOptionsAdmissionControllerOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecOptionsAdmissionControllerOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsAdmissionControllerOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecOptionsAdmissionControllerOptions)(ptr) = objs[0]
			} else {
				*(*ClusterSpecOptionsAdmissionControllerOptions)(ptr) = ClusterSpecOptionsAdmissionControllerOptions{}
			}
		} else {
			*(*ClusterSpecOptionsAdmissionControllerOptions)(ptr) = ClusterSpecOptionsAdmissionControllerOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecOptionsAdmissionControllerOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsAdmissionControllerOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecOptionsAdmissionControllerOptions)(ptr) = obj
		} else {
			*(*ClusterSpecOptionsAdmissionControllerOptions)(ptr) = ClusterSpecOptionsAdmissionControllerOptions{}
		}
	default:
		iter.ReportError("decode ClusterSpecOptionsAdmissionControllerOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecOptionsKubernetesNetworkConfigCodec struct {
}

func (ClusterSpecOptionsKubernetesNetworkConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecOptionsKubernetesNetworkConfig)(ptr) == nil
}

func (ClusterSpecOptionsKubernetesNetworkConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecOptionsKubernetesNetworkConfig)(ptr)
	var objs []ClusterSpecOptionsKubernetesNetworkConfig
	if obj != nil {
		objs = []ClusterSpecOptionsKubernetesNetworkConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsKubernetesNetworkConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecOptionsKubernetesNetworkConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecOptionsKubernetesNetworkConfig)(ptr) = ClusterSpecOptionsKubernetesNetworkConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecOptionsKubernetesNetworkConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsKubernetesNetworkConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecOptionsKubernetesNetworkConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecOptionsKubernetesNetworkConfig)(ptr) = ClusterSpecOptionsKubernetesNetworkConfig{}
			}
		} else {
			*(*ClusterSpecOptionsKubernetesNetworkConfig)(ptr) = ClusterSpecOptionsKubernetesNetworkConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecOptionsKubernetesNetworkConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsKubernetesNetworkConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecOptionsKubernetesNetworkConfig)(ptr) = obj
		} else {
			*(*ClusterSpecOptionsKubernetesNetworkConfig)(ptr) = ClusterSpecOptionsKubernetesNetworkConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecOptionsKubernetesNetworkConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecOptionsPersistentVolumeConfigCodec struct {
}

func (ClusterSpecOptionsPersistentVolumeConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecOptionsPersistentVolumeConfig)(ptr) == nil
}

func (ClusterSpecOptionsPersistentVolumeConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecOptionsPersistentVolumeConfig)(ptr)
	var objs []ClusterSpecOptionsPersistentVolumeConfig
	if obj != nil {
		objs = []ClusterSpecOptionsPersistentVolumeConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsPersistentVolumeConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecOptionsPersistentVolumeConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecOptionsPersistentVolumeConfig)(ptr) = ClusterSpecOptionsPersistentVolumeConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecOptionsPersistentVolumeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsPersistentVolumeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecOptionsPersistentVolumeConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecOptionsPersistentVolumeConfig)(ptr) = ClusterSpecOptionsPersistentVolumeConfig{}
			}
		} else {
			*(*ClusterSpecOptionsPersistentVolumeConfig)(ptr) = ClusterSpecOptionsPersistentVolumeConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecOptionsPersistentVolumeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsPersistentVolumeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecOptionsPersistentVolumeConfig)(ptr) = obj
		} else {
			*(*ClusterSpecOptionsPersistentVolumeConfig)(ptr) = ClusterSpecOptionsPersistentVolumeConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecOptionsPersistentVolumeConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecOptionsServiceLbConfigCodec struct {
}

func (ClusterSpecOptionsServiceLbConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecOptionsServiceLbConfig)(ptr) == nil
}

func (ClusterSpecOptionsServiceLbConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecOptionsServiceLbConfig)(ptr)
	var objs []ClusterSpecOptionsServiceLbConfig
	if obj != nil {
		objs = []ClusterSpecOptionsServiceLbConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsServiceLbConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecOptionsServiceLbConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecOptionsServiceLbConfig)(ptr) = ClusterSpecOptionsServiceLbConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecOptionsServiceLbConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsServiceLbConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecOptionsServiceLbConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecOptionsServiceLbConfig)(ptr) = ClusterSpecOptionsServiceLbConfig{}
			}
		} else {
			*(*ClusterSpecOptionsServiceLbConfig)(ptr) = ClusterSpecOptionsServiceLbConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecOptionsServiceLbConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOptionsServiceLbConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecOptionsServiceLbConfig)(ptr) = obj
		} else {
			*(*ClusterSpecOptionsServiceLbConfig)(ptr) = ClusterSpecOptionsServiceLbConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecOptionsServiceLbConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecNodeConfigDetailsCodec struct {
}

func (NodePoolSpecNodeConfigDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecNodeConfigDetails)(ptr) == nil
}

func (NodePoolSpecNodeConfigDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecNodeConfigDetails)(ptr)
	var objs []NodePoolSpecNodeConfigDetails
	if obj != nil {
		objs = []NodePoolSpecNodeConfigDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecNodeConfigDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecNodeConfigDetails)(ptr) = NodePoolSpecNodeConfigDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecNodeConfigDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecNodeConfigDetails)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecNodeConfigDetails)(ptr) = NodePoolSpecNodeConfigDetails{}
			}
		} else {
			*(*NodePoolSpecNodeConfigDetails)(ptr) = NodePoolSpecNodeConfigDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodePoolSpecNodeConfigDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodePoolSpecNodeConfigDetails)(ptr) = obj
		} else {
			*(*NodePoolSpecNodeConfigDetails)(ptr) = NodePoolSpecNodeConfigDetails{}
		}
	default:
		iter.ReportError("decode NodePoolSpecNodeConfigDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecNodeShapeConfigCodec struct {
}

func (NodePoolSpecNodeShapeConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecNodeShapeConfig)(ptr) == nil
}

func (NodePoolSpecNodeShapeConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecNodeShapeConfig)(ptr)
	var objs []NodePoolSpecNodeShapeConfig
	if obj != nil {
		objs = []NodePoolSpecNodeShapeConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeShapeConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecNodeShapeConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecNodeShapeConfig)(ptr) = NodePoolSpecNodeShapeConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecNodeShapeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeShapeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecNodeShapeConfig)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecNodeShapeConfig)(ptr) = NodePoolSpecNodeShapeConfig{}
			}
		} else {
			*(*NodePoolSpecNodeShapeConfig)(ptr) = NodePoolSpecNodeShapeConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodePoolSpecNodeShapeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeShapeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodePoolSpecNodeShapeConfig)(ptr) = obj
		} else {
			*(*NodePoolSpecNodeShapeConfig)(ptr) = NodePoolSpecNodeShapeConfig{}
		}
	default:
		iter.ReportError("decode NodePoolSpecNodeShapeConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecNodeSourceCodec struct {
}

func (NodePoolSpecNodeSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecNodeSource)(ptr) == nil
}

func (NodePoolSpecNodeSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecNodeSource)(ptr)
	var objs []NodePoolSpecNodeSource
	if obj != nil {
		objs = []NodePoolSpecNodeSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecNodeSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecNodeSource)(ptr) = NodePoolSpecNodeSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecNodeSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecNodeSource)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecNodeSource)(ptr) = NodePoolSpecNodeSource{}
			}
		} else {
			*(*NodePoolSpecNodeSource)(ptr) = NodePoolSpecNodeSource{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodePoolSpecNodeSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodePoolSpecNodeSource)(ptr) = obj
		} else {
			*(*NodePoolSpecNodeSource)(ptr) = NodePoolSpecNodeSource{}
		}
	default:
		iter.ReportError("decode NodePoolSpecNodeSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecNodeSourceDetailsCodec struct {
}

func (NodePoolSpecNodeSourceDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecNodeSourceDetails)(ptr) == nil
}

func (NodePoolSpecNodeSourceDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecNodeSourceDetails)(ptr)
	var objs []NodePoolSpecNodeSourceDetails
	if obj != nil {
		objs = []NodePoolSpecNodeSourceDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeSourceDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecNodeSourceDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecNodeSourceDetails)(ptr) = NodePoolSpecNodeSourceDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecNodeSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecNodeSourceDetails)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecNodeSourceDetails)(ptr) = NodePoolSpecNodeSourceDetails{}
			}
		} else {
			*(*NodePoolSpecNodeSourceDetails)(ptr) = NodePoolSpecNodeSourceDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodePoolSpecNodeSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodePoolSpecNodeSourceDetails)(ptr) = obj
		} else {
			*(*NodePoolSpecNodeSourceDetails)(ptr) = NodePoolSpecNodeSourceDetails{}
		}
	default:
		iter.ReportError("decode NodePoolSpecNodeSourceDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecNodesErrorCodec struct {
}

func (NodePoolSpecNodesErrorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecNodesError)(ptr) == nil
}

func (NodePoolSpecNodesErrorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecNodesError)(ptr)
	var objs []NodePoolSpecNodesError
	if obj != nil {
		objs = []NodePoolSpecNodesError{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodesError{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecNodesErrorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecNodesError)(ptr) = NodePoolSpecNodesError{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecNodesError

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodesError{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecNodesError)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecNodesError)(ptr) = NodePoolSpecNodesError{}
			}
		} else {
			*(*NodePoolSpecNodesError)(ptr) = NodePoolSpecNodesError{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodePoolSpecNodesError

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodesError{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodePoolSpecNodesError)(ptr) = obj
		} else {
			*(*NodePoolSpecNodesError)(ptr) = NodePoolSpecNodesError{}
		}
	default:
		iter.ReportError("decode NodePoolSpecNodesError", "unexpected JSON type")
	}
}
