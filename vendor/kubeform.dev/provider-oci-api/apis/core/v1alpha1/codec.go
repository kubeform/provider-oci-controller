/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(BootVolumeSpecSourceDetails{}).Type1()):                                                                    BootVolumeSpecSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BootVolumeBackupSpecSourceDetails{}).Type1()):                                                              BootVolumeBackupSpecSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterNetworkSpecPlacementConfiguration{}).Type1()):                                                       ClusterNetworkSpecPlacementConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig{}).Type1()):                    ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesIcmpOptions{}).Type1()):                                          DefaultSecurityListSpecEgressSecurityRulesIcmpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesTcpOptions{}).Type1()):                                           DefaultSecurityListSpecEgressSecurityRulesTcpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}).Type1()):                            DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesUdpOptions{}).Type1()):                                           DefaultSecurityListSpecEgressSecurityRulesUdpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}).Type1()):                            DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesIcmpOptions{}).Type1()):                                         DefaultSecurityListSpecIngressSecurityRulesIcmpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesTcpOptions{}).Type1()):                                          DefaultSecurityListSpecIngressSecurityRulesTcpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}).Type1()):                           DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesUdpOptions{}).Type1()):                                          DefaultSecurityListSpecIngressSecurityRulesUdpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}).Type1()):                           DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DrgSpecDefaultDrgRouteTables{}).Type1()):                                                                   DrgSpecDefaultDrgRouteTablesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DrgAttachmentSpecNetworkDetails{}).Type1()):                                                                DrgAttachmentSpecNetworkDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DrgAttachmentManagementSpecNetworkDetails{}).Type1()):                                                      DrgAttachmentManagementSpecNetworkDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DrgRouteDistributionStatementSpecMatchCriteria{}).Type1()):                                                 DrgRouteDistributionStatementSpecMatchCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecAgentFeatures{}).Type1()):                                                                         ImageSpecAgentFeaturesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecImageSourceDetails{}).Type1()):                                                                    ImageSpecImageSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecLaunchOptions{}).Type1()):                                                                         ImageSpecLaunchOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAgentConfig{}).Type1()):                                                                        InstanceSpecAgentConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAvailabilityConfig{}).Type1()):                                                                 InstanceSpecAvailabilityConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecCreateVnicDetails{}).Type1()):                                                                  InstanceSpecCreateVnicDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecInstanceOptions{}).Type1()):                                                                    InstanceSpecInstanceOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecLaunchOptions{}).Type1()):                                                                      InstanceSpecLaunchOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPlatformConfig{}).Type1()):                                                                     InstanceSpecPlatformConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPreemptibleInstanceConfig{}).Type1()):                                                          InstanceSpecPreemptibleInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPreemptibleInstanceConfigPreemptionAction{}).Type1()):                                          InstanceSpecPreemptibleInstanceConfigPreemptionActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecShapeConfig{}).Type1()):                                                                        InstanceSpecShapeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecSourceDetails{}).Type1()):                                                                      InstanceSpecSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetails{}).Type1()):                                                       InstanceConfigurationSpecInstanceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails{}).Type1()):                              InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails{}).Type1()):                              InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails{}).Type1()):                 InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetails{}).Type1()):                                          InstanceConfigurationSpecInstanceDetailsLaunchDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig{}).Type1()):                               InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig{}).Type1()):                        InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails{}).Type1()):                         InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions{}).Type1()):                           InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions{}).Type1()):                             InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig{}).Type1()):                            InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig{}).Type1()):                 InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction{}).Type1()): InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig{}).Type1()):                               InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails{}).Type1()):                             InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails{}).Type1()):                        InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IpsecConnectionTunnelManagementSpecEncryptionDomainConfig{}).Type1()):                                      IpsecConnectionTunnelManagementSpecEncryptionDomainConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecIcmpOptions{}).Type1()):                                                NetworkSecurityGroupSecurityRuleSpecIcmpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecTcpOptions{}).Type1()):                                                 NetworkSecurityGroupSecurityRuleSpecTcpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange{}).Type1()):                             NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange{}).Type1()):                                  NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecUdpOptions{}).Type1()):                                                 NetworkSecurityGroupSecurityRuleSpecUdpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange{}).Type1()):                             NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange{}).Type1()):                                  NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesIcmpOptions{}).Type1()):                                                 SecurityListSpecEgressSecurityRulesIcmpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesTcpOptions{}).Type1()):                                                  SecurityListSpecEgressSecurityRulesTcpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}).Type1()):                                   SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesUdpOptions{}).Type1()):                                                  SecurityListSpecEgressSecurityRulesUdpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}).Type1()):                                   SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesIcmpOptions{}).Type1()):                                                SecurityListSpecIngressSecurityRulesIcmpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesTcpOptions{}).Type1()):                                                 SecurityListSpecIngressSecurityRulesTcpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}).Type1()):                                  SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesUdpOptions{}).Type1()):                                                 SecurityListSpecIngressSecurityRulesUdpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}).Type1()):                                  SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VnicAttachmentSpecCreateVnicDetails{}).Type1()):                                                            VnicAttachmentSpecCreateVnicDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VolumeSpecSourceDetails{}).Type1()):                                                                        VolumeSpecSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VolumeBackupSpecSourceDetails{}).Type1()):                                                                  VolumeBackupSpecSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VolumeGroupSpecSourceDetails{}).Type1()):                                                                   VolumeGroupSpecSourceDetailsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(BootVolumeSpecSourceDetails{}).Type1()):                                                                    BootVolumeSpecSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BootVolumeBackupSpecSourceDetails{}).Type1()):                                                              BootVolumeBackupSpecSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterNetworkSpecPlacementConfiguration{}).Type1()):                                                       ClusterNetworkSpecPlacementConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig{}).Type1()):                    ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesIcmpOptions{}).Type1()):                                          DefaultSecurityListSpecEgressSecurityRulesIcmpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesTcpOptions{}).Type1()):                                           DefaultSecurityListSpecEgressSecurityRulesTcpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}).Type1()):                            DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesUdpOptions{}).Type1()):                                           DefaultSecurityListSpecEgressSecurityRulesUdpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}).Type1()):                            DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesIcmpOptions{}).Type1()):                                         DefaultSecurityListSpecIngressSecurityRulesIcmpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesTcpOptions{}).Type1()):                                          DefaultSecurityListSpecIngressSecurityRulesTcpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}).Type1()):                           DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesUdpOptions{}).Type1()):                                          DefaultSecurityListSpecIngressSecurityRulesUdpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}).Type1()):                           DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DrgSpecDefaultDrgRouteTables{}).Type1()):                                                                   DrgSpecDefaultDrgRouteTablesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DrgAttachmentSpecNetworkDetails{}).Type1()):                                                                DrgAttachmentSpecNetworkDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DrgAttachmentManagementSpecNetworkDetails{}).Type1()):                                                      DrgAttachmentManagementSpecNetworkDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DrgRouteDistributionStatementSpecMatchCriteria{}).Type1()):                                                 DrgRouteDistributionStatementSpecMatchCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecAgentFeatures{}).Type1()):                                                                         ImageSpecAgentFeaturesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecImageSourceDetails{}).Type1()):                                                                    ImageSpecImageSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecLaunchOptions{}).Type1()):                                                                         ImageSpecLaunchOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAgentConfig{}).Type1()):                                                                        InstanceSpecAgentConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAvailabilityConfig{}).Type1()):                                                                 InstanceSpecAvailabilityConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecCreateVnicDetails{}).Type1()):                                                                  InstanceSpecCreateVnicDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecInstanceOptions{}).Type1()):                                                                    InstanceSpecInstanceOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecLaunchOptions{}).Type1()):                                                                      InstanceSpecLaunchOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPlatformConfig{}).Type1()):                                                                     InstanceSpecPlatformConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPreemptibleInstanceConfig{}).Type1()):                                                          InstanceSpecPreemptibleInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPreemptibleInstanceConfigPreemptionAction{}).Type1()):                                          InstanceSpecPreemptibleInstanceConfigPreemptionActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecShapeConfig{}).Type1()):                                                                        InstanceSpecShapeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecSourceDetails{}).Type1()):                                                                      InstanceSpecSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetails{}).Type1()):                                                       InstanceConfigurationSpecInstanceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails{}).Type1()):                              InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails{}).Type1()):                              InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails{}).Type1()):                 InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetails{}).Type1()):                                          InstanceConfigurationSpecInstanceDetailsLaunchDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig{}).Type1()):                               InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig{}).Type1()):                        InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails{}).Type1()):                         InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions{}).Type1()):                           InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions{}).Type1()):                             InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig{}).Type1()):                            InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig{}).Type1()):                 InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction{}).Type1()): InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig{}).Type1()):                               InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails{}).Type1()):                             InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails{}).Type1()):                        InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IpsecConnectionTunnelManagementSpecEncryptionDomainConfig{}).Type1()):                                      IpsecConnectionTunnelManagementSpecEncryptionDomainConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecIcmpOptions{}).Type1()):                                                NetworkSecurityGroupSecurityRuleSpecIcmpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecTcpOptions{}).Type1()):                                                 NetworkSecurityGroupSecurityRuleSpecTcpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange{}).Type1()):                             NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange{}).Type1()):                                  NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecUdpOptions{}).Type1()):                                                 NetworkSecurityGroupSecurityRuleSpecUdpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange{}).Type1()):                             NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange{}).Type1()):                                  NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesIcmpOptions{}).Type1()):                                                 SecurityListSpecEgressSecurityRulesIcmpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesTcpOptions{}).Type1()):                                                  SecurityListSpecEgressSecurityRulesTcpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}).Type1()):                                   SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesUdpOptions{}).Type1()):                                                  SecurityListSpecEgressSecurityRulesUdpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}).Type1()):                                   SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesIcmpOptions{}).Type1()):                                                SecurityListSpecIngressSecurityRulesIcmpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesTcpOptions{}).Type1()):                                                 SecurityListSpecIngressSecurityRulesTcpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}).Type1()):                                  SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesUdpOptions{}).Type1()):                                                 SecurityListSpecIngressSecurityRulesUdpOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}).Type1()):                                  SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VnicAttachmentSpecCreateVnicDetails{}).Type1()):                                                            VnicAttachmentSpecCreateVnicDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VolumeSpecSourceDetails{}).Type1()):                                                                        VolumeSpecSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VolumeBackupSpecSourceDetails{}).Type1()):                                                                  VolumeBackupSpecSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VolumeGroupSpecSourceDetails{}).Type1()):                                                                   VolumeGroupSpecSourceDetailsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type BootVolumeSpecSourceDetailsCodec struct {
}

func (BootVolumeSpecSourceDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BootVolumeSpecSourceDetails)(ptr) == nil
}

func (BootVolumeSpecSourceDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BootVolumeSpecSourceDetails)(ptr)
	var objs []BootVolumeSpecSourceDetails
	if obj != nil {
		objs = []BootVolumeSpecSourceDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BootVolumeSpecSourceDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BootVolumeSpecSourceDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BootVolumeSpecSourceDetails)(ptr) = BootVolumeSpecSourceDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BootVolumeSpecSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BootVolumeSpecSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BootVolumeSpecSourceDetails)(ptr) = objs[0]
			} else {
				*(*BootVolumeSpecSourceDetails)(ptr) = BootVolumeSpecSourceDetails{}
			}
		} else {
			*(*BootVolumeSpecSourceDetails)(ptr) = BootVolumeSpecSourceDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BootVolumeSpecSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BootVolumeSpecSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BootVolumeSpecSourceDetails)(ptr) = obj
		} else {
			*(*BootVolumeSpecSourceDetails)(ptr) = BootVolumeSpecSourceDetails{}
		}
	default:
		iter.ReportError("decode BootVolumeSpecSourceDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BootVolumeBackupSpecSourceDetailsCodec struct {
}

func (BootVolumeBackupSpecSourceDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BootVolumeBackupSpecSourceDetails)(ptr) == nil
}

func (BootVolumeBackupSpecSourceDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BootVolumeBackupSpecSourceDetails)(ptr)
	var objs []BootVolumeBackupSpecSourceDetails
	if obj != nil {
		objs = []BootVolumeBackupSpecSourceDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BootVolumeBackupSpecSourceDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BootVolumeBackupSpecSourceDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BootVolumeBackupSpecSourceDetails)(ptr) = BootVolumeBackupSpecSourceDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BootVolumeBackupSpecSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BootVolumeBackupSpecSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BootVolumeBackupSpecSourceDetails)(ptr) = objs[0]
			} else {
				*(*BootVolumeBackupSpecSourceDetails)(ptr) = BootVolumeBackupSpecSourceDetails{}
			}
		} else {
			*(*BootVolumeBackupSpecSourceDetails)(ptr) = BootVolumeBackupSpecSourceDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BootVolumeBackupSpecSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BootVolumeBackupSpecSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BootVolumeBackupSpecSourceDetails)(ptr) = obj
		} else {
			*(*BootVolumeBackupSpecSourceDetails)(ptr) = BootVolumeBackupSpecSourceDetails{}
		}
	default:
		iter.ReportError("decode BootVolumeBackupSpecSourceDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterNetworkSpecPlacementConfigurationCodec struct {
}

func (ClusterNetworkSpecPlacementConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterNetworkSpecPlacementConfiguration)(ptr) == nil
}

func (ClusterNetworkSpecPlacementConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterNetworkSpecPlacementConfiguration)(ptr)
	var objs []ClusterNetworkSpecPlacementConfiguration
	if obj != nil {
		objs = []ClusterNetworkSpecPlacementConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterNetworkSpecPlacementConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterNetworkSpecPlacementConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterNetworkSpecPlacementConfiguration)(ptr) = ClusterNetworkSpecPlacementConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterNetworkSpecPlacementConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterNetworkSpecPlacementConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterNetworkSpecPlacementConfiguration)(ptr) = objs[0]
			} else {
				*(*ClusterNetworkSpecPlacementConfiguration)(ptr) = ClusterNetworkSpecPlacementConfiguration{}
			}
		} else {
			*(*ClusterNetworkSpecPlacementConfiguration)(ptr) = ClusterNetworkSpecPlacementConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterNetworkSpecPlacementConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterNetworkSpecPlacementConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterNetworkSpecPlacementConfiguration)(ptr) = obj
		} else {
			*(*ClusterNetworkSpecPlacementConfiguration)(ptr) = ClusterNetworkSpecPlacementConfiguration{}
		}
	default:
		iter.ReportError("decode ClusterNetworkSpecPlacementConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfigCodec struct {
}

func (ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig)(ptr) == nil
}

func (ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig)(ptr)
	var objs []ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig
	if obj != nil {
		objs = []ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig)(ptr) = ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig)(ptr) = objs[0]
			} else {
				*(*ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig)(ptr) = ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig{}
			}
		} else {
			*(*ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig)(ptr) = ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig)(ptr) = obj
		} else {
			*(*ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig)(ptr) = ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig{}
		}
	default:
		iter.ReportError("decode ComputeCapacityReservationSpecInstanceReservationConfigsInstanceShapeConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DefaultSecurityListSpecEgressSecurityRulesIcmpOptionsCodec struct {
}

func (DefaultSecurityListSpecEgressSecurityRulesIcmpOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DefaultSecurityListSpecEgressSecurityRulesIcmpOptions)(ptr) == nil
}

func (DefaultSecurityListSpecEgressSecurityRulesIcmpOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DefaultSecurityListSpecEgressSecurityRulesIcmpOptions)(ptr)
	var objs []DefaultSecurityListSpecEgressSecurityRulesIcmpOptions
	if obj != nil {
		objs = []DefaultSecurityListSpecEgressSecurityRulesIcmpOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesIcmpOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DefaultSecurityListSpecEgressSecurityRulesIcmpOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DefaultSecurityListSpecEgressSecurityRulesIcmpOptions)(ptr) = DefaultSecurityListSpecEgressSecurityRulesIcmpOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DefaultSecurityListSpecEgressSecurityRulesIcmpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesIcmpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DefaultSecurityListSpecEgressSecurityRulesIcmpOptions)(ptr) = objs[0]
			} else {
				*(*DefaultSecurityListSpecEgressSecurityRulesIcmpOptions)(ptr) = DefaultSecurityListSpecEgressSecurityRulesIcmpOptions{}
			}
		} else {
			*(*DefaultSecurityListSpecEgressSecurityRulesIcmpOptions)(ptr) = DefaultSecurityListSpecEgressSecurityRulesIcmpOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DefaultSecurityListSpecEgressSecurityRulesIcmpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesIcmpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DefaultSecurityListSpecEgressSecurityRulesIcmpOptions)(ptr) = obj
		} else {
			*(*DefaultSecurityListSpecEgressSecurityRulesIcmpOptions)(ptr) = DefaultSecurityListSpecEgressSecurityRulesIcmpOptions{}
		}
	default:
		iter.ReportError("decode DefaultSecurityListSpecEgressSecurityRulesIcmpOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DefaultSecurityListSpecEgressSecurityRulesTcpOptionsCodec struct {
}

func (DefaultSecurityListSpecEgressSecurityRulesTcpOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DefaultSecurityListSpecEgressSecurityRulesTcpOptions)(ptr) == nil
}

func (DefaultSecurityListSpecEgressSecurityRulesTcpOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DefaultSecurityListSpecEgressSecurityRulesTcpOptions)(ptr)
	var objs []DefaultSecurityListSpecEgressSecurityRulesTcpOptions
	if obj != nil {
		objs = []DefaultSecurityListSpecEgressSecurityRulesTcpOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesTcpOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DefaultSecurityListSpecEgressSecurityRulesTcpOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DefaultSecurityListSpecEgressSecurityRulesTcpOptions)(ptr) = DefaultSecurityListSpecEgressSecurityRulesTcpOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DefaultSecurityListSpecEgressSecurityRulesTcpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesTcpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DefaultSecurityListSpecEgressSecurityRulesTcpOptions)(ptr) = objs[0]
			} else {
				*(*DefaultSecurityListSpecEgressSecurityRulesTcpOptions)(ptr) = DefaultSecurityListSpecEgressSecurityRulesTcpOptions{}
			}
		} else {
			*(*DefaultSecurityListSpecEgressSecurityRulesTcpOptions)(ptr) = DefaultSecurityListSpecEgressSecurityRulesTcpOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DefaultSecurityListSpecEgressSecurityRulesTcpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesTcpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DefaultSecurityListSpecEgressSecurityRulesTcpOptions)(ptr) = obj
		} else {
			*(*DefaultSecurityListSpecEgressSecurityRulesTcpOptions)(ptr) = DefaultSecurityListSpecEgressSecurityRulesTcpOptions{}
		}
	default:
		iter.ReportError("decode DefaultSecurityListSpecEgressSecurityRulesTcpOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRangeCodec struct {
}

func (DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange)(ptr) == nil
}

func (DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange)(ptr)
	var objs []DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange
	if obj != nil {
		objs = []DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange)(ptr) = DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange)(ptr) = objs[0]
			} else {
				*(*DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange)(ptr) = DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}
			}
		} else {
			*(*DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange)(ptr) = DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange)(ptr) = obj
		} else {
			*(*DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange)(ptr) = DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}
		}
	default:
		iter.ReportError("decode DefaultSecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DefaultSecurityListSpecEgressSecurityRulesUdpOptionsCodec struct {
}

func (DefaultSecurityListSpecEgressSecurityRulesUdpOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DefaultSecurityListSpecEgressSecurityRulesUdpOptions)(ptr) == nil
}

func (DefaultSecurityListSpecEgressSecurityRulesUdpOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DefaultSecurityListSpecEgressSecurityRulesUdpOptions)(ptr)
	var objs []DefaultSecurityListSpecEgressSecurityRulesUdpOptions
	if obj != nil {
		objs = []DefaultSecurityListSpecEgressSecurityRulesUdpOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesUdpOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DefaultSecurityListSpecEgressSecurityRulesUdpOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DefaultSecurityListSpecEgressSecurityRulesUdpOptions)(ptr) = DefaultSecurityListSpecEgressSecurityRulesUdpOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DefaultSecurityListSpecEgressSecurityRulesUdpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesUdpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DefaultSecurityListSpecEgressSecurityRulesUdpOptions)(ptr) = objs[0]
			} else {
				*(*DefaultSecurityListSpecEgressSecurityRulesUdpOptions)(ptr) = DefaultSecurityListSpecEgressSecurityRulesUdpOptions{}
			}
		} else {
			*(*DefaultSecurityListSpecEgressSecurityRulesUdpOptions)(ptr) = DefaultSecurityListSpecEgressSecurityRulesUdpOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DefaultSecurityListSpecEgressSecurityRulesUdpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesUdpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DefaultSecurityListSpecEgressSecurityRulesUdpOptions)(ptr) = obj
		} else {
			*(*DefaultSecurityListSpecEgressSecurityRulesUdpOptions)(ptr) = DefaultSecurityListSpecEgressSecurityRulesUdpOptions{}
		}
	default:
		iter.ReportError("decode DefaultSecurityListSpecEgressSecurityRulesUdpOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRangeCodec struct {
}

func (DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange)(ptr) == nil
}

func (DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange)(ptr)
	var objs []DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange
	if obj != nil {
		objs = []DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange)(ptr) = DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange)(ptr) = objs[0]
			} else {
				*(*DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange)(ptr) = DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}
			}
		} else {
			*(*DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange)(ptr) = DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange)(ptr) = obj
		} else {
			*(*DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange)(ptr) = DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}
		}
	default:
		iter.ReportError("decode DefaultSecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DefaultSecurityListSpecIngressSecurityRulesIcmpOptionsCodec struct {
}

func (DefaultSecurityListSpecIngressSecurityRulesIcmpOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DefaultSecurityListSpecIngressSecurityRulesIcmpOptions)(ptr) == nil
}

func (DefaultSecurityListSpecIngressSecurityRulesIcmpOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DefaultSecurityListSpecIngressSecurityRulesIcmpOptions)(ptr)
	var objs []DefaultSecurityListSpecIngressSecurityRulesIcmpOptions
	if obj != nil {
		objs = []DefaultSecurityListSpecIngressSecurityRulesIcmpOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesIcmpOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DefaultSecurityListSpecIngressSecurityRulesIcmpOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DefaultSecurityListSpecIngressSecurityRulesIcmpOptions)(ptr) = DefaultSecurityListSpecIngressSecurityRulesIcmpOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DefaultSecurityListSpecIngressSecurityRulesIcmpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesIcmpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DefaultSecurityListSpecIngressSecurityRulesIcmpOptions)(ptr) = objs[0]
			} else {
				*(*DefaultSecurityListSpecIngressSecurityRulesIcmpOptions)(ptr) = DefaultSecurityListSpecIngressSecurityRulesIcmpOptions{}
			}
		} else {
			*(*DefaultSecurityListSpecIngressSecurityRulesIcmpOptions)(ptr) = DefaultSecurityListSpecIngressSecurityRulesIcmpOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DefaultSecurityListSpecIngressSecurityRulesIcmpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesIcmpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DefaultSecurityListSpecIngressSecurityRulesIcmpOptions)(ptr) = obj
		} else {
			*(*DefaultSecurityListSpecIngressSecurityRulesIcmpOptions)(ptr) = DefaultSecurityListSpecIngressSecurityRulesIcmpOptions{}
		}
	default:
		iter.ReportError("decode DefaultSecurityListSpecIngressSecurityRulesIcmpOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DefaultSecurityListSpecIngressSecurityRulesTcpOptionsCodec struct {
}

func (DefaultSecurityListSpecIngressSecurityRulesTcpOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DefaultSecurityListSpecIngressSecurityRulesTcpOptions)(ptr) == nil
}

func (DefaultSecurityListSpecIngressSecurityRulesTcpOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DefaultSecurityListSpecIngressSecurityRulesTcpOptions)(ptr)
	var objs []DefaultSecurityListSpecIngressSecurityRulesTcpOptions
	if obj != nil {
		objs = []DefaultSecurityListSpecIngressSecurityRulesTcpOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesTcpOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DefaultSecurityListSpecIngressSecurityRulesTcpOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DefaultSecurityListSpecIngressSecurityRulesTcpOptions)(ptr) = DefaultSecurityListSpecIngressSecurityRulesTcpOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DefaultSecurityListSpecIngressSecurityRulesTcpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesTcpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DefaultSecurityListSpecIngressSecurityRulesTcpOptions)(ptr) = objs[0]
			} else {
				*(*DefaultSecurityListSpecIngressSecurityRulesTcpOptions)(ptr) = DefaultSecurityListSpecIngressSecurityRulesTcpOptions{}
			}
		} else {
			*(*DefaultSecurityListSpecIngressSecurityRulesTcpOptions)(ptr) = DefaultSecurityListSpecIngressSecurityRulesTcpOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DefaultSecurityListSpecIngressSecurityRulesTcpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesTcpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DefaultSecurityListSpecIngressSecurityRulesTcpOptions)(ptr) = obj
		} else {
			*(*DefaultSecurityListSpecIngressSecurityRulesTcpOptions)(ptr) = DefaultSecurityListSpecIngressSecurityRulesTcpOptions{}
		}
	default:
		iter.ReportError("decode DefaultSecurityListSpecIngressSecurityRulesTcpOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRangeCodec struct {
}

func (DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange)(ptr) == nil
}

func (DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange)(ptr)
	var objs []DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange
	if obj != nil {
		objs = []DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange)(ptr) = DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange)(ptr) = objs[0]
			} else {
				*(*DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange)(ptr) = DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}
			}
		} else {
			*(*DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange)(ptr) = DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange)(ptr) = obj
		} else {
			*(*DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange)(ptr) = DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}
		}
	default:
		iter.ReportError("decode DefaultSecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DefaultSecurityListSpecIngressSecurityRulesUdpOptionsCodec struct {
}

func (DefaultSecurityListSpecIngressSecurityRulesUdpOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DefaultSecurityListSpecIngressSecurityRulesUdpOptions)(ptr) == nil
}

func (DefaultSecurityListSpecIngressSecurityRulesUdpOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DefaultSecurityListSpecIngressSecurityRulesUdpOptions)(ptr)
	var objs []DefaultSecurityListSpecIngressSecurityRulesUdpOptions
	if obj != nil {
		objs = []DefaultSecurityListSpecIngressSecurityRulesUdpOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesUdpOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DefaultSecurityListSpecIngressSecurityRulesUdpOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DefaultSecurityListSpecIngressSecurityRulesUdpOptions)(ptr) = DefaultSecurityListSpecIngressSecurityRulesUdpOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DefaultSecurityListSpecIngressSecurityRulesUdpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesUdpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DefaultSecurityListSpecIngressSecurityRulesUdpOptions)(ptr) = objs[0]
			} else {
				*(*DefaultSecurityListSpecIngressSecurityRulesUdpOptions)(ptr) = DefaultSecurityListSpecIngressSecurityRulesUdpOptions{}
			}
		} else {
			*(*DefaultSecurityListSpecIngressSecurityRulesUdpOptions)(ptr) = DefaultSecurityListSpecIngressSecurityRulesUdpOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DefaultSecurityListSpecIngressSecurityRulesUdpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesUdpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DefaultSecurityListSpecIngressSecurityRulesUdpOptions)(ptr) = obj
		} else {
			*(*DefaultSecurityListSpecIngressSecurityRulesUdpOptions)(ptr) = DefaultSecurityListSpecIngressSecurityRulesUdpOptions{}
		}
	default:
		iter.ReportError("decode DefaultSecurityListSpecIngressSecurityRulesUdpOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRangeCodec struct {
}

func (DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange)(ptr) == nil
}

func (DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange)(ptr)
	var objs []DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange
	if obj != nil {
		objs = []DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange)(ptr) = DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange)(ptr) = objs[0]
			} else {
				*(*DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange)(ptr) = DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}
			}
		} else {
			*(*DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange)(ptr) = DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange)(ptr) = obj
		} else {
			*(*DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange)(ptr) = DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}
		}
	default:
		iter.ReportError("decode DefaultSecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DrgSpecDefaultDrgRouteTablesCodec struct {
}

func (DrgSpecDefaultDrgRouteTablesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DrgSpecDefaultDrgRouteTables)(ptr) == nil
}

func (DrgSpecDefaultDrgRouteTablesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DrgSpecDefaultDrgRouteTables)(ptr)
	var objs []DrgSpecDefaultDrgRouteTables
	if obj != nil {
		objs = []DrgSpecDefaultDrgRouteTables{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DrgSpecDefaultDrgRouteTables{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DrgSpecDefaultDrgRouteTablesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DrgSpecDefaultDrgRouteTables)(ptr) = DrgSpecDefaultDrgRouteTables{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DrgSpecDefaultDrgRouteTables

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DrgSpecDefaultDrgRouteTables{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DrgSpecDefaultDrgRouteTables)(ptr) = objs[0]
			} else {
				*(*DrgSpecDefaultDrgRouteTables)(ptr) = DrgSpecDefaultDrgRouteTables{}
			}
		} else {
			*(*DrgSpecDefaultDrgRouteTables)(ptr) = DrgSpecDefaultDrgRouteTables{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DrgSpecDefaultDrgRouteTables

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DrgSpecDefaultDrgRouteTables{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DrgSpecDefaultDrgRouteTables)(ptr) = obj
		} else {
			*(*DrgSpecDefaultDrgRouteTables)(ptr) = DrgSpecDefaultDrgRouteTables{}
		}
	default:
		iter.ReportError("decode DrgSpecDefaultDrgRouteTables", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DrgAttachmentSpecNetworkDetailsCodec struct {
}

func (DrgAttachmentSpecNetworkDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DrgAttachmentSpecNetworkDetails)(ptr) == nil
}

func (DrgAttachmentSpecNetworkDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DrgAttachmentSpecNetworkDetails)(ptr)
	var objs []DrgAttachmentSpecNetworkDetails
	if obj != nil {
		objs = []DrgAttachmentSpecNetworkDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DrgAttachmentSpecNetworkDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DrgAttachmentSpecNetworkDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DrgAttachmentSpecNetworkDetails)(ptr) = DrgAttachmentSpecNetworkDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DrgAttachmentSpecNetworkDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DrgAttachmentSpecNetworkDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DrgAttachmentSpecNetworkDetails)(ptr) = objs[0]
			} else {
				*(*DrgAttachmentSpecNetworkDetails)(ptr) = DrgAttachmentSpecNetworkDetails{}
			}
		} else {
			*(*DrgAttachmentSpecNetworkDetails)(ptr) = DrgAttachmentSpecNetworkDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DrgAttachmentSpecNetworkDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DrgAttachmentSpecNetworkDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DrgAttachmentSpecNetworkDetails)(ptr) = obj
		} else {
			*(*DrgAttachmentSpecNetworkDetails)(ptr) = DrgAttachmentSpecNetworkDetails{}
		}
	default:
		iter.ReportError("decode DrgAttachmentSpecNetworkDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DrgAttachmentManagementSpecNetworkDetailsCodec struct {
}

func (DrgAttachmentManagementSpecNetworkDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DrgAttachmentManagementSpecNetworkDetails)(ptr) == nil
}

func (DrgAttachmentManagementSpecNetworkDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DrgAttachmentManagementSpecNetworkDetails)(ptr)
	var objs []DrgAttachmentManagementSpecNetworkDetails
	if obj != nil {
		objs = []DrgAttachmentManagementSpecNetworkDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DrgAttachmentManagementSpecNetworkDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DrgAttachmentManagementSpecNetworkDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DrgAttachmentManagementSpecNetworkDetails)(ptr) = DrgAttachmentManagementSpecNetworkDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DrgAttachmentManagementSpecNetworkDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DrgAttachmentManagementSpecNetworkDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DrgAttachmentManagementSpecNetworkDetails)(ptr) = objs[0]
			} else {
				*(*DrgAttachmentManagementSpecNetworkDetails)(ptr) = DrgAttachmentManagementSpecNetworkDetails{}
			}
		} else {
			*(*DrgAttachmentManagementSpecNetworkDetails)(ptr) = DrgAttachmentManagementSpecNetworkDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DrgAttachmentManagementSpecNetworkDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DrgAttachmentManagementSpecNetworkDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DrgAttachmentManagementSpecNetworkDetails)(ptr) = obj
		} else {
			*(*DrgAttachmentManagementSpecNetworkDetails)(ptr) = DrgAttachmentManagementSpecNetworkDetails{}
		}
	default:
		iter.ReportError("decode DrgAttachmentManagementSpecNetworkDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DrgRouteDistributionStatementSpecMatchCriteriaCodec struct {
}

func (DrgRouteDistributionStatementSpecMatchCriteriaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DrgRouteDistributionStatementSpecMatchCriteria)(ptr) == nil
}

func (DrgRouteDistributionStatementSpecMatchCriteriaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DrgRouteDistributionStatementSpecMatchCriteria)(ptr)
	var objs []DrgRouteDistributionStatementSpecMatchCriteria
	if obj != nil {
		objs = []DrgRouteDistributionStatementSpecMatchCriteria{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DrgRouteDistributionStatementSpecMatchCriteria{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DrgRouteDistributionStatementSpecMatchCriteriaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DrgRouteDistributionStatementSpecMatchCriteria)(ptr) = DrgRouteDistributionStatementSpecMatchCriteria{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DrgRouteDistributionStatementSpecMatchCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DrgRouteDistributionStatementSpecMatchCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DrgRouteDistributionStatementSpecMatchCriteria)(ptr) = objs[0]
			} else {
				*(*DrgRouteDistributionStatementSpecMatchCriteria)(ptr) = DrgRouteDistributionStatementSpecMatchCriteria{}
			}
		} else {
			*(*DrgRouteDistributionStatementSpecMatchCriteria)(ptr) = DrgRouteDistributionStatementSpecMatchCriteria{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DrgRouteDistributionStatementSpecMatchCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DrgRouteDistributionStatementSpecMatchCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DrgRouteDistributionStatementSpecMatchCriteria)(ptr) = obj
		} else {
			*(*DrgRouteDistributionStatementSpecMatchCriteria)(ptr) = DrgRouteDistributionStatementSpecMatchCriteria{}
		}
	default:
		iter.ReportError("decode DrgRouteDistributionStatementSpecMatchCriteria", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ImageSpecAgentFeaturesCodec struct {
}

func (ImageSpecAgentFeaturesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ImageSpecAgentFeatures)(ptr) == nil
}

func (ImageSpecAgentFeaturesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ImageSpecAgentFeatures)(ptr)
	var objs []ImageSpecAgentFeatures
	if obj != nil {
		objs = []ImageSpecAgentFeatures{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecAgentFeatures{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ImageSpecAgentFeaturesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ImageSpecAgentFeatures)(ptr) = ImageSpecAgentFeatures{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ImageSpecAgentFeatures

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecAgentFeatures{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ImageSpecAgentFeatures)(ptr) = objs[0]
			} else {
				*(*ImageSpecAgentFeatures)(ptr) = ImageSpecAgentFeatures{}
			}
		} else {
			*(*ImageSpecAgentFeatures)(ptr) = ImageSpecAgentFeatures{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ImageSpecAgentFeatures

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecAgentFeatures{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ImageSpecAgentFeatures)(ptr) = obj
		} else {
			*(*ImageSpecAgentFeatures)(ptr) = ImageSpecAgentFeatures{}
		}
	default:
		iter.ReportError("decode ImageSpecAgentFeatures", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ImageSpecImageSourceDetailsCodec struct {
}

func (ImageSpecImageSourceDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ImageSpecImageSourceDetails)(ptr) == nil
}

func (ImageSpecImageSourceDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ImageSpecImageSourceDetails)(ptr)
	var objs []ImageSpecImageSourceDetails
	if obj != nil {
		objs = []ImageSpecImageSourceDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecImageSourceDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ImageSpecImageSourceDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ImageSpecImageSourceDetails)(ptr) = ImageSpecImageSourceDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ImageSpecImageSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecImageSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ImageSpecImageSourceDetails)(ptr) = objs[0]
			} else {
				*(*ImageSpecImageSourceDetails)(ptr) = ImageSpecImageSourceDetails{}
			}
		} else {
			*(*ImageSpecImageSourceDetails)(ptr) = ImageSpecImageSourceDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ImageSpecImageSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecImageSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ImageSpecImageSourceDetails)(ptr) = obj
		} else {
			*(*ImageSpecImageSourceDetails)(ptr) = ImageSpecImageSourceDetails{}
		}
	default:
		iter.ReportError("decode ImageSpecImageSourceDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ImageSpecLaunchOptionsCodec struct {
}

func (ImageSpecLaunchOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ImageSpecLaunchOptions)(ptr) == nil
}

func (ImageSpecLaunchOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ImageSpecLaunchOptions)(ptr)
	var objs []ImageSpecLaunchOptions
	if obj != nil {
		objs = []ImageSpecLaunchOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecLaunchOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ImageSpecLaunchOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ImageSpecLaunchOptions)(ptr) = ImageSpecLaunchOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ImageSpecLaunchOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecLaunchOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ImageSpecLaunchOptions)(ptr) = objs[0]
			} else {
				*(*ImageSpecLaunchOptions)(ptr) = ImageSpecLaunchOptions{}
			}
		} else {
			*(*ImageSpecLaunchOptions)(ptr) = ImageSpecLaunchOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ImageSpecLaunchOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecLaunchOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ImageSpecLaunchOptions)(ptr) = obj
		} else {
			*(*ImageSpecLaunchOptions)(ptr) = ImageSpecLaunchOptions{}
		}
	default:
		iter.ReportError("decode ImageSpecLaunchOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecAgentConfigCodec struct {
}

func (InstanceSpecAgentConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecAgentConfig)(ptr) == nil
}

func (InstanceSpecAgentConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecAgentConfig)(ptr)
	var objs []InstanceSpecAgentConfig
	if obj != nil {
		objs = []InstanceSpecAgentConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAgentConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecAgentConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecAgentConfig)(ptr) = InstanceSpecAgentConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecAgentConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAgentConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecAgentConfig)(ptr) = objs[0]
			} else {
				*(*InstanceSpecAgentConfig)(ptr) = InstanceSpecAgentConfig{}
			}
		} else {
			*(*InstanceSpecAgentConfig)(ptr) = InstanceSpecAgentConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecAgentConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAgentConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecAgentConfig)(ptr) = obj
		} else {
			*(*InstanceSpecAgentConfig)(ptr) = InstanceSpecAgentConfig{}
		}
	default:
		iter.ReportError("decode InstanceSpecAgentConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecAvailabilityConfigCodec struct {
}

func (InstanceSpecAvailabilityConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecAvailabilityConfig)(ptr) == nil
}

func (InstanceSpecAvailabilityConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecAvailabilityConfig)(ptr)
	var objs []InstanceSpecAvailabilityConfig
	if obj != nil {
		objs = []InstanceSpecAvailabilityConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAvailabilityConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecAvailabilityConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecAvailabilityConfig)(ptr) = InstanceSpecAvailabilityConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecAvailabilityConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAvailabilityConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecAvailabilityConfig)(ptr) = objs[0]
			} else {
				*(*InstanceSpecAvailabilityConfig)(ptr) = InstanceSpecAvailabilityConfig{}
			}
		} else {
			*(*InstanceSpecAvailabilityConfig)(ptr) = InstanceSpecAvailabilityConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecAvailabilityConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAvailabilityConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecAvailabilityConfig)(ptr) = obj
		} else {
			*(*InstanceSpecAvailabilityConfig)(ptr) = InstanceSpecAvailabilityConfig{}
		}
	default:
		iter.ReportError("decode InstanceSpecAvailabilityConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecCreateVnicDetailsCodec struct {
}

func (InstanceSpecCreateVnicDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecCreateVnicDetails)(ptr) == nil
}

func (InstanceSpecCreateVnicDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecCreateVnicDetails)(ptr)
	var objs []InstanceSpecCreateVnicDetails
	if obj != nil {
		objs = []InstanceSpecCreateVnicDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecCreateVnicDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecCreateVnicDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecCreateVnicDetails)(ptr) = InstanceSpecCreateVnicDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecCreateVnicDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecCreateVnicDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecCreateVnicDetails)(ptr) = objs[0]
			} else {
				*(*InstanceSpecCreateVnicDetails)(ptr) = InstanceSpecCreateVnicDetails{}
			}
		} else {
			*(*InstanceSpecCreateVnicDetails)(ptr) = InstanceSpecCreateVnicDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecCreateVnicDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecCreateVnicDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecCreateVnicDetails)(ptr) = obj
		} else {
			*(*InstanceSpecCreateVnicDetails)(ptr) = InstanceSpecCreateVnicDetails{}
		}
	default:
		iter.ReportError("decode InstanceSpecCreateVnicDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecInstanceOptionsCodec struct {
}

func (InstanceSpecInstanceOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecInstanceOptions)(ptr) == nil
}

func (InstanceSpecInstanceOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecInstanceOptions)(ptr)
	var objs []InstanceSpecInstanceOptions
	if obj != nil {
		objs = []InstanceSpecInstanceOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecInstanceOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecInstanceOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecInstanceOptions)(ptr) = InstanceSpecInstanceOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecInstanceOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecInstanceOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecInstanceOptions)(ptr) = objs[0]
			} else {
				*(*InstanceSpecInstanceOptions)(ptr) = InstanceSpecInstanceOptions{}
			}
		} else {
			*(*InstanceSpecInstanceOptions)(ptr) = InstanceSpecInstanceOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecInstanceOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecInstanceOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecInstanceOptions)(ptr) = obj
		} else {
			*(*InstanceSpecInstanceOptions)(ptr) = InstanceSpecInstanceOptions{}
		}
	default:
		iter.ReportError("decode InstanceSpecInstanceOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecLaunchOptionsCodec struct {
}

func (InstanceSpecLaunchOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecLaunchOptions)(ptr) == nil
}

func (InstanceSpecLaunchOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecLaunchOptions)(ptr)
	var objs []InstanceSpecLaunchOptions
	if obj != nil {
		objs = []InstanceSpecLaunchOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecLaunchOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecLaunchOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecLaunchOptions)(ptr) = InstanceSpecLaunchOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecLaunchOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecLaunchOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecLaunchOptions)(ptr) = objs[0]
			} else {
				*(*InstanceSpecLaunchOptions)(ptr) = InstanceSpecLaunchOptions{}
			}
		} else {
			*(*InstanceSpecLaunchOptions)(ptr) = InstanceSpecLaunchOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecLaunchOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecLaunchOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecLaunchOptions)(ptr) = obj
		} else {
			*(*InstanceSpecLaunchOptions)(ptr) = InstanceSpecLaunchOptions{}
		}
	default:
		iter.ReportError("decode InstanceSpecLaunchOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecPlatformConfigCodec struct {
}

func (InstanceSpecPlatformConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecPlatformConfig)(ptr) == nil
}

func (InstanceSpecPlatformConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecPlatformConfig)(ptr)
	var objs []InstanceSpecPlatformConfig
	if obj != nil {
		objs = []InstanceSpecPlatformConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPlatformConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecPlatformConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecPlatformConfig)(ptr) = InstanceSpecPlatformConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecPlatformConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPlatformConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecPlatformConfig)(ptr) = objs[0]
			} else {
				*(*InstanceSpecPlatformConfig)(ptr) = InstanceSpecPlatformConfig{}
			}
		} else {
			*(*InstanceSpecPlatformConfig)(ptr) = InstanceSpecPlatformConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecPlatformConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPlatformConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecPlatformConfig)(ptr) = obj
		} else {
			*(*InstanceSpecPlatformConfig)(ptr) = InstanceSpecPlatformConfig{}
		}
	default:
		iter.ReportError("decode InstanceSpecPlatformConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecPreemptibleInstanceConfigCodec struct {
}

func (InstanceSpecPreemptibleInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecPreemptibleInstanceConfig)(ptr) == nil
}

func (InstanceSpecPreemptibleInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecPreemptibleInstanceConfig)(ptr)
	var objs []InstanceSpecPreemptibleInstanceConfig
	if obj != nil {
		objs = []InstanceSpecPreemptibleInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPreemptibleInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecPreemptibleInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecPreemptibleInstanceConfig)(ptr) = InstanceSpecPreemptibleInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecPreemptibleInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPreemptibleInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecPreemptibleInstanceConfig)(ptr) = objs[0]
			} else {
				*(*InstanceSpecPreemptibleInstanceConfig)(ptr) = InstanceSpecPreemptibleInstanceConfig{}
			}
		} else {
			*(*InstanceSpecPreemptibleInstanceConfig)(ptr) = InstanceSpecPreemptibleInstanceConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecPreemptibleInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPreemptibleInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecPreemptibleInstanceConfig)(ptr) = obj
		} else {
			*(*InstanceSpecPreemptibleInstanceConfig)(ptr) = InstanceSpecPreemptibleInstanceConfig{}
		}
	default:
		iter.ReportError("decode InstanceSpecPreemptibleInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecPreemptibleInstanceConfigPreemptionActionCodec struct {
}

func (InstanceSpecPreemptibleInstanceConfigPreemptionActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecPreemptibleInstanceConfigPreemptionAction)(ptr) == nil
}

func (InstanceSpecPreemptibleInstanceConfigPreemptionActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecPreemptibleInstanceConfigPreemptionAction)(ptr)
	var objs []InstanceSpecPreemptibleInstanceConfigPreemptionAction
	if obj != nil {
		objs = []InstanceSpecPreemptibleInstanceConfigPreemptionAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPreemptibleInstanceConfigPreemptionAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecPreemptibleInstanceConfigPreemptionActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecPreemptibleInstanceConfigPreemptionAction)(ptr) = InstanceSpecPreemptibleInstanceConfigPreemptionAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecPreemptibleInstanceConfigPreemptionAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPreemptibleInstanceConfigPreemptionAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecPreemptibleInstanceConfigPreemptionAction)(ptr) = objs[0]
			} else {
				*(*InstanceSpecPreemptibleInstanceConfigPreemptionAction)(ptr) = InstanceSpecPreemptibleInstanceConfigPreemptionAction{}
			}
		} else {
			*(*InstanceSpecPreemptibleInstanceConfigPreemptionAction)(ptr) = InstanceSpecPreemptibleInstanceConfigPreemptionAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecPreemptibleInstanceConfigPreemptionAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPreemptibleInstanceConfigPreemptionAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecPreemptibleInstanceConfigPreemptionAction)(ptr) = obj
		} else {
			*(*InstanceSpecPreemptibleInstanceConfigPreemptionAction)(ptr) = InstanceSpecPreemptibleInstanceConfigPreemptionAction{}
		}
	default:
		iter.ReportError("decode InstanceSpecPreemptibleInstanceConfigPreemptionAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecShapeConfigCodec struct {
}

func (InstanceSpecShapeConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecShapeConfig)(ptr) == nil
}

func (InstanceSpecShapeConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecShapeConfig)(ptr)
	var objs []InstanceSpecShapeConfig
	if obj != nil {
		objs = []InstanceSpecShapeConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecShapeConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecShapeConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecShapeConfig)(ptr) = InstanceSpecShapeConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecShapeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecShapeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecShapeConfig)(ptr) = objs[0]
			} else {
				*(*InstanceSpecShapeConfig)(ptr) = InstanceSpecShapeConfig{}
			}
		} else {
			*(*InstanceSpecShapeConfig)(ptr) = InstanceSpecShapeConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecShapeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecShapeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecShapeConfig)(ptr) = obj
		} else {
			*(*InstanceSpecShapeConfig)(ptr) = InstanceSpecShapeConfig{}
		}
	default:
		iter.ReportError("decode InstanceSpecShapeConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecSourceDetailsCodec struct {
}

func (InstanceSpecSourceDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecSourceDetails)(ptr) == nil
}

func (InstanceSpecSourceDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecSourceDetails)(ptr)
	var objs []InstanceSpecSourceDetails
	if obj != nil {
		objs = []InstanceSpecSourceDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecSourceDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecSourceDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecSourceDetails)(ptr) = InstanceSpecSourceDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecSourceDetails)(ptr) = objs[0]
			} else {
				*(*InstanceSpecSourceDetails)(ptr) = InstanceSpecSourceDetails{}
			}
		} else {
			*(*InstanceSpecSourceDetails)(ptr) = InstanceSpecSourceDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecSourceDetails)(ptr) = obj
		} else {
			*(*InstanceSpecSourceDetails)(ptr) = InstanceSpecSourceDetails{}
		}
	default:
		iter.ReportError("decode InstanceSpecSourceDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceConfigurationSpecInstanceDetailsCodec struct {
}

func (InstanceConfigurationSpecInstanceDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceConfigurationSpecInstanceDetails)(ptr) == nil
}

func (InstanceConfigurationSpecInstanceDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceConfigurationSpecInstanceDetails)(ptr)
	var objs []InstanceConfigurationSpecInstanceDetails
	if obj != nil {
		objs = []InstanceConfigurationSpecInstanceDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceConfigurationSpecInstanceDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceConfigurationSpecInstanceDetails)(ptr) = InstanceConfigurationSpecInstanceDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceConfigurationSpecInstanceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceConfigurationSpecInstanceDetails)(ptr) = objs[0]
			} else {
				*(*InstanceConfigurationSpecInstanceDetails)(ptr) = InstanceConfigurationSpecInstanceDetails{}
			}
		} else {
			*(*InstanceConfigurationSpecInstanceDetails)(ptr) = InstanceConfigurationSpecInstanceDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceConfigurationSpecInstanceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceConfigurationSpecInstanceDetails)(ptr) = obj
		} else {
			*(*InstanceConfigurationSpecInstanceDetails)(ptr) = InstanceConfigurationSpecInstanceDetails{}
		}
	default:
		iter.ReportError("decode InstanceConfigurationSpecInstanceDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetailsCodec struct {
}

func (InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails)(ptr) == nil
}

func (InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails)(ptr)
	var objs []InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails
	if obj != nil {
		objs = []InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails)(ptr) = objs[0]
			} else {
				*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails{}
			}
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails)(ptr) = obj
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails{}
		}
	default:
		iter.ReportError("decode InstanceConfigurationSpecInstanceDetailsBlockVolumesAttachDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsCodec struct {
}

func (InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails)(ptr) == nil
}

func (InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails)(ptr)
	var objs []InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails
	if obj != nil {
		objs = []InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails)(ptr) = objs[0]
			} else {
				*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails{}
			}
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails)(ptr) = obj
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails{}
		}
	default:
		iter.ReportError("decode InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetailsCodec struct {
}

func (InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails)(ptr) == nil
}

func (InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails)(ptr)
	var objs []InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails
	if obj != nil {
		objs = []InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails)(ptr) = objs[0]
			} else {
				*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails{}
			}
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails)(ptr) = obj
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails{}
		}
	default:
		iter.ReportError("decode InstanceConfigurationSpecInstanceDetailsBlockVolumesCreateDetailsSourceDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceConfigurationSpecInstanceDetailsLaunchDetailsCodec struct {
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceConfigurationSpecInstanceDetailsLaunchDetails)(ptr) == nil
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceConfigurationSpecInstanceDetailsLaunchDetails)(ptr)
	var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetails
	if obj != nil {
		objs = []InstanceConfigurationSpecInstanceDetailsLaunchDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceConfigurationSpecInstanceDetailsLaunchDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetails)(ptr) = objs[0]
			} else {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetails{}
			}
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceConfigurationSpecInstanceDetailsLaunchDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetails)(ptr) = obj
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetails{}
		}
	default:
		iter.ReportError("decode InstanceConfigurationSpecInstanceDetailsLaunchDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfigCodec struct {
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig)(ptr) == nil
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig)(ptr)
	var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig
	if obj != nil {
		objs = []InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig)(ptr) = objs[0]
			} else {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig{}
			}
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig)(ptr) = obj
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig{}
		}
	default:
		iter.ReportError("decode InstanceConfigurationSpecInstanceDetailsLaunchDetailsAgentConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfigCodec struct {
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig)(ptr) == nil
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig)(ptr)
	var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig
	if obj != nil {
		objs = []InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig)(ptr) = objs[0]
			} else {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig{}
			}
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig)(ptr) = obj
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig{}
		}
	default:
		iter.ReportError("decode InstanceConfigurationSpecInstanceDetailsLaunchDetailsAvailabilityConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetailsCodec struct {
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails)(ptr) == nil
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails)(ptr)
	var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails
	if obj != nil {
		objs = []InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails)(ptr) = objs[0]
			} else {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails{}
			}
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails)(ptr) = obj
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails{}
		}
	default:
		iter.ReportError("decode InstanceConfigurationSpecInstanceDetailsLaunchDetailsCreateVnicDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptionsCodec struct {
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions)(ptr) == nil
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions)(ptr)
	var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions
	if obj != nil {
		objs = []InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions)(ptr) = objs[0]
			} else {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions{}
			}
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions)(ptr) = obj
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions{}
		}
	default:
		iter.ReportError("decode InstanceConfigurationSpecInstanceDetailsLaunchDetailsInstanceOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptionsCodec struct {
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions)(ptr) == nil
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions)(ptr)
	var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions
	if obj != nil {
		objs = []InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions)(ptr) = objs[0]
			} else {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions{}
			}
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions)(ptr) = obj
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions{}
		}
	default:
		iter.ReportError("decode InstanceConfigurationSpecInstanceDetailsLaunchDetailsLaunchOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfigCodec struct {
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig)(ptr) == nil
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig)(ptr)
	var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig
	if obj != nil {
		objs = []InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig)(ptr) = objs[0]
			} else {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig{}
			}
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig)(ptr) = obj
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig{}
		}
	default:
		iter.ReportError("decode InstanceConfigurationSpecInstanceDetailsLaunchDetailsPlatformConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigCodec struct {
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig)(ptr) == nil
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig)(ptr)
	var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig
	if obj != nil {
		objs = []InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig)(ptr) = objs[0]
			} else {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig{}
			}
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig)(ptr) = obj
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig{}
		}
	default:
		iter.ReportError("decode InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionCodec struct {
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction)(ptr) == nil
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction)(ptr)
	var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction
	if obj != nil {
		objs = []InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction)(ptr) = objs[0]
			} else {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction{}
			}
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction)(ptr) = obj
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction{}
		}
	default:
		iter.ReportError("decode InstanceConfigurationSpecInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfigCodec struct {
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig)(ptr) == nil
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig)(ptr)
	var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig
	if obj != nil {
		objs = []InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig)(ptr) = objs[0]
			} else {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig{}
			}
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig)(ptr) = obj
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig{}
		}
	default:
		iter.ReportError("decode InstanceConfigurationSpecInstanceDetailsLaunchDetailsShapeConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetailsCodec struct {
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails)(ptr) == nil
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails)(ptr)
	var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails
	if obj != nil {
		objs = []InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails)(ptr) = objs[0]
			} else {
				*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails{}
			}
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails)(ptr) = obj
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails{}
		}
	default:
		iter.ReportError("decode InstanceConfigurationSpecInstanceDetailsLaunchDetailsSourceDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetailsCodec struct {
}

func (InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails)(ptr) == nil
}

func (InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails)(ptr)
	var objs []InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails
	if obj != nil {
		objs = []InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails)(ptr) = objs[0]
			} else {
				*(*InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails{}
			}
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails)(ptr) = obj
		} else {
			*(*InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails)(ptr) = InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails{}
		}
	default:
		iter.ReportError("decode InstanceConfigurationSpecInstanceDetailsSecondaryVnicsCreateVnicDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type IpsecConnectionTunnelManagementSpecEncryptionDomainConfigCodec struct {
}

func (IpsecConnectionTunnelManagementSpecEncryptionDomainConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*IpsecConnectionTunnelManagementSpecEncryptionDomainConfig)(ptr) == nil
}

func (IpsecConnectionTunnelManagementSpecEncryptionDomainConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*IpsecConnectionTunnelManagementSpecEncryptionDomainConfig)(ptr)
	var objs []IpsecConnectionTunnelManagementSpecEncryptionDomainConfig
	if obj != nil {
		objs = []IpsecConnectionTunnelManagementSpecEncryptionDomainConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IpsecConnectionTunnelManagementSpecEncryptionDomainConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (IpsecConnectionTunnelManagementSpecEncryptionDomainConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*IpsecConnectionTunnelManagementSpecEncryptionDomainConfig)(ptr) = IpsecConnectionTunnelManagementSpecEncryptionDomainConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []IpsecConnectionTunnelManagementSpecEncryptionDomainConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IpsecConnectionTunnelManagementSpecEncryptionDomainConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*IpsecConnectionTunnelManagementSpecEncryptionDomainConfig)(ptr) = objs[0]
			} else {
				*(*IpsecConnectionTunnelManagementSpecEncryptionDomainConfig)(ptr) = IpsecConnectionTunnelManagementSpecEncryptionDomainConfig{}
			}
		} else {
			*(*IpsecConnectionTunnelManagementSpecEncryptionDomainConfig)(ptr) = IpsecConnectionTunnelManagementSpecEncryptionDomainConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj IpsecConnectionTunnelManagementSpecEncryptionDomainConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IpsecConnectionTunnelManagementSpecEncryptionDomainConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*IpsecConnectionTunnelManagementSpecEncryptionDomainConfig)(ptr) = obj
		} else {
			*(*IpsecConnectionTunnelManagementSpecEncryptionDomainConfig)(ptr) = IpsecConnectionTunnelManagementSpecEncryptionDomainConfig{}
		}
	default:
		iter.ReportError("decode IpsecConnectionTunnelManagementSpecEncryptionDomainConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkSecurityGroupSecurityRuleSpecIcmpOptionsCodec struct {
}

func (NetworkSecurityGroupSecurityRuleSpecIcmpOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkSecurityGroupSecurityRuleSpecIcmpOptions)(ptr) == nil
}

func (NetworkSecurityGroupSecurityRuleSpecIcmpOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkSecurityGroupSecurityRuleSpecIcmpOptions)(ptr)
	var objs []NetworkSecurityGroupSecurityRuleSpecIcmpOptions
	if obj != nil {
		objs = []NetworkSecurityGroupSecurityRuleSpecIcmpOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecIcmpOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkSecurityGroupSecurityRuleSpecIcmpOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkSecurityGroupSecurityRuleSpecIcmpOptions)(ptr) = NetworkSecurityGroupSecurityRuleSpecIcmpOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkSecurityGroupSecurityRuleSpecIcmpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecIcmpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkSecurityGroupSecurityRuleSpecIcmpOptions)(ptr) = objs[0]
			} else {
				*(*NetworkSecurityGroupSecurityRuleSpecIcmpOptions)(ptr) = NetworkSecurityGroupSecurityRuleSpecIcmpOptions{}
			}
		} else {
			*(*NetworkSecurityGroupSecurityRuleSpecIcmpOptions)(ptr) = NetworkSecurityGroupSecurityRuleSpecIcmpOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NetworkSecurityGroupSecurityRuleSpecIcmpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecIcmpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NetworkSecurityGroupSecurityRuleSpecIcmpOptions)(ptr) = obj
		} else {
			*(*NetworkSecurityGroupSecurityRuleSpecIcmpOptions)(ptr) = NetworkSecurityGroupSecurityRuleSpecIcmpOptions{}
		}
	default:
		iter.ReportError("decode NetworkSecurityGroupSecurityRuleSpecIcmpOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkSecurityGroupSecurityRuleSpecTcpOptionsCodec struct {
}

func (NetworkSecurityGroupSecurityRuleSpecTcpOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkSecurityGroupSecurityRuleSpecTcpOptions)(ptr) == nil
}

func (NetworkSecurityGroupSecurityRuleSpecTcpOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkSecurityGroupSecurityRuleSpecTcpOptions)(ptr)
	var objs []NetworkSecurityGroupSecurityRuleSpecTcpOptions
	if obj != nil {
		objs = []NetworkSecurityGroupSecurityRuleSpecTcpOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecTcpOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkSecurityGroupSecurityRuleSpecTcpOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkSecurityGroupSecurityRuleSpecTcpOptions)(ptr) = NetworkSecurityGroupSecurityRuleSpecTcpOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkSecurityGroupSecurityRuleSpecTcpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecTcpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkSecurityGroupSecurityRuleSpecTcpOptions)(ptr) = objs[0]
			} else {
				*(*NetworkSecurityGroupSecurityRuleSpecTcpOptions)(ptr) = NetworkSecurityGroupSecurityRuleSpecTcpOptions{}
			}
		} else {
			*(*NetworkSecurityGroupSecurityRuleSpecTcpOptions)(ptr) = NetworkSecurityGroupSecurityRuleSpecTcpOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NetworkSecurityGroupSecurityRuleSpecTcpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecTcpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NetworkSecurityGroupSecurityRuleSpecTcpOptions)(ptr) = obj
		} else {
			*(*NetworkSecurityGroupSecurityRuleSpecTcpOptions)(ptr) = NetworkSecurityGroupSecurityRuleSpecTcpOptions{}
		}
	default:
		iter.ReportError("decode NetworkSecurityGroupSecurityRuleSpecTcpOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRangeCodec struct {
}

func (NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange)(ptr) == nil
}

func (NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange)(ptr)
	var objs []NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange
	if obj != nil {
		objs = []NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange)(ptr) = NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange)(ptr) = objs[0]
			} else {
				*(*NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange)(ptr) = NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange{}
			}
		} else {
			*(*NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange)(ptr) = NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange)(ptr) = obj
		} else {
			*(*NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange)(ptr) = NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange{}
		}
	default:
		iter.ReportError("decode NetworkSecurityGroupSecurityRuleSpecTcpOptionsDestinationPortRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRangeCodec struct {
}

func (NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange)(ptr) == nil
}

func (NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange)(ptr)
	var objs []NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange
	if obj != nil {
		objs = []NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange)(ptr) = NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange)(ptr) = objs[0]
			} else {
				*(*NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange)(ptr) = NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange{}
			}
		} else {
			*(*NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange)(ptr) = NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange)(ptr) = obj
		} else {
			*(*NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange)(ptr) = NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange{}
		}
	default:
		iter.ReportError("decode NetworkSecurityGroupSecurityRuleSpecTcpOptionsSourcePortRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkSecurityGroupSecurityRuleSpecUdpOptionsCodec struct {
}

func (NetworkSecurityGroupSecurityRuleSpecUdpOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkSecurityGroupSecurityRuleSpecUdpOptions)(ptr) == nil
}

func (NetworkSecurityGroupSecurityRuleSpecUdpOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkSecurityGroupSecurityRuleSpecUdpOptions)(ptr)
	var objs []NetworkSecurityGroupSecurityRuleSpecUdpOptions
	if obj != nil {
		objs = []NetworkSecurityGroupSecurityRuleSpecUdpOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecUdpOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkSecurityGroupSecurityRuleSpecUdpOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkSecurityGroupSecurityRuleSpecUdpOptions)(ptr) = NetworkSecurityGroupSecurityRuleSpecUdpOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkSecurityGroupSecurityRuleSpecUdpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecUdpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkSecurityGroupSecurityRuleSpecUdpOptions)(ptr) = objs[0]
			} else {
				*(*NetworkSecurityGroupSecurityRuleSpecUdpOptions)(ptr) = NetworkSecurityGroupSecurityRuleSpecUdpOptions{}
			}
		} else {
			*(*NetworkSecurityGroupSecurityRuleSpecUdpOptions)(ptr) = NetworkSecurityGroupSecurityRuleSpecUdpOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NetworkSecurityGroupSecurityRuleSpecUdpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecUdpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NetworkSecurityGroupSecurityRuleSpecUdpOptions)(ptr) = obj
		} else {
			*(*NetworkSecurityGroupSecurityRuleSpecUdpOptions)(ptr) = NetworkSecurityGroupSecurityRuleSpecUdpOptions{}
		}
	default:
		iter.ReportError("decode NetworkSecurityGroupSecurityRuleSpecUdpOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRangeCodec struct {
}

func (NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange)(ptr) == nil
}

func (NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange)(ptr)
	var objs []NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange
	if obj != nil {
		objs = []NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange)(ptr) = NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange)(ptr) = objs[0]
			} else {
				*(*NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange)(ptr) = NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange{}
			}
		} else {
			*(*NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange)(ptr) = NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange)(ptr) = obj
		} else {
			*(*NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange)(ptr) = NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange{}
		}
	default:
		iter.ReportError("decode NetworkSecurityGroupSecurityRuleSpecUdpOptionsDestinationPortRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRangeCodec struct {
}

func (NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange)(ptr) == nil
}

func (NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange)(ptr)
	var objs []NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange
	if obj != nil {
		objs = []NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange)(ptr) = NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange)(ptr) = objs[0]
			} else {
				*(*NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange)(ptr) = NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange{}
			}
		} else {
			*(*NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange)(ptr) = NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange)(ptr) = obj
		} else {
			*(*NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange)(ptr) = NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange{}
		}
	default:
		iter.ReportError("decode NetworkSecurityGroupSecurityRuleSpecUdpOptionsSourcePortRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityListSpecEgressSecurityRulesIcmpOptionsCodec struct {
}

func (SecurityListSpecEgressSecurityRulesIcmpOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityListSpecEgressSecurityRulesIcmpOptions)(ptr) == nil
}

func (SecurityListSpecEgressSecurityRulesIcmpOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityListSpecEgressSecurityRulesIcmpOptions)(ptr)
	var objs []SecurityListSpecEgressSecurityRulesIcmpOptions
	if obj != nil {
		objs = []SecurityListSpecEgressSecurityRulesIcmpOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesIcmpOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityListSpecEgressSecurityRulesIcmpOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityListSpecEgressSecurityRulesIcmpOptions)(ptr) = SecurityListSpecEgressSecurityRulesIcmpOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityListSpecEgressSecurityRulesIcmpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesIcmpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityListSpecEgressSecurityRulesIcmpOptions)(ptr) = objs[0]
			} else {
				*(*SecurityListSpecEgressSecurityRulesIcmpOptions)(ptr) = SecurityListSpecEgressSecurityRulesIcmpOptions{}
			}
		} else {
			*(*SecurityListSpecEgressSecurityRulesIcmpOptions)(ptr) = SecurityListSpecEgressSecurityRulesIcmpOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SecurityListSpecEgressSecurityRulesIcmpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesIcmpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SecurityListSpecEgressSecurityRulesIcmpOptions)(ptr) = obj
		} else {
			*(*SecurityListSpecEgressSecurityRulesIcmpOptions)(ptr) = SecurityListSpecEgressSecurityRulesIcmpOptions{}
		}
	default:
		iter.ReportError("decode SecurityListSpecEgressSecurityRulesIcmpOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityListSpecEgressSecurityRulesTcpOptionsCodec struct {
}

func (SecurityListSpecEgressSecurityRulesTcpOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityListSpecEgressSecurityRulesTcpOptions)(ptr) == nil
}

func (SecurityListSpecEgressSecurityRulesTcpOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityListSpecEgressSecurityRulesTcpOptions)(ptr)
	var objs []SecurityListSpecEgressSecurityRulesTcpOptions
	if obj != nil {
		objs = []SecurityListSpecEgressSecurityRulesTcpOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesTcpOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityListSpecEgressSecurityRulesTcpOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityListSpecEgressSecurityRulesTcpOptions)(ptr) = SecurityListSpecEgressSecurityRulesTcpOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityListSpecEgressSecurityRulesTcpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesTcpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityListSpecEgressSecurityRulesTcpOptions)(ptr) = objs[0]
			} else {
				*(*SecurityListSpecEgressSecurityRulesTcpOptions)(ptr) = SecurityListSpecEgressSecurityRulesTcpOptions{}
			}
		} else {
			*(*SecurityListSpecEgressSecurityRulesTcpOptions)(ptr) = SecurityListSpecEgressSecurityRulesTcpOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SecurityListSpecEgressSecurityRulesTcpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesTcpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SecurityListSpecEgressSecurityRulesTcpOptions)(ptr) = obj
		} else {
			*(*SecurityListSpecEgressSecurityRulesTcpOptions)(ptr) = SecurityListSpecEgressSecurityRulesTcpOptions{}
		}
	default:
		iter.ReportError("decode SecurityListSpecEgressSecurityRulesTcpOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRangeCodec struct {
}

func (SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange)(ptr) == nil
}

func (SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange)(ptr)
	var objs []SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange
	if obj != nil {
		objs = []SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange)(ptr) = SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange)(ptr) = objs[0]
			} else {
				*(*SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange)(ptr) = SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}
			}
		} else {
			*(*SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange)(ptr) = SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange)(ptr) = obj
		} else {
			*(*SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange)(ptr) = SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange{}
		}
	default:
		iter.ReportError("decode SecurityListSpecEgressSecurityRulesTcpOptionsSourcePortRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityListSpecEgressSecurityRulesUdpOptionsCodec struct {
}

func (SecurityListSpecEgressSecurityRulesUdpOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityListSpecEgressSecurityRulesUdpOptions)(ptr) == nil
}

func (SecurityListSpecEgressSecurityRulesUdpOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityListSpecEgressSecurityRulesUdpOptions)(ptr)
	var objs []SecurityListSpecEgressSecurityRulesUdpOptions
	if obj != nil {
		objs = []SecurityListSpecEgressSecurityRulesUdpOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesUdpOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityListSpecEgressSecurityRulesUdpOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityListSpecEgressSecurityRulesUdpOptions)(ptr) = SecurityListSpecEgressSecurityRulesUdpOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityListSpecEgressSecurityRulesUdpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesUdpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityListSpecEgressSecurityRulesUdpOptions)(ptr) = objs[0]
			} else {
				*(*SecurityListSpecEgressSecurityRulesUdpOptions)(ptr) = SecurityListSpecEgressSecurityRulesUdpOptions{}
			}
		} else {
			*(*SecurityListSpecEgressSecurityRulesUdpOptions)(ptr) = SecurityListSpecEgressSecurityRulesUdpOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SecurityListSpecEgressSecurityRulesUdpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesUdpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SecurityListSpecEgressSecurityRulesUdpOptions)(ptr) = obj
		} else {
			*(*SecurityListSpecEgressSecurityRulesUdpOptions)(ptr) = SecurityListSpecEgressSecurityRulesUdpOptions{}
		}
	default:
		iter.ReportError("decode SecurityListSpecEgressSecurityRulesUdpOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRangeCodec struct {
}

func (SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange)(ptr) == nil
}

func (SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange)(ptr)
	var objs []SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange
	if obj != nil {
		objs = []SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange)(ptr) = SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange)(ptr) = objs[0]
			} else {
				*(*SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange)(ptr) = SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}
			}
		} else {
			*(*SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange)(ptr) = SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange)(ptr) = obj
		} else {
			*(*SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange)(ptr) = SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange{}
		}
	default:
		iter.ReportError("decode SecurityListSpecEgressSecurityRulesUdpOptionsSourcePortRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityListSpecIngressSecurityRulesIcmpOptionsCodec struct {
}

func (SecurityListSpecIngressSecurityRulesIcmpOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityListSpecIngressSecurityRulesIcmpOptions)(ptr) == nil
}

func (SecurityListSpecIngressSecurityRulesIcmpOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityListSpecIngressSecurityRulesIcmpOptions)(ptr)
	var objs []SecurityListSpecIngressSecurityRulesIcmpOptions
	if obj != nil {
		objs = []SecurityListSpecIngressSecurityRulesIcmpOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesIcmpOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityListSpecIngressSecurityRulesIcmpOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityListSpecIngressSecurityRulesIcmpOptions)(ptr) = SecurityListSpecIngressSecurityRulesIcmpOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityListSpecIngressSecurityRulesIcmpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesIcmpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityListSpecIngressSecurityRulesIcmpOptions)(ptr) = objs[0]
			} else {
				*(*SecurityListSpecIngressSecurityRulesIcmpOptions)(ptr) = SecurityListSpecIngressSecurityRulesIcmpOptions{}
			}
		} else {
			*(*SecurityListSpecIngressSecurityRulesIcmpOptions)(ptr) = SecurityListSpecIngressSecurityRulesIcmpOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SecurityListSpecIngressSecurityRulesIcmpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesIcmpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SecurityListSpecIngressSecurityRulesIcmpOptions)(ptr) = obj
		} else {
			*(*SecurityListSpecIngressSecurityRulesIcmpOptions)(ptr) = SecurityListSpecIngressSecurityRulesIcmpOptions{}
		}
	default:
		iter.ReportError("decode SecurityListSpecIngressSecurityRulesIcmpOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityListSpecIngressSecurityRulesTcpOptionsCodec struct {
}

func (SecurityListSpecIngressSecurityRulesTcpOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityListSpecIngressSecurityRulesTcpOptions)(ptr) == nil
}

func (SecurityListSpecIngressSecurityRulesTcpOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityListSpecIngressSecurityRulesTcpOptions)(ptr)
	var objs []SecurityListSpecIngressSecurityRulesTcpOptions
	if obj != nil {
		objs = []SecurityListSpecIngressSecurityRulesTcpOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesTcpOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityListSpecIngressSecurityRulesTcpOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityListSpecIngressSecurityRulesTcpOptions)(ptr) = SecurityListSpecIngressSecurityRulesTcpOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityListSpecIngressSecurityRulesTcpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesTcpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityListSpecIngressSecurityRulesTcpOptions)(ptr) = objs[0]
			} else {
				*(*SecurityListSpecIngressSecurityRulesTcpOptions)(ptr) = SecurityListSpecIngressSecurityRulesTcpOptions{}
			}
		} else {
			*(*SecurityListSpecIngressSecurityRulesTcpOptions)(ptr) = SecurityListSpecIngressSecurityRulesTcpOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SecurityListSpecIngressSecurityRulesTcpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesTcpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SecurityListSpecIngressSecurityRulesTcpOptions)(ptr) = obj
		} else {
			*(*SecurityListSpecIngressSecurityRulesTcpOptions)(ptr) = SecurityListSpecIngressSecurityRulesTcpOptions{}
		}
	default:
		iter.ReportError("decode SecurityListSpecIngressSecurityRulesTcpOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRangeCodec struct {
}

func (SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange)(ptr) == nil
}

func (SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange)(ptr)
	var objs []SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange
	if obj != nil {
		objs = []SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange)(ptr) = SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange)(ptr) = objs[0]
			} else {
				*(*SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange)(ptr) = SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}
			}
		} else {
			*(*SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange)(ptr) = SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange)(ptr) = obj
		} else {
			*(*SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange)(ptr) = SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange{}
		}
	default:
		iter.ReportError("decode SecurityListSpecIngressSecurityRulesTcpOptionsSourcePortRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityListSpecIngressSecurityRulesUdpOptionsCodec struct {
}

func (SecurityListSpecIngressSecurityRulesUdpOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityListSpecIngressSecurityRulesUdpOptions)(ptr) == nil
}

func (SecurityListSpecIngressSecurityRulesUdpOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityListSpecIngressSecurityRulesUdpOptions)(ptr)
	var objs []SecurityListSpecIngressSecurityRulesUdpOptions
	if obj != nil {
		objs = []SecurityListSpecIngressSecurityRulesUdpOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesUdpOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityListSpecIngressSecurityRulesUdpOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityListSpecIngressSecurityRulesUdpOptions)(ptr) = SecurityListSpecIngressSecurityRulesUdpOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityListSpecIngressSecurityRulesUdpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesUdpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityListSpecIngressSecurityRulesUdpOptions)(ptr) = objs[0]
			} else {
				*(*SecurityListSpecIngressSecurityRulesUdpOptions)(ptr) = SecurityListSpecIngressSecurityRulesUdpOptions{}
			}
		} else {
			*(*SecurityListSpecIngressSecurityRulesUdpOptions)(ptr) = SecurityListSpecIngressSecurityRulesUdpOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SecurityListSpecIngressSecurityRulesUdpOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesUdpOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SecurityListSpecIngressSecurityRulesUdpOptions)(ptr) = obj
		} else {
			*(*SecurityListSpecIngressSecurityRulesUdpOptions)(ptr) = SecurityListSpecIngressSecurityRulesUdpOptions{}
		}
	default:
		iter.ReportError("decode SecurityListSpecIngressSecurityRulesUdpOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRangeCodec struct {
}

func (SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange)(ptr) == nil
}

func (SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange)(ptr)
	var objs []SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange
	if obj != nil {
		objs = []SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange)(ptr) = SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange)(ptr) = objs[0]
			} else {
				*(*SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange)(ptr) = SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}
			}
		} else {
			*(*SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange)(ptr) = SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange)(ptr) = obj
		} else {
			*(*SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange)(ptr) = SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange{}
		}
	default:
		iter.ReportError("decode SecurityListSpecIngressSecurityRulesUdpOptionsSourcePortRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VnicAttachmentSpecCreateVnicDetailsCodec struct {
}

func (VnicAttachmentSpecCreateVnicDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VnicAttachmentSpecCreateVnicDetails)(ptr) == nil
}

func (VnicAttachmentSpecCreateVnicDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VnicAttachmentSpecCreateVnicDetails)(ptr)
	var objs []VnicAttachmentSpecCreateVnicDetails
	if obj != nil {
		objs = []VnicAttachmentSpecCreateVnicDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VnicAttachmentSpecCreateVnicDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VnicAttachmentSpecCreateVnicDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VnicAttachmentSpecCreateVnicDetails)(ptr) = VnicAttachmentSpecCreateVnicDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VnicAttachmentSpecCreateVnicDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VnicAttachmentSpecCreateVnicDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VnicAttachmentSpecCreateVnicDetails)(ptr) = objs[0]
			} else {
				*(*VnicAttachmentSpecCreateVnicDetails)(ptr) = VnicAttachmentSpecCreateVnicDetails{}
			}
		} else {
			*(*VnicAttachmentSpecCreateVnicDetails)(ptr) = VnicAttachmentSpecCreateVnicDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj VnicAttachmentSpecCreateVnicDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VnicAttachmentSpecCreateVnicDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*VnicAttachmentSpecCreateVnicDetails)(ptr) = obj
		} else {
			*(*VnicAttachmentSpecCreateVnicDetails)(ptr) = VnicAttachmentSpecCreateVnicDetails{}
		}
	default:
		iter.ReportError("decode VnicAttachmentSpecCreateVnicDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VolumeSpecSourceDetailsCodec struct {
}

func (VolumeSpecSourceDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VolumeSpecSourceDetails)(ptr) == nil
}

func (VolumeSpecSourceDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VolumeSpecSourceDetails)(ptr)
	var objs []VolumeSpecSourceDetails
	if obj != nil {
		objs = []VolumeSpecSourceDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VolumeSpecSourceDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VolumeSpecSourceDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VolumeSpecSourceDetails)(ptr) = VolumeSpecSourceDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VolumeSpecSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VolumeSpecSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VolumeSpecSourceDetails)(ptr) = objs[0]
			} else {
				*(*VolumeSpecSourceDetails)(ptr) = VolumeSpecSourceDetails{}
			}
		} else {
			*(*VolumeSpecSourceDetails)(ptr) = VolumeSpecSourceDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj VolumeSpecSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VolumeSpecSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*VolumeSpecSourceDetails)(ptr) = obj
		} else {
			*(*VolumeSpecSourceDetails)(ptr) = VolumeSpecSourceDetails{}
		}
	default:
		iter.ReportError("decode VolumeSpecSourceDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VolumeBackupSpecSourceDetailsCodec struct {
}

func (VolumeBackupSpecSourceDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VolumeBackupSpecSourceDetails)(ptr) == nil
}

func (VolumeBackupSpecSourceDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VolumeBackupSpecSourceDetails)(ptr)
	var objs []VolumeBackupSpecSourceDetails
	if obj != nil {
		objs = []VolumeBackupSpecSourceDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VolumeBackupSpecSourceDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VolumeBackupSpecSourceDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VolumeBackupSpecSourceDetails)(ptr) = VolumeBackupSpecSourceDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VolumeBackupSpecSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VolumeBackupSpecSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VolumeBackupSpecSourceDetails)(ptr) = objs[0]
			} else {
				*(*VolumeBackupSpecSourceDetails)(ptr) = VolumeBackupSpecSourceDetails{}
			}
		} else {
			*(*VolumeBackupSpecSourceDetails)(ptr) = VolumeBackupSpecSourceDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj VolumeBackupSpecSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VolumeBackupSpecSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*VolumeBackupSpecSourceDetails)(ptr) = obj
		} else {
			*(*VolumeBackupSpecSourceDetails)(ptr) = VolumeBackupSpecSourceDetails{}
		}
	default:
		iter.ReportError("decode VolumeBackupSpecSourceDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VolumeGroupSpecSourceDetailsCodec struct {
}

func (VolumeGroupSpecSourceDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VolumeGroupSpecSourceDetails)(ptr) == nil
}

func (VolumeGroupSpecSourceDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VolumeGroupSpecSourceDetails)(ptr)
	var objs []VolumeGroupSpecSourceDetails
	if obj != nil {
		objs = []VolumeGroupSpecSourceDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VolumeGroupSpecSourceDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VolumeGroupSpecSourceDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VolumeGroupSpecSourceDetails)(ptr) = VolumeGroupSpecSourceDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VolumeGroupSpecSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VolumeGroupSpecSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VolumeGroupSpecSourceDetails)(ptr) = objs[0]
			} else {
				*(*VolumeGroupSpecSourceDetails)(ptr) = VolumeGroupSpecSourceDetails{}
			}
		} else {
			*(*VolumeGroupSpecSourceDetails)(ptr) = VolumeGroupSpecSourceDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj VolumeGroupSpecSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VolumeGroupSpecSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*VolumeGroupSpecSourceDetails)(ptr) = obj
		} else {
			*(*VolumeGroupSpecSourceDetails)(ptr) = VolumeGroupSpecSourceDetails{}
		}
	default:
		iter.ReportError("decode VolumeGroupSpecSourceDetails", "unexpected JSON type")
	}
}
