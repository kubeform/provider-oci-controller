/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecMetadata{}).Type1()):                                               ConnectivityRegistryConnectionSpecMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecMetadataAggregator{}).Type1()):                                     ConnectivityRegistryConnectionSpecMetadataAggregatorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchema{}).Type1()):                                          ConnectivityRegistryConnectionSpecPrimarySchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchemaMetadata{}).Type1()):                                  ConnectivityRegistryConnectionSpecPrimarySchemaMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator{}).Type1()):                        ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregatorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchemaParentRef{}).Type1()):                                 ConnectivityRegistryConnectionSpecPrimarySchemaParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecRegistryMetadata{}).Type1()):                                       ConnectivityRegistryConnectionSpecRegistryMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnection{}).Type1()):                                       ConnectivityRegistryDataAssetSpecDefaultConnectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata{}).Type1()):                               ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator{}).Type1()):                     ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregatorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema{}).Type1()):                          ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata{}).Type1()):                  ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator{}).Type1()):        ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregatorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef{}).Type1()):                 ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata{}).Type1()):                       ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecMetadata{}).Type1()):                                                ConnectivityRegistryDataAssetSpecMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecMetadataAggregator{}).Type1()):                                      ConnectivityRegistryDataAssetSpecMetadataAggregatorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystem{}).Type1()):                                        ConnectivityRegistryDataAssetSpecNativeTypeSystemCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef{}).Type1()):                               ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition{}).Type1()):                   ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef{}).Type1()):          ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef{}).Type1()):                          ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecRegistryMetadata{}).Type1()):                                        ConnectivityRegistryDataAssetSpecRegistryMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnection{}).Type1()):                                ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata{}).Type1()):                        ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator{}).Type1()):              ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregatorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema{}).Type1()):                   ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata{}).Type1()):           ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator{}).Type1()): ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregatorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef{}).Type1()):          ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata{}).Type1()):                ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsMetadata{}).Type1()):                                         ConnectivityRegistryFolderSpecDataAssetsMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator{}).Type1()):                               ConnectivityRegistryFolderSpecDataAssetsMetadataAggregatorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem{}).Type1()):                                 ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef{}).Type1()):                        ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition{}).Type1()):            ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef{}).Type1()):   ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef{}).Type1()):                   ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata{}).Type1()):                                 ConnectivityRegistryFolderSpecDataAssetsRegistryMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecParentRef{}).Type1()):                                                  ConnectivityRegistryFolderSpecParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecDatasetFormatDetails{}).Type1()):                                           LabelingServiceDatasetSpecDatasetFormatDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecDatasetSourceDetails{}).Type1()):                                           LabelingServiceDatasetSpecDatasetSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecInitialRecordGenerationConfiguration{}).Type1()):                           LabelingServiceDatasetSpecInitialRecordGenerationConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecLabelSet{}).Type1()):                                                       LabelingServiceDatasetSpecLabelSetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatistics{}).Type1()):                                                     SafeSecurityAssessmentSpecStatisticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsAdvisory{}).Type1()):                                             SafeSecurityAssessmentSpecStatisticsAdvisoryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsEvaluate{}).Type1()):                                             SafeSecurityAssessmentSpecStatisticsEvaluateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsHighRisk{}).Type1()):                                             SafeSecurityAssessmentSpecStatisticsHighRiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsLowRisk{}).Type1()):                                              SafeSecurityAssessmentSpecStatisticsLowRiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsMediumRisk{}).Type1()):                                           SafeSecurityAssessmentSpecStatisticsMediumRiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsPass{}).Type1()):                                                 SafeSecurityAssessmentSpecStatisticsPassCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecConnectionOption{}).Type1()):                                                   SafeTargetDatabaseSpecConnectionOptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecCredentials{}).Type1()):                                                        SafeTargetDatabaseSpecCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecDatabaseDetails{}).Type1()):                                                    SafeTargetDatabaseSpecDatabaseDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecTlsConfig{}).Type1()):                                                          SafeTargetDatabaseSpecTlsConfigCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecMetadata{}).Type1()):                                               ConnectivityRegistryConnectionSpecMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecMetadataAggregator{}).Type1()):                                     ConnectivityRegistryConnectionSpecMetadataAggregatorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchema{}).Type1()):                                          ConnectivityRegistryConnectionSpecPrimarySchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchemaMetadata{}).Type1()):                                  ConnectivityRegistryConnectionSpecPrimarySchemaMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator{}).Type1()):                        ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregatorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchemaParentRef{}).Type1()):                                 ConnectivityRegistryConnectionSpecPrimarySchemaParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecRegistryMetadata{}).Type1()):                                       ConnectivityRegistryConnectionSpecRegistryMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnection{}).Type1()):                                       ConnectivityRegistryDataAssetSpecDefaultConnectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata{}).Type1()):                               ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator{}).Type1()):                     ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregatorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema{}).Type1()):                          ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata{}).Type1()):                  ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator{}).Type1()):        ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregatorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef{}).Type1()):                 ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata{}).Type1()):                       ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecMetadata{}).Type1()):                                                ConnectivityRegistryDataAssetSpecMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecMetadataAggregator{}).Type1()):                                      ConnectivityRegistryDataAssetSpecMetadataAggregatorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystem{}).Type1()):                                        ConnectivityRegistryDataAssetSpecNativeTypeSystemCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef{}).Type1()):                               ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition{}).Type1()):                   ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef{}).Type1()):          ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef{}).Type1()):                          ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecRegistryMetadata{}).Type1()):                                        ConnectivityRegistryDataAssetSpecRegistryMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnection{}).Type1()):                                ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata{}).Type1()):                        ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator{}).Type1()):              ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregatorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema{}).Type1()):                   ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata{}).Type1()):           ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator{}).Type1()): ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregatorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef{}).Type1()):          ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata{}).Type1()):                ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsMetadata{}).Type1()):                                         ConnectivityRegistryFolderSpecDataAssetsMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator{}).Type1()):                               ConnectivityRegistryFolderSpecDataAssetsMetadataAggregatorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem{}).Type1()):                                 ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef{}).Type1()):                        ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition{}).Type1()):            ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef{}).Type1()):   ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef{}).Type1()):                   ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata{}).Type1()):                                 ConnectivityRegistryFolderSpecDataAssetsRegistryMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecParentRef{}).Type1()):                                                  ConnectivityRegistryFolderSpecParentRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecDatasetFormatDetails{}).Type1()):                                           LabelingServiceDatasetSpecDatasetFormatDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecDatasetSourceDetails{}).Type1()):                                           LabelingServiceDatasetSpecDatasetSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecInitialRecordGenerationConfiguration{}).Type1()):                           LabelingServiceDatasetSpecInitialRecordGenerationConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecLabelSet{}).Type1()):                                                       LabelingServiceDatasetSpecLabelSetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatistics{}).Type1()):                                                     SafeSecurityAssessmentSpecStatisticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsAdvisory{}).Type1()):                                             SafeSecurityAssessmentSpecStatisticsAdvisoryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsEvaluate{}).Type1()):                                             SafeSecurityAssessmentSpecStatisticsEvaluateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsHighRisk{}).Type1()):                                             SafeSecurityAssessmentSpecStatisticsHighRiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsLowRisk{}).Type1()):                                              SafeSecurityAssessmentSpecStatisticsLowRiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsMediumRisk{}).Type1()):                                           SafeSecurityAssessmentSpecStatisticsMediumRiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsPass{}).Type1()):                                                 SafeSecurityAssessmentSpecStatisticsPassCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecConnectionOption{}).Type1()):                                                   SafeTargetDatabaseSpecConnectionOptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecCredentials{}).Type1()):                                                        SafeTargetDatabaseSpecCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecDatabaseDetails{}).Type1()):                                                    SafeTargetDatabaseSpecDatabaseDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecTlsConfig{}).Type1()):                                                          SafeTargetDatabaseSpecTlsConfigCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryConnectionSpecMetadataCodec struct {
}

func (ConnectivityRegistryConnectionSpecMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryConnectionSpecMetadata)(ptr) == nil
}

func (ConnectivityRegistryConnectionSpecMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryConnectionSpecMetadata)(ptr)
	var objs []ConnectivityRegistryConnectionSpecMetadata
	if obj != nil {
		objs = []ConnectivityRegistryConnectionSpecMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryConnectionSpecMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryConnectionSpecMetadata)(ptr) = ConnectivityRegistryConnectionSpecMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryConnectionSpecMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryConnectionSpecMetadata)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryConnectionSpecMetadata)(ptr) = ConnectivityRegistryConnectionSpecMetadata{}
			}
		} else {
			*(*ConnectivityRegistryConnectionSpecMetadata)(ptr) = ConnectivityRegistryConnectionSpecMetadata{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryConnectionSpecMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryConnectionSpecMetadata)(ptr) = obj
		} else {
			*(*ConnectivityRegistryConnectionSpecMetadata)(ptr) = ConnectivityRegistryConnectionSpecMetadata{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryConnectionSpecMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryConnectionSpecMetadataAggregatorCodec struct {
}

func (ConnectivityRegistryConnectionSpecMetadataAggregatorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryConnectionSpecMetadataAggregator)(ptr) == nil
}

func (ConnectivityRegistryConnectionSpecMetadataAggregatorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryConnectionSpecMetadataAggregator)(ptr)
	var objs []ConnectivityRegistryConnectionSpecMetadataAggregator
	if obj != nil {
		objs = []ConnectivityRegistryConnectionSpecMetadataAggregator{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecMetadataAggregator{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryConnectionSpecMetadataAggregatorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryConnectionSpecMetadataAggregator)(ptr) = ConnectivityRegistryConnectionSpecMetadataAggregator{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryConnectionSpecMetadataAggregator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecMetadataAggregator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryConnectionSpecMetadataAggregator)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryConnectionSpecMetadataAggregator)(ptr) = ConnectivityRegistryConnectionSpecMetadataAggregator{}
			}
		} else {
			*(*ConnectivityRegistryConnectionSpecMetadataAggregator)(ptr) = ConnectivityRegistryConnectionSpecMetadataAggregator{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryConnectionSpecMetadataAggregator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecMetadataAggregator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryConnectionSpecMetadataAggregator)(ptr) = obj
		} else {
			*(*ConnectivityRegistryConnectionSpecMetadataAggregator)(ptr) = ConnectivityRegistryConnectionSpecMetadataAggregator{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryConnectionSpecMetadataAggregator", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryConnectionSpecPrimarySchemaCodec struct {
}

func (ConnectivityRegistryConnectionSpecPrimarySchemaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryConnectionSpecPrimarySchema)(ptr) == nil
}

func (ConnectivityRegistryConnectionSpecPrimarySchemaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryConnectionSpecPrimarySchema)(ptr)
	var objs []ConnectivityRegistryConnectionSpecPrimarySchema
	if obj != nil {
		objs = []ConnectivityRegistryConnectionSpecPrimarySchema{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchema{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryConnectionSpecPrimarySchemaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryConnectionSpecPrimarySchema)(ptr) = ConnectivityRegistryConnectionSpecPrimarySchema{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryConnectionSpecPrimarySchema

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchema{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryConnectionSpecPrimarySchema)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryConnectionSpecPrimarySchema)(ptr) = ConnectivityRegistryConnectionSpecPrimarySchema{}
			}
		} else {
			*(*ConnectivityRegistryConnectionSpecPrimarySchema)(ptr) = ConnectivityRegistryConnectionSpecPrimarySchema{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryConnectionSpecPrimarySchema

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchema{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryConnectionSpecPrimarySchema)(ptr) = obj
		} else {
			*(*ConnectivityRegistryConnectionSpecPrimarySchema)(ptr) = ConnectivityRegistryConnectionSpecPrimarySchema{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryConnectionSpecPrimarySchema", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryConnectionSpecPrimarySchemaMetadataCodec struct {
}

func (ConnectivityRegistryConnectionSpecPrimarySchemaMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryConnectionSpecPrimarySchemaMetadata)(ptr) == nil
}

func (ConnectivityRegistryConnectionSpecPrimarySchemaMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryConnectionSpecPrimarySchemaMetadata)(ptr)
	var objs []ConnectivityRegistryConnectionSpecPrimarySchemaMetadata
	if obj != nil {
		objs = []ConnectivityRegistryConnectionSpecPrimarySchemaMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchemaMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryConnectionSpecPrimarySchemaMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryConnectionSpecPrimarySchemaMetadata)(ptr) = ConnectivityRegistryConnectionSpecPrimarySchemaMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryConnectionSpecPrimarySchemaMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchemaMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryConnectionSpecPrimarySchemaMetadata)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryConnectionSpecPrimarySchemaMetadata)(ptr) = ConnectivityRegistryConnectionSpecPrimarySchemaMetadata{}
			}
		} else {
			*(*ConnectivityRegistryConnectionSpecPrimarySchemaMetadata)(ptr) = ConnectivityRegistryConnectionSpecPrimarySchemaMetadata{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryConnectionSpecPrimarySchemaMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchemaMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryConnectionSpecPrimarySchemaMetadata)(ptr) = obj
		} else {
			*(*ConnectivityRegistryConnectionSpecPrimarySchemaMetadata)(ptr) = ConnectivityRegistryConnectionSpecPrimarySchemaMetadata{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryConnectionSpecPrimarySchemaMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregatorCodec struct {
}

func (ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregatorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator)(ptr) == nil
}

func (ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregatorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator)(ptr)
	var objs []ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator
	if obj != nil {
		objs = []ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregatorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator)(ptr) = ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator)(ptr) = ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator{}
			}
		} else {
			*(*ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator)(ptr) = ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator)(ptr) = obj
		} else {
			*(*ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator)(ptr) = ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryConnectionSpecPrimarySchemaMetadataAggregator", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryConnectionSpecPrimarySchemaParentRefCodec struct {
}

func (ConnectivityRegistryConnectionSpecPrimarySchemaParentRefCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryConnectionSpecPrimarySchemaParentRef)(ptr) == nil
}

func (ConnectivityRegistryConnectionSpecPrimarySchemaParentRefCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryConnectionSpecPrimarySchemaParentRef)(ptr)
	var objs []ConnectivityRegistryConnectionSpecPrimarySchemaParentRef
	if obj != nil {
		objs = []ConnectivityRegistryConnectionSpecPrimarySchemaParentRef{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchemaParentRef{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryConnectionSpecPrimarySchemaParentRefCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryConnectionSpecPrimarySchemaParentRef)(ptr) = ConnectivityRegistryConnectionSpecPrimarySchemaParentRef{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryConnectionSpecPrimarySchemaParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchemaParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryConnectionSpecPrimarySchemaParentRef)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryConnectionSpecPrimarySchemaParentRef)(ptr) = ConnectivityRegistryConnectionSpecPrimarySchemaParentRef{}
			}
		} else {
			*(*ConnectivityRegistryConnectionSpecPrimarySchemaParentRef)(ptr) = ConnectivityRegistryConnectionSpecPrimarySchemaParentRef{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryConnectionSpecPrimarySchemaParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecPrimarySchemaParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryConnectionSpecPrimarySchemaParentRef)(ptr) = obj
		} else {
			*(*ConnectivityRegistryConnectionSpecPrimarySchemaParentRef)(ptr) = ConnectivityRegistryConnectionSpecPrimarySchemaParentRef{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryConnectionSpecPrimarySchemaParentRef", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryConnectionSpecRegistryMetadataCodec struct {
}

func (ConnectivityRegistryConnectionSpecRegistryMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryConnectionSpecRegistryMetadata)(ptr) == nil
}

func (ConnectivityRegistryConnectionSpecRegistryMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryConnectionSpecRegistryMetadata)(ptr)
	var objs []ConnectivityRegistryConnectionSpecRegistryMetadata
	if obj != nil {
		objs = []ConnectivityRegistryConnectionSpecRegistryMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecRegistryMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryConnectionSpecRegistryMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryConnectionSpecRegistryMetadata)(ptr) = ConnectivityRegistryConnectionSpecRegistryMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryConnectionSpecRegistryMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecRegistryMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryConnectionSpecRegistryMetadata)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryConnectionSpecRegistryMetadata)(ptr) = ConnectivityRegistryConnectionSpecRegistryMetadata{}
			}
		} else {
			*(*ConnectivityRegistryConnectionSpecRegistryMetadata)(ptr) = ConnectivityRegistryConnectionSpecRegistryMetadata{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryConnectionSpecRegistryMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryConnectionSpecRegistryMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryConnectionSpecRegistryMetadata)(ptr) = obj
		} else {
			*(*ConnectivityRegistryConnectionSpecRegistryMetadata)(ptr) = ConnectivityRegistryConnectionSpecRegistryMetadata{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryConnectionSpecRegistryMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryDataAssetSpecDefaultConnectionCodec struct {
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryDataAssetSpecDefaultConnection)(ptr) == nil
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryDataAssetSpecDefaultConnection)(ptr)
	var objs []ConnectivityRegistryDataAssetSpecDefaultConnection
	if obj != nil {
		objs = []ConnectivityRegistryDataAssetSpecDefaultConnection{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnection{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryDataAssetSpecDefaultConnection)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnection{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryDataAssetSpecDefaultConnection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryDataAssetSpecDefaultConnection)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryDataAssetSpecDefaultConnection)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnection{}
			}
		} else {
			*(*ConnectivityRegistryDataAssetSpecDefaultConnection)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnection{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryDataAssetSpecDefaultConnection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryDataAssetSpecDefaultConnection)(ptr) = obj
		} else {
			*(*ConnectivityRegistryDataAssetSpecDefaultConnection)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnection{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryDataAssetSpecDefaultConnection", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataCodec struct {
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata)(ptr) == nil
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata)(ptr)
	var objs []ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata
	if obj != nil {
		objs = []ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata{}
			}
		} else {
			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata)(ptr) = obj
		} else {
			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryDataAssetSpecDefaultConnectionMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregatorCodec struct {
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregatorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator)(ptr) == nil
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregatorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator)(ptr)
	var objs []ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator
	if obj != nil {
		objs = []ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregatorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator{}
			}
		} else {
			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator)(ptr) = obj
		} else {
			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryDataAssetSpecDefaultConnectionMetadataAggregator", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaCodec struct {
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema)(ptr) == nil
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema)(ptr)
	var objs []ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema
	if obj != nil {
		objs = []ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema{}
			}
		} else {
			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema)(ptr) = obj
		} else {
			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchema", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataCodec struct {
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata)(ptr) == nil
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata)(ptr)
	var objs []ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata
	if obj != nil {
		objs = []ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata{}
			}
		} else {
			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata)(ptr) = obj
		} else {
			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregatorCodec struct {
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregatorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator)(ptr) == nil
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregatorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator)(ptr)
	var objs []ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator
	if obj != nil {
		objs = []ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregatorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator{}
			}
		} else {
			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator)(ptr) = obj
		} else {
			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaMetadataAggregator", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRefCodec struct {
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRefCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef)(ptr) == nil
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRefCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef)(ptr)
	var objs []ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef
	if obj != nil {
		objs = []ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRefCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef{}
			}
		} else {
			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef)(ptr) = obj
		} else {
			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryDataAssetSpecDefaultConnectionPrimarySchemaParentRef", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadataCodec struct {
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata)(ptr) == nil
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata)(ptr)
	var objs []ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata
	if obj != nil {
		objs = []ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata{}
			}
		} else {
			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata)(ptr) = obj
		} else {
			*(*ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata)(ptr) = ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryDataAssetSpecDefaultConnectionRegistryMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryDataAssetSpecMetadataCodec struct {
}

func (ConnectivityRegistryDataAssetSpecMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryDataAssetSpecMetadata)(ptr) == nil
}

func (ConnectivityRegistryDataAssetSpecMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryDataAssetSpecMetadata)(ptr)
	var objs []ConnectivityRegistryDataAssetSpecMetadata
	if obj != nil {
		objs = []ConnectivityRegistryDataAssetSpecMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryDataAssetSpecMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryDataAssetSpecMetadata)(ptr) = ConnectivityRegistryDataAssetSpecMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryDataAssetSpecMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryDataAssetSpecMetadata)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryDataAssetSpecMetadata)(ptr) = ConnectivityRegistryDataAssetSpecMetadata{}
			}
		} else {
			*(*ConnectivityRegistryDataAssetSpecMetadata)(ptr) = ConnectivityRegistryDataAssetSpecMetadata{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryDataAssetSpecMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryDataAssetSpecMetadata)(ptr) = obj
		} else {
			*(*ConnectivityRegistryDataAssetSpecMetadata)(ptr) = ConnectivityRegistryDataAssetSpecMetadata{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryDataAssetSpecMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryDataAssetSpecMetadataAggregatorCodec struct {
}

func (ConnectivityRegistryDataAssetSpecMetadataAggregatorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryDataAssetSpecMetadataAggregator)(ptr) == nil
}

func (ConnectivityRegistryDataAssetSpecMetadataAggregatorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryDataAssetSpecMetadataAggregator)(ptr)
	var objs []ConnectivityRegistryDataAssetSpecMetadataAggregator
	if obj != nil {
		objs = []ConnectivityRegistryDataAssetSpecMetadataAggregator{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecMetadataAggregator{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryDataAssetSpecMetadataAggregatorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryDataAssetSpecMetadataAggregator)(ptr) = ConnectivityRegistryDataAssetSpecMetadataAggregator{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryDataAssetSpecMetadataAggregator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecMetadataAggregator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryDataAssetSpecMetadataAggregator)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryDataAssetSpecMetadataAggregator)(ptr) = ConnectivityRegistryDataAssetSpecMetadataAggregator{}
			}
		} else {
			*(*ConnectivityRegistryDataAssetSpecMetadataAggregator)(ptr) = ConnectivityRegistryDataAssetSpecMetadataAggregator{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryDataAssetSpecMetadataAggregator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecMetadataAggregator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryDataAssetSpecMetadataAggregator)(ptr) = obj
		} else {
			*(*ConnectivityRegistryDataAssetSpecMetadataAggregator)(ptr) = ConnectivityRegistryDataAssetSpecMetadataAggregator{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryDataAssetSpecMetadataAggregator", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryDataAssetSpecNativeTypeSystemCodec struct {
}

func (ConnectivityRegistryDataAssetSpecNativeTypeSystemCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryDataAssetSpecNativeTypeSystem)(ptr) == nil
}

func (ConnectivityRegistryDataAssetSpecNativeTypeSystemCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryDataAssetSpecNativeTypeSystem)(ptr)
	var objs []ConnectivityRegistryDataAssetSpecNativeTypeSystem
	if obj != nil {
		objs = []ConnectivityRegistryDataAssetSpecNativeTypeSystem{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystem{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryDataAssetSpecNativeTypeSystemCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryDataAssetSpecNativeTypeSystem)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystem{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryDataAssetSpecNativeTypeSystem

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystem{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryDataAssetSpecNativeTypeSystem)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryDataAssetSpecNativeTypeSystem)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystem{}
			}
		} else {
			*(*ConnectivityRegistryDataAssetSpecNativeTypeSystem)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystem{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryDataAssetSpecNativeTypeSystem

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystem{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryDataAssetSpecNativeTypeSystem)(ptr) = obj
		} else {
			*(*ConnectivityRegistryDataAssetSpecNativeTypeSystem)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystem{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryDataAssetSpecNativeTypeSystem", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRefCodec struct {
}

func (ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRefCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef)(ptr) == nil
}

func (ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRefCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef)(ptr)
	var objs []ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef
	if obj != nil {
		objs = []ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRefCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef{}
			}
		} else {
			*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef)(ptr) = obj
		} else {
			*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryDataAssetSpecNativeTypeSystemParentRef", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionCodec struct {
}

func (ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition)(ptr) == nil
}

func (ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition)(ptr)
	var objs []ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition
	if obj != nil {
		objs = []ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition{}
			}
		} else {
			*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition)(ptr) = obj
		} else {
			*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRefCodec struct {
}

func (ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRefCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef)(ptr) == nil
}

func (ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRefCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef)(ptr)
	var objs []ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef
	if obj != nil {
		objs = []ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRefCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef{}
			}
		} else {
			*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef)(ptr) = obj
		} else {
			*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesConfigDefinitionParentRef", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRefCodec struct {
}

func (ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRefCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef)(ptr) == nil
}

func (ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRefCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef)(ptr)
	var objs []ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef
	if obj != nil {
		objs = []ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRefCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef{}
			}
		} else {
			*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef)(ptr) = obj
		} else {
			*(*ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef)(ptr) = ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryDataAssetSpecNativeTypeSystemTypesParentRef", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryDataAssetSpecRegistryMetadataCodec struct {
}

func (ConnectivityRegistryDataAssetSpecRegistryMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryDataAssetSpecRegistryMetadata)(ptr) == nil
}

func (ConnectivityRegistryDataAssetSpecRegistryMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryDataAssetSpecRegistryMetadata)(ptr)
	var objs []ConnectivityRegistryDataAssetSpecRegistryMetadata
	if obj != nil {
		objs = []ConnectivityRegistryDataAssetSpecRegistryMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecRegistryMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryDataAssetSpecRegistryMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryDataAssetSpecRegistryMetadata)(ptr) = ConnectivityRegistryDataAssetSpecRegistryMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryDataAssetSpecRegistryMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecRegistryMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryDataAssetSpecRegistryMetadata)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryDataAssetSpecRegistryMetadata)(ptr) = ConnectivityRegistryDataAssetSpecRegistryMetadata{}
			}
		} else {
			*(*ConnectivityRegistryDataAssetSpecRegistryMetadata)(ptr) = ConnectivityRegistryDataAssetSpecRegistryMetadata{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryDataAssetSpecRegistryMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryDataAssetSpecRegistryMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryDataAssetSpecRegistryMetadata)(ptr) = obj
		} else {
			*(*ConnectivityRegistryDataAssetSpecRegistryMetadata)(ptr) = ConnectivityRegistryDataAssetSpecRegistryMetadata{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryDataAssetSpecRegistryMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionCodec struct {
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecDataAssetsDefaultConnection)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecDataAssetsDefaultConnection)(ptr)
	var objs []ConnectivityRegistryFolderSpecDataAssetsDefaultConnection
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecDataAssetsDefaultConnection{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnection{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnection)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnection{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecDataAssetsDefaultConnection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnection)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnection)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnection{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnection)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnection{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecDataAssetsDefaultConnection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnection)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnection)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnection{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecDataAssetsDefaultConnection", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataCodec struct {
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata)(ptr)
	var objs []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregatorCodec struct {
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregatorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregatorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator)(ptr)
	var objs []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregatorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionMetadataAggregator", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaCodec struct {
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema)(ptr)
	var objs []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchema", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataCodec struct {
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata)(ptr)
	var objs []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregatorCodec struct {
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregatorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregatorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator)(ptr)
	var objs []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregatorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaMetadataAggregator", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRefCodec struct {
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRefCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRefCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef)(ptr)
	var objs []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRefCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionPrimarySchemaParentRef", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadataCodec struct {
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata)(ptr)
	var objs []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecDataAssetsDefaultConnectionRegistryMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecDataAssetsMetadataCodec struct {
}

func (ConnectivityRegistryFolderSpecDataAssetsMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecDataAssetsMetadata)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecDataAssetsMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecDataAssetsMetadata)(ptr)
	var objs []ConnectivityRegistryFolderSpecDataAssetsMetadata
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecDataAssetsMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecDataAssetsMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecDataAssetsMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecDataAssetsMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecDataAssetsMetadata)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecDataAssetsMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsMetadata{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsMetadata{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecDataAssetsMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecDataAssetsMetadata)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsMetadata{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecDataAssetsMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecDataAssetsMetadataAggregatorCodec struct {
}

func (ConnectivityRegistryFolderSpecDataAssetsMetadataAggregatorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecDataAssetsMetadataAggregatorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator)(ptr)
	var objs []ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecDataAssetsMetadataAggregatorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator)(ptr) = ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator)(ptr) = ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator)(ptr) = ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator)(ptr) = ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecDataAssetsMetadataAggregator", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemCodec struct {
}

func (ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem)(ptr)
	var objs []ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystem", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRefCodec struct {
}

func (ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRefCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRefCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef)(ptr)
	var objs []ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRefCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemParentRef", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionCodec struct {
}

func (ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition)(ptr)
	var objs []ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRefCodec struct {
}

func (ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRefCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRefCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef)(ptr)
	var objs []ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRefCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesConfigDefinitionParentRef", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRefCodec struct {
}

func (ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRefCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRefCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef)(ptr)
	var objs []ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRefCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef)(ptr) = ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecDataAssetsNativeTypeSystemTypesParentRef", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecDataAssetsRegistryMetadataCodec struct {
}

func (ConnectivityRegistryFolderSpecDataAssetsRegistryMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecDataAssetsRegistryMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata)(ptr)
	var objs []ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecDataAssetsRegistryMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata)(ptr) = ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecDataAssetsRegistryMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectivityRegistryFolderSpecParentRefCodec struct {
}

func (ConnectivityRegistryFolderSpecParentRefCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectivityRegistryFolderSpecParentRef)(ptr) == nil
}

func (ConnectivityRegistryFolderSpecParentRefCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectivityRegistryFolderSpecParentRef)(ptr)
	var objs []ConnectivityRegistryFolderSpecParentRef
	if obj != nil {
		objs = []ConnectivityRegistryFolderSpecParentRef{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecParentRef{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectivityRegistryFolderSpecParentRefCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectivityRegistryFolderSpecParentRef)(ptr) = ConnectivityRegistryFolderSpecParentRef{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectivityRegistryFolderSpecParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectivityRegistryFolderSpecParentRef)(ptr) = objs[0]
			} else {
				*(*ConnectivityRegistryFolderSpecParentRef)(ptr) = ConnectivityRegistryFolderSpecParentRef{}
			}
		} else {
			*(*ConnectivityRegistryFolderSpecParentRef)(ptr) = ConnectivityRegistryFolderSpecParentRef{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ConnectivityRegistryFolderSpecParentRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectivityRegistryFolderSpecParentRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ConnectivityRegistryFolderSpecParentRef)(ptr) = obj
		} else {
			*(*ConnectivityRegistryFolderSpecParentRef)(ptr) = ConnectivityRegistryFolderSpecParentRef{}
		}
	default:
		iter.ReportError("decode ConnectivityRegistryFolderSpecParentRef", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LabelingServiceDatasetSpecDatasetFormatDetailsCodec struct {
}

func (LabelingServiceDatasetSpecDatasetFormatDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LabelingServiceDatasetSpecDatasetFormatDetails)(ptr) == nil
}

func (LabelingServiceDatasetSpecDatasetFormatDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LabelingServiceDatasetSpecDatasetFormatDetails)(ptr)
	var objs []LabelingServiceDatasetSpecDatasetFormatDetails
	if obj != nil {
		objs = []LabelingServiceDatasetSpecDatasetFormatDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecDatasetFormatDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LabelingServiceDatasetSpecDatasetFormatDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LabelingServiceDatasetSpecDatasetFormatDetails)(ptr) = LabelingServiceDatasetSpecDatasetFormatDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LabelingServiceDatasetSpecDatasetFormatDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecDatasetFormatDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LabelingServiceDatasetSpecDatasetFormatDetails)(ptr) = objs[0]
			} else {
				*(*LabelingServiceDatasetSpecDatasetFormatDetails)(ptr) = LabelingServiceDatasetSpecDatasetFormatDetails{}
			}
		} else {
			*(*LabelingServiceDatasetSpecDatasetFormatDetails)(ptr) = LabelingServiceDatasetSpecDatasetFormatDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj LabelingServiceDatasetSpecDatasetFormatDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecDatasetFormatDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*LabelingServiceDatasetSpecDatasetFormatDetails)(ptr) = obj
		} else {
			*(*LabelingServiceDatasetSpecDatasetFormatDetails)(ptr) = LabelingServiceDatasetSpecDatasetFormatDetails{}
		}
	default:
		iter.ReportError("decode LabelingServiceDatasetSpecDatasetFormatDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LabelingServiceDatasetSpecDatasetSourceDetailsCodec struct {
}

func (LabelingServiceDatasetSpecDatasetSourceDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LabelingServiceDatasetSpecDatasetSourceDetails)(ptr) == nil
}

func (LabelingServiceDatasetSpecDatasetSourceDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LabelingServiceDatasetSpecDatasetSourceDetails)(ptr)
	var objs []LabelingServiceDatasetSpecDatasetSourceDetails
	if obj != nil {
		objs = []LabelingServiceDatasetSpecDatasetSourceDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecDatasetSourceDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LabelingServiceDatasetSpecDatasetSourceDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LabelingServiceDatasetSpecDatasetSourceDetails)(ptr) = LabelingServiceDatasetSpecDatasetSourceDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LabelingServiceDatasetSpecDatasetSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecDatasetSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LabelingServiceDatasetSpecDatasetSourceDetails)(ptr) = objs[0]
			} else {
				*(*LabelingServiceDatasetSpecDatasetSourceDetails)(ptr) = LabelingServiceDatasetSpecDatasetSourceDetails{}
			}
		} else {
			*(*LabelingServiceDatasetSpecDatasetSourceDetails)(ptr) = LabelingServiceDatasetSpecDatasetSourceDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj LabelingServiceDatasetSpecDatasetSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecDatasetSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*LabelingServiceDatasetSpecDatasetSourceDetails)(ptr) = obj
		} else {
			*(*LabelingServiceDatasetSpecDatasetSourceDetails)(ptr) = LabelingServiceDatasetSpecDatasetSourceDetails{}
		}
	default:
		iter.ReportError("decode LabelingServiceDatasetSpecDatasetSourceDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LabelingServiceDatasetSpecInitialRecordGenerationConfigurationCodec struct {
}

func (LabelingServiceDatasetSpecInitialRecordGenerationConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LabelingServiceDatasetSpecInitialRecordGenerationConfiguration)(ptr) == nil
}

func (LabelingServiceDatasetSpecInitialRecordGenerationConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LabelingServiceDatasetSpecInitialRecordGenerationConfiguration)(ptr)
	var objs []LabelingServiceDatasetSpecInitialRecordGenerationConfiguration
	if obj != nil {
		objs = []LabelingServiceDatasetSpecInitialRecordGenerationConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecInitialRecordGenerationConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LabelingServiceDatasetSpecInitialRecordGenerationConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LabelingServiceDatasetSpecInitialRecordGenerationConfiguration)(ptr) = LabelingServiceDatasetSpecInitialRecordGenerationConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LabelingServiceDatasetSpecInitialRecordGenerationConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecInitialRecordGenerationConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LabelingServiceDatasetSpecInitialRecordGenerationConfiguration)(ptr) = objs[0]
			} else {
				*(*LabelingServiceDatasetSpecInitialRecordGenerationConfiguration)(ptr) = LabelingServiceDatasetSpecInitialRecordGenerationConfiguration{}
			}
		} else {
			*(*LabelingServiceDatasetSpecInitialRecordGenerationConfiguration)(ptr) = LabelingServiceDatasetSpecInitialRecordGenerationConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj LabelingServiceDatasetSpecInitialRecordGenerationConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecInitialRecordGenerationConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*LabelingServiceDatasetSpecInitialRecordGenerationConfiguration)(ptr) = obj
		} else {
			*(*LabelingServiceDatasetSpecInitialRecordGenerationConfiguration)(ptr) = LabelingServiceDatasetSpecInitialRecordGenerationConfiguration{}
		}
	default:
		iter.ReportError("decode LabelingServiceDatasetSpecInitialRecordGenerationConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LabelingServiceDatasetSpecLabelSetCodec struct {
}

func (LabelingServiceDatasetSpecLabelSetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LabelingServiceDatasetSpecLabelSet)(ptr) == nil
}

func (LabelingServiceDatasetSpecLabelSetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LabelingServiceDatasetSpecLabelSet)(ptr)
	var objs []LabelingServiceDatasetSpecLabelSet
	if obj != nil {
		objs = []LabelingServiceDatasetSpecLabelSet{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecLabelSet{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LabelingServiceDatasetSpecLabelSetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LabelingServiceDatasetSpecLabelSet)(ptr) = LabelingServiceDatasetSpecLabelSet{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LabelingServiceDatasetSpecLabelSet

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecLabelSet{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LabelingServiceDatasetSpecLabelSet)(ptr) = objs[0]
			} else {
				*(*LabelingServiceDatasetSpecLabelSet)(ptr) = LabelingServiceDatasetSpecLabelSet{}
			}
		} else {
			*(*LabelingServiceDatasetSpecLabelSet)(ptr) = LabelingServiceDatasetSpecLabelSet{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj LabelingServiceDatasetSpecLabelSet

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LabelingServiceDatasetSpecLabelSet{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*LabelingServiceDatasetSpecLabelSet)(ptr) = obj
		} else {
			*(*LabelingServiceDatasetSpecLabelSet)(ptr) = LabelingServiceDatasetSpecLabelSet{}
		}
	default:
		iter.ReportError("decode LabelingServiceDatasetSpecLabelSet", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SafeSecurityAssessmentSpecStatisticsCodec struct {
}

func (SafeSecurityAssessmentSpecStatisticsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SafeSecurityAssessmentSpecStatistics)(ptr) == nil
}

func (SafeSecurityAssessmentSpecStatisticsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SafeSecurityAssessmentSpecStatistics)(ptr)
	var objs []SafeSecurityAssessmentSpecStatistics
	if obj != nil {
		objs = []SafeSecurityAssessmentSpecStatistics{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatistics{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SafeSecurityAssessmentSpecStatisticsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SafeSecurityAssessmentSpecStatistics)(ptr) = SafeSecurityAssessmentSpecStatistics{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SafeSecurityAssessmentSpecStatistics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatistics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SafeSecurityAssessmentSpecStatistics)(ptr) = objs[0]
			} else {
				*(*SafeSecurityAssessmentSpecStatistics)(ptr) = SafeSecurityAssessmentSpecStatistics{}
			}
		} else {
			*(*SafeSecurityAssessmentSpecStatistics)(ptr) = SafeSecurityAssessmentSpecStatistics{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SafeSecurityAssessmentSpecStatistics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatistics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SafeSecurityAssessmentSpecStatistics)(ptr) = obj
		} else {
			*(*SafeSecurityAssessmentSpecStatistics)(ptr) = SafeSecurityAssessmentSpecStatistics{}
		}
	default:
		iter.ReportError("decode SafeSecurityAssessmentSpecStatistics", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SafeSecurityAssessmentSpecStatisticsAdvisoryCodec struct {
}

func (SafeSecurityAssessmentSpecStatisticsAdvisoryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SafeSecurityAssessmentSpecStatisticsAdvisory)(ptr) == nil
}

func (SafeSecurityAssessmentSpecStatisticsAdvisoryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SafeSecurityAssessmentSpecStatisticsAdvisory)(ptr)
	var objs []SafeSecurityAssessmentSpecStatisticsAdvisory
	if obj != nil {
		objs = []SafeSecurityAssessmentSpecStatisticsAdvisory{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsAdvisory{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SafeSecurityAssessmentSpecStatisticsAdvisoryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SafeSecurityAssessmentSpecStatisticsAdvisory)(ptr) = SafeSecurityAssessmentSpecStatisticsAdvisory{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SafeSecurityAssessmentSpecStatisticsAdvisory

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsAdvisory{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SafeSecurityAssessmentSpecStatisticsAdvisory)(ptr) = objs[0]
			} else {
				*(*SafeSecurityAssessmentSpecStatisticsAdvisory)(ptr) = SafeSecurityAssessmentSpecStatisticsAdvisory{}
			}
		} else {
			*(*SafeSecurityAssessmentSpecStatisticsAdvisory)(ptr) = SafeSecurityAssessmentSpecStatisticsAdvisory{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SafeSecurityAssessmentSpecStatisticsAdvisory

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsAdvisory{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SafeSecurityAssessmentSpecStatisticsAdvisory)(ptr) = obj
		} else {
			*(*SafeSecurityAssessmentSpecStatisticsAdvisory)(ptr) = SafeSecurityAssessmentSpecStatisticsAdvisory{}
		}
	default:
		iter.ReportError("decode SafeSecurityAssessmentSpecStatisticsAdvisory", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SafeSecurityAssessmentSpecStatisticsEvaluateCodec struct {
}

func (SafeSecurityAssessmentSpecStatisticsEvaluateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SafeSecurityAssessmentSpecStatisticsEvaluate)(ptr) == nil
}

func (SafeSecurityAssessmentSpecStatisticsEvaluateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SafeSecurityAssessmentSpecStatisticsEvaluate)(ptr)
	var objs []SafeSecurityAssessmentSpecStatisticsEvaluate
	if obj != nil {
		objs = []SafeSecurityAssessmentSpecStatisticsEvaluate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsEvaluate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SafeSecurityAssessmentSpecStatisticsEvaluateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SafeSecurityAssessmentSpecStatisticsEvaluate)(ptr) = SafeSecurityAssessmentSpecStatisticsEvaluate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SafeSecurityAssessmentSpecStatisticsEvaluate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsEvaluate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SafeSecurityAssessmentSpecStatisticsEvaluate)(ptr) = objs[0]
			} else {
				*(*SafeSecurityAssessmentSpecStatisticsEvaluate)(ptr) = SafeSecurityAssessmentSpecStatisticsEvaluate{}
			}
		} else {
			*(*SafeSecurityAssessmentSpecStatisticsEvaluate)(ptr) = SafeSecurityAssessmentSpecStatisticsEvaluate{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SafeSecurityAssessmentSpecStatisticsEvaluate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsEvaluate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SafeSecurityAssessmentSpecStatisticsEvaluate)(ptr) = obj
		} else {
			*(*SafeSecurityAssessmentSpecStatisticsEvaluate)(ptr) = SafeSecurityAssessmentSpecStatisticsEvaluate{}
		}
	default:
		iter.ReportError("decode SafeSecurityAssessmentSpecStatisticsEvaluate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SafeSecurityAssessmentSpecStatisticsHighRiskCodec struct {
}

func (SafeSecurityAssessmentSpecStatisticsHighRiskCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SafeSecurityAssessmentSpecStatisticsHighRisk)(ptr) == nil
}

func (SafeSecurityAssessmentSpecStatisticsHighRiskCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SafeSecurityAssessmentSpecStatisticsHighRisk)(ptr)
	var objs []SafeSecurityAssessmentSpecStatisticsHighRisk
	if obj != nil {
		objs = []SafeSecurityAssessmentSpecStatisticsHighRisk{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsHighRisk{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SafeSecurityAssessmentSpecStatisticsHighRiskCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SafeSecurityAssessmentSpecStatisticsHighRisk)(ptr) = SafeSecurityAssessmentSpecStatisticsHighRisk{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SafeSecurityAssessmentSpecStatisticsHighRisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsHighRisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SafeSecurityAssessmentSpecStatisticsHighRisk)(ptr) = objs[0]
			} else {
				*(*SafeSecurityAssessmentSpecStatisticsHighRisk)(ptr) = SafeSecurityAssessmentSpecStatisticsHighRisk{}
			}
		} else {
			*(*SafeSecurityAssessmentSpecStatisticsHighRisk)(ptr) = SafeSecurityAssessmentSpecStatisticsHighRisk{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SafeSecurityAssessmentSpecStatisticsHighRisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsHighRisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SafeSecurityAssessmentSpecStatisticsHighRisk)(ptr) = obj
		} else {
			*(*SafeSecurityAssessmentSpecStatisticsHighRisk)(ptr) = SafeSecurityAssessmentSpecStatisticsHighRisk{}
		}
	default:
		iter.ReportError("decode SafeSecurityAssessmentSpecStatisticsHighRisk", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SafeSecurityAssessmentSpecStatisticsLowRiskCodec struct {
}

func (SafeSecurityAssessmentSpecStatisticsLowRiskCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SafeSecurityAssessmentSpecStatisticsLowRisk)(ptr) == nil
}

func (SafeSecurityAssessmentSpecStatisticsLowRiskCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SafeSecurityAssessmentSpecStatisticsLowRisk)(ptr)
	var objs []SafeSecurityAssessmentSpecStatisticsLowRisk
	if obj != nil {
		objs = []SafeSecurityAssessmentSpecStatisticsLowRisk{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsLowRisk{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SafeSecurityAssessmentSpecStatisticsLowRiskCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SafeSecurityAssessmentSpecStatisticsLowRisk)(ptr) = SafeSecurityAssessmentSpecStatisticsLowRisk{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SafeSecurityAssessmentSpecStatisticsLowRisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsLowRisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SafeSecurityAssessmentSpecStatisticsLowRisk)(ptr) = objs[0]
			} else {
				*(*SafeSecurityAssessmentSpecStatisticsLowRisk)(ptr) = SafeSecurityAssessmentSpecStatisticsLowRisk{}
			}
		} else {
			*(*SafeSecurityAssessmentSpecStatisticsLowRisk)(ptr) = SafeSecurityAssessmentSpecStatisticsLowRisk{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SafeSecurityAssessmentSpecStatisticsLowRisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsLowRisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SafeSecurityAssessmentSpecStatisticsLowRisk)(ptr) = obj
		} else {
			*(*SafeSecurityAssessmentSpecStatisticsLowRisk)(ptr) = SafeSecurityAssessmentSpecStatisticsLowRisk{}
		}
	default:
		iter.ReportError("decode SafeSecurityAssessmentSpecStatisticsLowRisk", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SafeSecurityAssessmentSpecStatisticsMediumRiskCodec struct {
}

func (SafeSecurityAssessmentSpecStatisticsMediumRiskCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SafeSecurityAssessmentSpecStatisticsMediumRisk)(ptr) == nil
}

func (SafeSecurityAssessmentSpecStatisticsMediumRiskCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SafeSecurityAssessmentSpecStatisticsMediumRisk)(ptr)
	var objs []SafeSecurityAssessmentSpecStatisticsMediumRisk
	if obj != nil {
		objs = []SafeSecurityAssessmentSpecStatisticsMediumRisk{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsMediumRisk{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SafeSecurityAssessmentSpecStatisticsMediumRiskCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SafeSecurityAssessmentSpecStatisticsMediumRisk)(ptr) = SafeSecurityAssessmentSpecStatisticsMediumRisk{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SafeSecurityAssessmentSpecStatisticsMediumRisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsMediumRisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SafeSecurityAssessmentSpecStatisticsMediumRisk)(ptr) = objs[0]
			} else {
				*(*SafeSecurityAssessmentSpecStatisticsMediumRisk)(ptr) = SafeSecurityAssessmentSpecStatisticsMediumRisk{}
			}
		} else {
			*(*SafeSecurityAssessmentSpecStatisticsMediumRisk)(ptr) = SafeSecurityAssessmentSpecStatisticsMediumRisk{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SafeSecurityAssessmentSpecStatisticsMediumRisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsMediumRisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SafeSecurityAssessmentSpecStatisticsMediumRisk)(ptr) = obj
		} else {
			*(*SafeSecurityAssessmentSpecStatisticsMediumRisk)(ptr) = SafeSecurityAssessmentSpecStatisticsMediumRisk{}
		}
	default:
		iter.ReportError("decode SafeSecurityAssessmentSpecStatisticsMediumRisk", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SafeSecurityAssessmentSpecStatisticsPassCodec struct {
}

func (SafeSecurityAssessmentSpecStatisticsPassCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SafeSecurityAssessmentSpecStatisticsPass)(ptr) == nil
}

func (SafeSecurityAssessmentSpecStatisticsPassCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SafeSecurityAssessmentSpecStatisticsPass)(ptr)
	var objs []SafeSecurityAssessmentSpecStatisticsPass
	if obj != nil {
		objs = []SafeSecurityAssessmentSpecStatisticsPass{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsPass{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SafeSecurityAssessmentSpecStatisticsPassCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SafeSecurityAssessmentSpecStatisticsPass)(ptr) = SafeSecurityAssessmentSpecStatisticsPass{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SafeSecurityAssessmentSpecStatisticsPass

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsPass{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SafeSecurityAssessmentSpecStatisticsPass)(ptr) = objs[0]
			} else {
				*(*SafeSecurityAssessmentSpecStatisticsPass)(ptr) = SafeSecurityAssessmentSpecStatisticsPass{}
			}
		} else {
			*(*SafeSecurityAssessmentSpecStatisticsPass)(ptr) = SafeSecurityAssessmentSpecStatisticsPass{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SafeSecurityAssessmentSpecStatisticsPass

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeSecurityAssessmentSpecStatisticsPass{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SafeSecurityAssessmentSpecStatisticsPass)(ptr) = obj
		} else {
			*(*SafeSecurityAssessmentSpecStatisticsPass)(ptr) = SafeSecurityAssessmentSpecStatisticsPass{}
		}
	default:
		iter.ReportError("decode SafeSecurityAssessmentSpecStatisticsPass", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SafeTargetDatabaseSpecConnectionOptionCodec struct {
}

func (SafeTargetDatabaseSpecConnectionOptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SafeTargetDatabaseSpecConnectionOption)(ptr) == nil
}

func (SafeTargetDatabaseSpecConnectionOptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SafeTargetDatabaseSpecConnectionOption)(ptr)
	var objs []SafeTargetDatabaseSpecConnectionOption
	if obj != nil {
		objs = []SafeTargetDatabaseSpecConnectionOption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecConnectionOption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SafeTargetDatabaseSpecConnectionOptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SafeTargetDatabaseSpecConnectionOption)(ptr) = SafeTargetDatabaseSpecConnectionOption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SafeTargetDatabaseSpecConnectionOption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecConnectionOption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SafeTargetDatabaseSpecConnectionOption)(ptr) = objs[0]
			} else {
				*(*SafeTargetDatabaseSpecConnectionOption)(ptr) = SafeTargetDatabaseSpecConnectionOption{}
			}
		} else {
			*(*SafeTargetDatabaseSpecConnectionOption)(ptr) = SafeTargetDatabaseSpecConnectionOption{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SafeTargetDatabaseSpecConnectionOption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecConnectionOption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SafeTargetDatabaseSpecConnectionOption)(ptr) = obj
		} else {
			*(*SafeTargetDatabaseSpecConnectionOption)(ptr) = SafeTargetDatabaseSpecConnectionOption{}
		}
	default:
		iter.ReportError("decode SafeTargetDatabaseSpecConnectionOption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SafeTargetDatabaseSpecCredentialsCodec struct {
}

func (SafeTargetDatabaseSpecCredentialsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SafeTargetDatabaseSpecCredentials)(ptr) == nil
}

func (SafeTargetDatabaseSpecCredentialsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SafeTargetDatabaseSpecCredentials)(ptr)
	var objs []SafeTargetDatabaseSpecCredentials
	if obj != nil {
		objs = []SafeTargetDatabaseSpecCredentials{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecCredentials{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SafeTargetDatabaseSpecCredentialsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SafeTargetDatabaseSpecCredentials)(ptr) = SafeTargetDatabaseSpecCredentials{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SafeTargetDatabaseSpecCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SafeTargetDatabaseSpecCredentials)(ptr) = objs[0]
			} else {
				*(*SafeTargetDatabaseSpecCredentials)(ptr) = SafeTargetDatabaseSpecCredentials{}
			}
		} else {
			*(*SafeTargetDatabaseSpecCredentials)(ptr) = SafeTargetDatabaseSpecCredentials{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SafeTargetDatabaseSpecCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SafeTargetDatabaseSpecCredentials)(ptr) = obj
		} else {
			*(*SafeTargetDatabaseSpecCredentials)(ptr) = SafeTargetDatabaseSpecCredentials{}
		}
	default:
		iter.ReportError("decode SafeTargetDatabaseSpecCredentials", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SafeTargetDatabaseSpecDatabaseDetailsCodec struct {
}

func (SafeTargetDatabaseSpecDatabaseDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SafeTargetDatabaseSpecDatabaseDetails)(ptr) == nil
}

func (SafeTargetDatabaseSpecDatabaseDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SafeTargetDatabaseSpecDatabaseDetails)(ptr)
	var objs []SafeTargetDatabaseSpecDatabaseDetails
	if obj != nil {
		objs = []SafeTargetDatabaseSpecDatabaseDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecDatabaseDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SafeTargetDatabaseSpecDatabaseDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SafeTargetDatabaseSpecDatabaseDetails)(ptr) = SafeTargetDatabaseSpecDatabaseDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SafeTargetDatabaseSpecDatabaseDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecDatabaseDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SafeTargetDatabaseSpecDatabaseDetails)(ptr) = objs[0]
			} else {
				*(*SafeTargetDatabaseSpecDatabaseDetails)(ptr) = SafeTargetDatabaseSpecDatabaseDetails{}
			}
		} else {
			*(*SafeTargetDatabaseSpecDatabaseDetails)(ptr) = SafeTargetDatabaseSpecDatabaseDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SafeTargetDatabaseSpecDatabaseDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecDatabaseDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SafeTargetDatabaseSpecDatabaseDetails)(ptr) = obj
		} else {
			*(*SafeTargetDatabaseSpecDatabaseDetails)(ptr) = SafeTargetDatabaseSpecDatabaseDetails{}
		}
	default:
		iter.ReportError("decode SafeTargetDatabaseSpecDatabaseDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SafeTargetDatabaseSpecTlsConfigCodec struct {
}

func (SafeTargetDatabaseSpecTlsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SafeTargetDatabaseSpecTlsConfig)(ptr) == nil
}

func (SafeTargetDatabaseSpecTlsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SafeTargetDatabaseSpecTlsConfig)(ptr)
	var objs []SafeTargetDatabaseSpecTlsConfig
	if obj != nil {
		objs = []SafeTargetDatabaseSpecTlsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecTlsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SafeTargetDatabaseSpecTlsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SafeTargetDatabaseSpecTlsConfig)(ptr) = SafeTargetDatabaseSpecTlsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SafeTargetDatabaseSpecTlsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecTlsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SafeTargetDatabaseSpecTlsConfig)(ptr) = objs[0]
			} else {
				*(*SafeTargetDatabaseSpecTlsConfig)(ptr) = SafeTargetDatabaseSpecTlsConfig{}
			}
		} else {
			*(*SafeTargetDatabaseSpecTlsConfig)(ptr) = SafeTargetDatabaseSpecTlsConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SafeTargetDatabaseSpecTlsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SafeTargetDatabaseSpecTlsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SafeTargetDatabaseSpecTlsConfig)(ptr) = obj
		} else {
			*(*SafeTargetDatabaseSpecTlsConfig)(ptr) = SafeTargetDatabaseSpecTlsConfig{}
		}
	default:
		iter.ReportError("decode SafeTargetDatabaseSpecTlsConfig", "unexpected JSON type")
	}
}
