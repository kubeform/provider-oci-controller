/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecBackupConfig{}).Type1()):                                    AutonomousContainerDatabaseSpecBackupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails{}).Type1()):            AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecMaintenanceWindow{}).Type1()):                               AutonomousContainerDatabaseSpecMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecMaintenanceWindowDetails{}).Type1()):                        AutonomousContainerDatabaseSpecMaintenanceWindowDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig{}).Type1()):     AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecApexDetails{}).Type1()):                                              AutonomousDatabaseSpecApexDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecBackupConfig{}).Type1()):                                             AutonomousDatabaseSpecBackupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecConnectionStrings{}).Type1()):                                        AutonomousDatabaseSpecConnectionStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecConnectionUrls{}).Type1()):                                           AutonomousDatabaseSpecConnectionUrlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecScheduledOperationsDayOfWeek{}).Type1()):                             AutonomousDatabaseSpecScheduledOperationsDayOfWeekCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecStandbyDb{}).Type1()):                                                AutonomousDatabaseSpecStandbyDbCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousExadataInfrastructureSpecMaintenanceWindow{}).Type1()):                           AutonomousExadataInfrastructureSpecMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousExadataInfrastructureSpecMaintenanceWindowDetails{}).Type1()):                    AutonomousExadataInfrastructureSpecMaintenanceWindowDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackupDestinationSpecMountTypeDetails{}).Type1()):                                          BackupDestinationSpecMountTypeDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CloudDatabaseManagementSpecCredentialdetails{}).Type1()):                                   CloudDatabaseManagementSpecCredentialdetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CloudExadataInfrastructureSpecMaintenanceWindow{}).Type1()):                                CloudExadataInfrastructureSpecMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CloudVmClusterSpecIormConfigCache{}).Type1()):                                              CloudVmClusterSpecIormConfigCacheCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecConnectionStrings{}).Type1()):                                                  DatabaseSpecConnectionStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDatabase{}).Type1()):                                                           DatabaseSpecDatabaseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDatabaseDbBackupConfig{}).Type1()):                                             DatabaseSpecDatabaseDbBackupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDatabaseManagementConfig{}).Type1()):                                           DatabaseSpecDatabaseManagementConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDbBackupConfig{}).Type1()):                                                     DatabaseSpecDbBackupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseUpgradeSpecConnectionStrings{}).Type1()):                                           DatabaseUpgradeSpecConnectionStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseUpgradeSpecDatabaseUpgradeSourceDetails{}).Type1()):                                DatabaseUpgradeSpecDatabaseUpgradeSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseUpgradeSpecDbBackupConfig{}).Type1()):                                              DatabaseUpgradeSpecDbBackupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbHomeSpecDatabase{}).Type1()):                                                             DbHomeSpecDatabaseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbHomeSpecDatabaseDbBackupConfig{}).Type1()):                                               DbHomeSpecDatabaseDbBackupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbHome{}).Type1()):                                                             DbSystemSpecDbHomeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbHomeDatabase{}).Type1()):                                                     DbSystemSpecDbHomeDatabaseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbHomeDatabaseDbBackupConfig{}).Type1()):                                       DbSystemSpecDbHomeDatabaseDbBackupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbSystemOptions{}).Type1()):                                                    DbSystemSpecDbSystemOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecIormConfigCache{}).Type1()):                                                    DbSystemSpecIormConfigCacheCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecMaintenanceWindow{}).Type1()):                                                  DbSystemSpecMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecMaintenanceWindowDetails{}).Type1()):                                           DbSystemSpecMaintenanceWindowDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExadataInfrastructureSpecMaintenanceWindow{}).Type1()):                                     ExadataInfrastructureSpecMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExadataInfrastructureStorageSpecMaintenanceWindow{}).Type1()):                              ExadataInfrastructureStorageSpecMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExternalContainerDatabaseSpecDatabaseManagementConfig{}).Type1()):                          ExternalContainerDatabaseSpecDatabaseManagementConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExternalDatabaseConnectorSpecConnectionCredentials{}).Type1()):                             ExternalDatabaseConnectorSpecConnectionCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExternalDatabaseConnectorSpecConnectionString{}).Type1()):                                  ExternalDatabaseConnectorSpecConnectionStringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExternalNonContainerDatabaseSpecDatabaseManagementConfig{}).Type1()):                       ExternalNonContainerDatabaseSpecDatabaseManagementConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExternalNonContainerDatabaseSpecOperationsInsightsConfig{}).Type1()):                       ExternalNonContainerDatabaseSpecOperationsInsightsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExternalPluggableDatabaseSpecDatabaseManagementConfig{}).Type1()):                          ExternalPluggableDatabaseSpecDatabaseManagementConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExternalPluggableDatabaseSpecOperationsInsightsConfig{}).Type1()):                          ExternalPluggableDatabaseSpecOperationsInsightsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KeyStoreSpecTypeDetails{}).Type1()):                                                        KeyStoreSpecTypeDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MaintenanceRunSpecEstimatedPatchingTime{}).Type1()):                                        MaintenanceRunSpecEstimatedPatchingTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials{}).Type1()):               ManagementManagedDatabasesChangeDatabaseParameterSpecCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementManagedDatabasesResetDatabaseParameterSpecCredentials{}).Type1()):                ManagementManagedDatabasesResetDatabaseParameterSpecCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecAdminCredentials{}).Type1()):                                        MigrationConnectionSpecAdminCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecConnectDescriptor{}).Type1()):                                       MigrationConnectionSpecConnectDescriptorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecPrivateEndpoint{}).Type1()):                                         MigrationConnectionSpecPrivateEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecSshDetails{}).Type1()):                                              MigrationConnectionSpecSshDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecVaultDetails{}).Type1()):                                            MigrationConnectionSpecVaultDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationJobSpecProgress{}).Type1()):                                                       MigrationJobSpecProgressCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationJobSpecProgressPhasesLogLocation{}).Type1()):                                      MigrationJobSpecProgressPhasesLogLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecAdvisorSettings{}).Type1()):                                          MigrationMigrationSpecAdvisorSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetails{}).Type1()):                                MigrationMigrationSpecDataTransferMediumDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails{}).Type1()):             MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket{}).Type1()): MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucketCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails{}).Type1()):            MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettings{}).Type1()):                                         MigrationMigrationSpecDatapumpSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettingsDataPumpParameters{}).Type1()):                       MigrationMigrationSpecDatapumpSettingsDataPumpParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettingsExportDirectoryObject{}).Type1()):                    MigrationMigrationSpecDatapumpSettingsExportDirectoryObjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettingsImportDirectoryObject{}).Type1()):                    MigrationMigrationSpecDatapumpSettingsImportDirectoryObjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDumpTransferDetails{}).Type1()):                                      MigrationMigrationSpecDumpTransferDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDumpTransferDetailsSource{}).Type1()):                                MigrationMigrationSpecDumpTransferDetailsSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDumpTransferDetailsTarget{}).Type1()):                                MigrationMigrationSpecDumpTransferDetailsTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetails{}).Type1()):                                        MigrationMigrationSpecGoldenGateDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHub{}).Type1()):                                     MigrationMigrationSpecGoldenGateDetailsHubCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials{}).Type1()):                 MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials{}).Type1()):    MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials{}).Type1()):             MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials{}).Type1()):             MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsSettings{}).Type1()):                                MigrationMigrationSpecGoldenGateDetailsSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsSettingsExtract{}).Type1()):                         MigrationMigrationSpecGoldenGateDetailsSettingsExtractCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsSettingsReplicat{}).Type1()):                        MigrationMigrationSpecGoldenGateDetailsSettingsReplicatCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecVaultDetails{}).Type1()):                                             MigrationMigrationSpecVaultDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PluggableDatabaseSpecConnectionStrings{}).Type1()):                                         PluggableDatabaseSpecConnectionStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PluggableDatabasesLocalCloneSpecConnectionStrings{}).Type1()):                              PluggableDatabasesLocalCloneSpecConnectionStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PluggableDatabasesRemoteCloneSpecConnectionStrings{}).Type1()):                             PluggableDatabasesRemoteCloneSpecConnectionStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent{}).Type1()):                       ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword{}).Type1()):                      ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecRelatedResource{}).Type1()):                                ToolsDatabaseToolsConnectionSpecRelatedResourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecUserPassword{}).Type1()):                                   ToolsDatabaseToolsConnectionSpecUserPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration{}).Type1()):            ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfigurationCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecBackupConfig{}).Type1()):                                    AutonomousContainerDatabaseSpecBackupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails{}).Type1()):            AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecMaintenanceWindow{}).Type1()):                               AutonomousContainerDatabaseSpecMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecMaintenanceWindowDetails{}).Type1()):                        AutonomousContainerDatabaseSpecMaintenanceWindowDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig{}).Type1()):     AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecApexDetails{}).Type1()):                                              AutonomousDatabaseSpecApexDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecBackupConfig{}).Type1()):                                             AutonomousDatabaseSpecBackupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecConnectionStrings{}).Type1()):                                        AutonomousDatabaseSpecConnectionStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecConnectionUrls{}).Type1()):                                           AutonomousDatabaseSpecConnectionUrlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecScheduledOperationsDayOfWeek{}).Type1()):                             AutonomousDatabaseSpecScheduledOperationsDayOfWeekCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecStandbyDb{}).Type1()):                                                AutonomousDatabaseSpecStandbyDbCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousExadataInfrastructureSpecMaintenanceWindow{}).Type1()):                           AutonomousExadataInfrastructureSpecMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutonomousExadataInfrastructureSpecMaintenanceWindowDetails{}).Type1()):                    AutonomousExadataInfrastructureSpecMaintenanceWindowDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackupDestinationSpecMountTypeDetails{}).Type1()):                                          BackupDestinationSpecMountTypeDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CloudDatabaseManagementSpecCredentialdetails{}).Type1()):                                   CloudDatabaseManagementSpecCredentialdetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CloudExadataInfrastructureSpecMaintenanceWindow{}).Type1()):                                CloudExadataInfrastructureSpecMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CloudVmClusterSpecIormConfigCache{}).Type1()):                                              CloudVmClusterSpecIormConfigCacheCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecConnectionStrings{}).Type1()):                                                  DatabaseSpecConnectionStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDatabase{}).Type1()):                                                           DatabaseSpecDatabaseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDatabaseDbBackupConfig{}).Type1()):                                             DatabaseSpecDatabaseDbBackupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDatabaseManagementConfig{}).Type1()):                                           DatabaseSpecDatabaseManagementConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDbBackupConfig{}).Type1()):                                                     DatabaseSpecDbBackupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseUpgradeSpecConnectionStrings{}).Type1()):                                           DatabaseUpgradeSpecConnectionStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseUpgradeSpecDatabaseUpgradeSourceDetails{}).Type1()):                                DatabaseUpgradeSpecDatabaseUpgradeSourceDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseUpgradeSpecDbBackupConfig{}).Type1()):                                              DatabaseUpgradeSpecDbBackupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbHomeSpecDatabase{}).Type1()):                                                             DbHomeSpecDatabaseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbHomeSpecDatabaseDbBackupConfig{}).Type1()):                                               DbHomeSpecDatabaseDbBackupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbHome{}).Type1()):                                                             DbSystemSpecDbHomeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbHomeDatabase{}).Type1()):                                                     DbSystemSpecDbHomeDatabaseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbHomeDatabaseDbBackupConfig{}).Type1()):                                       DbSystemSpecDbHomeDatabaseDbBackupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbSystemOptions{}).Type1()):                                                    DbSystemSpecDbSystemOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecIormConfigCache{}).Type1()):                                                    DbSystemSpecIormConfigCacheCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecMaintenanceWindow{}).Type1()):                                                  DbSystemSpecMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecMaintenanceWindowDetails{}).Type1()):                                           DbSystemSpecMaintenanceWindowDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExadataInfrastructureSpecMaintenanceWindow{}).Type1()):                                     ExadataInfrastructureSpecMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExadataInfrastructureStorageSpecMaintenanceWindow{}).Type1()):                              ExadataInfrastructureStorageSpecMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExternalContainerDatabaseSpecDatabaseManagementConfig{}).Type1()):                          ExternalContainerDatabaseSpecDatabaseManagementConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExternalDatabaseConnectorSpecConnectionCredentials{}).Type1()):                             ExternalDatabaseConnectorSpecConnectionCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExternalDatabaseConnectorSpecConnectionString{}).Type1()):                                  ExternalDatabaseConnectorSpecConnectionStringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExternalNonContainerDatabaseSpecDatabaseManagementConfig{}).Type1()):                       ExternalNonContainerDatabaseSpecDatabaseManagementConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExternalNonContainerDatabaseSpecOperationsInsightsConfig{}).Type1()):                       ExternalNonContainerDatabaseSpecOperationsInsightsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExternalPluggableDatabaseSpecDatabaseManagementConfig{}).Type1()):                          ExternalPluggableDatabaseSpecDatabaseManagementConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ExternalPluggableDatabaseSpecOperationsInsightsConfig{}).Type1()):                          ExternalPluggableDatabaseSpecOperationsInsightsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KeyStoreSpecTypeDetails{}).Type1()):                                                        KeyStoreSpecTypeDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MaintenanceRunSpecEstimatedPatchingTime{}).Type1()):                                        MaintenanceRunSpecEstimatedPatchingTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials{}).Type1()):               ManagementManagedDatabasesChangeDatabaseParameterSpecCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementManagedDatabasesResetDatabaseParameterSpecCredentials{}).Type1()):                ManagementManagedDatabasesResetDatabaseParameterSpecCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecAdminCredentials{}).Type1()):                                        MigrationConnectionSpecAdminCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecConnectDescriptor{}).Type1()):                                       MigrationConnectionSpecConnectDescriptorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecPrivateEndpoint{}).Type1()):                                         MigrationConnectionSpecPrivateEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecSshDetails{}).Type1()):                                              MigrationConnectionSpecSshDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecVaultDetails{}).Type1()):                                            MigrationConnectionSpecVaultDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationJobSpecProgress{}).Type1()):                                                       MigrationJobSpecProgressCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationJobSpecProgressPhasesLogLocation{}).Type1()):                                      MigrationJobSpecProgressPhasesLogLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecAdvisorSettings{}).Type1()):                                          MigrationMigrationSpecAdvisorSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetails{}).Type1()):                                MigrationMigrationSpecDataTransferMediumDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails{}).Type1()):             MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket{}).Type1()): MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucketCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails{}).Type1()):            MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettings{}).Type1()):                                         MigrationMigrationSpecDatapumpSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettingsDataPumpParameters{}).Type1()):                       MigrationMigrationSpecDatapumpSettingsDataPumpParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettingsExportDirectoryObject{}).Type1()):                    MigrationMigrationSpecDatapumpSettingsExportDirectoryObjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettingsImportDirectoryObject{}).Type1()):                    MigrationMigrationSpecDatapumpSettingsImportDirectoryObjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDumpTransferDetails{}).Type1()):                                      MigrationMigrationSpecDumpTransferDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDumpTransferDetailsSource{}).Type1()):                                MigrationMigrationSpecDumpTransferDetailsSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDumpTransferDetailsTarget{}).Type1()):                                MigrationMigrationSpecDumpTransferDetailsTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetails{}).Type1()):                                        MigrationMigrationSpecGoldenGateDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHub{}).Type1()):                                     MigrationMigrationSpecGoldenGateDetailsHubCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials{}).Type1()):                 MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials{}).Type1()):    MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials{}).Type1()):             MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials{}).Type1()):             MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsSettings{}).Type1()):                                MigrationMigrationSpecGoldenGateDetailsSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsSettingsExtract{}).Type1()):                         MigrationMigrationSpecGoldenGateDetailsSettingsExtractCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsSettingsReplicat{}).Type1()):                        MigrationMigrationSpecGoldenGateDetailsSettingsReplicatCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecVaultDetails{}).Type1()):                                             MigrationMigrationSpecVaultDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PluggableDatabaseSpecConnectionStrings{}).Type1()):                                         PluggableDatabaseSpecConnectionStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PluggableDatabasesLocalCloneSpecConnectionStrings{}).Type1()):                              PluggableDatabasesLocalCloneSpecConnectionStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PluggableDatabasesRemoteCloneSpecConnectionStrings{}).Type1()):                             PluggableDatabasesRemoteCloneSpecConnectionStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent{}).Type1()):                       ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword{}).Type1()):                      ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecRelatedResource{}).Type1()):                                ToolsDatabaseToolsConnectionSpecRelatedResourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecUserPassword{}).Type1()):                                   ToolsDatabaseToolsConnectionSpecUserPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration{}).Type1()):            ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfigurationCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AutonomousContainerDatabaseSpecBackupConfigCodec struct {
}

func (AutonomousContainerDatabaseSpecBackupConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutonomousContainerDatabaseSpecBackupConfig)(ptr) == nil
}

func (AutonomousContainerDatabaseSpecBackupConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutonomousContainerDatabaseSpecBackupConfig)(ptr)
	var objs []AutonomousContainerDatabaseSpecBackupConfig
	if obj != nil {
		objs = []AutonomousContainerDatabaseSpecBackupConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecBackupConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutonomousContainerDatabaseSpecBackupConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutonomousContainerDatabaseSpecBackupConfig)(ptr) = AutonomousContainerDatabaseSpecBackupConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutonomousContainerDatabaseSpecBackupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecBackupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutonomousContainerDatabaseSpecBackupConfig)(ptr) = objs[0]
			} else {
				*(*AutonomousContainerDatabaseSpecBackupConfig)(ptr) = AutonomousContainerDatabaseSpecBackupConfig{}
			}
		} else {
			*(*AutonomousContainerDatabaseSpecBackupConfig)(ptr) = AutonomousContainerDatabaseSpecBackupConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutonomousContainerDatabaseSpecBackupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecBackupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutonomousContainerDatabaseSpecBackupConfig)(ptr) = obj
		} else {
			*(*AutonomousContainerDatabaseSpecBackupConfig)(ptr) = AutonomousContainerDatabaseSpecBackupConfig{}
		}
	default:
		iter.ReportError("decode AutonomousContainerDatabaseSpecBackupConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetailsCodec struct {
}

func (AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails)(ptr) == nil
}

func (AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails)(ptr)
	var objs []AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails
	if obj != nil {
		objs = []AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails)(ptr) = AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails)(ptr) = objs[0]
			} else {
				*(*AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails)(ptr) = AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails{}
			}
		} else {
			*(*AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails)(ptr) = AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails)(ptr) = obj
		} else {
			*(*AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails)(ptr) = AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails{}
		}
	default:
		iter.ReportError("decode AutonomousContainerDatabaseSpecBackupConfigBackupDestinationDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutonomousContainerDatabaseSpecMaintenanceWindowCodec struct {
}

func (AutonomousContainerDatabaseSpecMaintenanceWindowCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutonomousContainerDatabaseSpecMaintenanceWindow)(ptr) == nil
}

func (AutonomousContainerDatabaseSpecMaintenanceWindowCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutonomousContainerDatabaseSpecMaintenanceWindow)(ptr)
	var objs []AutonomousContainerDatabaseSpecMaintenanceWindow
	if obj != nil {
		objs = []AutonomousContainerDatabaseSpecMaintenanceWindow{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecMaintenanceWindow{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutonomousContainerDatabaseSpecMaintenanceWindowCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutonomousContainerDatabaseSpecMaintenanceWindow)(ptr) = AutonomousContainerDatabaseSpecMaintenanceWindow{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutonomousContainerDatabaseSpecMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutonomousContainerDatabaseSpecMaintenanceWindow)(ptr) = objs[0]
			} else {
				*(*AutonomousContainerDatabaseSpecMaintenanceWindow)(ptr) = AutonomousContainerDatabaseSpecMaintenanceWindow{}
			}
		} else {
			*(*AutonomousContainerDatabaseSpecMaintenanceWindow)(ptr) = AutonomousContainerDatabaseSpecMaintenanceWindow{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutonomousContainerDatabaseSpecMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutonomousContainerDatabaseSpecMaintenanceWindow)(ptr) = obj
		} else {
			*(*AutonomousContainerDatabaseSpecMaintenanceWindow)(ptr) = AutonomousContainerDatabaseSpecMaintenanceWindow{}
		}
	default:
		iter.ReportError("decode AutonomousContainerDatabaseSpecMaintenanceWindow", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutonomousContainerDatabaseSpecMaintenanceWindowDetailsCodec struct {
}

func (AutonomousContainerDatabaseSpecMaintenanceWindowDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutonomousContainerDatabaseSpecMaintenanceWindowDetails)(ptr) == nil
}

func (AutonomousContainerDatabaseSpecMaintenanceWindowDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutonomousContainerDatabaseSpecMaintenanceWindowDetails)(ptr)
	var objs []AutonomousContainerDatabaseSpecMaintenanceWindowDetails
	if obj != nil {
		objs = []AutonomousContainerDatabaseSpecMaintenanceWindowDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecMaintenanceWindowDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutonomousContainerDatabaseSpecMaintenanceWindowDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutonomousContainerDatabaseSpecMaintenanceWindowDetails)(ptr) = AutonomousContainerDatabaseSpecMaintenanceWindowDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutonomousContainerDatabaseSpecMaintenanceWindowDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecMaintenanceWindowDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutonomousContainerDatabaseSpecMaintenanceWindowDetails)(ptr) = objs[0]
			} else {
				*(*AutonomousContainerDatabaseSpecMaintenanceWindowDetails)(ptr) = AutonomousContainerDatabaseSpecMaintenanceWindowDetails{}
			}
		} else {
			*(*AutonomousContainerDatabaseSpecMaintenanceWindowDetails)(ptr) = AutonomousContainerDatabaseSpecMaintenanceWindowDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutonomousContainerDatabaseSpecMaintenanceWindowDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecMaintenanceWindowDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutonomousContainerDatabaseSpecMaintenanceWindowDetails)(ptr) = obj
		} else {
			*(*AutonomousContainerDatabaseSpecMaintenanceWindowDetails)(ptr) = AutonomousContainerDatabaseSpecMaintenanceWindowDetails{}
		}
	default:
		iter.ReportError("decode AutonomousContainerDatabaseSpecMaintenanceWindowDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfigCodec struct {
}

func (AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig)(ptr) == nil
}

func (AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig)(ptr)
	var objs []AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig
	if obj != nil {
		objs = []AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig)(ptr) = AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig)(ptr) = objs[0]
			} else {
				*(*AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig)(ptr) = AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig{}
			}
		} else {
			*(*AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig)(ptr) = AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig)(ptr) = obj
		} else {
			*(*AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig)(ptr) = AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig{}
		}
	default:
		iter.ReportError("decode AutonomousContainerDatabaseSpecPeerAutonomousContainerDatabaseBackupConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutonomousDatabaseSpecApexDetailsCodec struct {
}

func (AutonomousDatabaseSpecApexDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutonomousDatabaseSpecApexDetails)(ptr) == nil
}

func (AutonomousDatabaseSpecApexDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutonomousDatabaseSpecApexDetails)(ptr)
	var objs []AutonomousDatabaseSpecApexDetails
	if obj != nil {
		objs = []AutonomousDatabaseSpecApexDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecApexDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutonomousDatabaseSpecApexDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutonomousDatabaseSpecApexDetails)(ptr) = AutonomousDatabaseSpecApexDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutonomousDatabaseSpecApexDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecApexDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutonomousDatabaseSpecApexDetails)(ptr) = objs[0]
			} else {
				*(*AutonomousDatabaseSpecApexDetails)(ptr) = AutonomousDatabaseSpecApexDetails{}
			}
		} else {
			*(*AutonomousDatabaseSpecApexDetails)(ptr) = AutonomousDatabaseSpecApexDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutonomousDatabaseSpecApexDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecApexDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutonomousDatabaseSpecApexDetails)(ptr) = obj
		} else {
			*(*AutonomousDatabaseSpecApexDetails)(ptr) = AutonomousDatabaseSpecApexDetails{}
		}
	default:
		iter.ReportError("decode AutonomousDatabaseSpecApexDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutonomousDatabaseSpecBackupConfigCodec struct {
}

func (AutonomousDatabaseSpecBackupConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutonomousDatabaseSpecBackupConfig)(ptr) == nil
}

func (AutonomousDatabaseSpecBackupConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutonomousDatabaseSpecBackupConfig)(ptr)
	var objs []AutonomousDatabaseSpecBackupConfig
	if obj != nil {
		objs = []AutonomousDatabaseSpecBackupConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecBackupConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutonomousDatabaseSpecBackupConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutonomousDatabaseSpecBackupConfig)(ptr) = AutonomousDatabaseSpecBackupConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutonomousDatabaseSpecBackupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecBackupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutonomousDatabaseSpecBackupConfig)(ptr) = objs[0]
			} else {
				*(*AutonomousDatabaseSpecBackupConfig)(ptr) = AutonomousDatabaseSpecBackupConfig{}
			}
		} else {
			*(*AutonomousDatabaseSpecBackupConfig)(ptr) = AutonomousDatabaseSpecBackupConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutonomousDatabaseSpecBackupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecBackupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutonomousDatabaseSpecBackupConfig)(ptr) = obj
		} else {
			*(*AutonomousDatabaseSpecBackupConfig)(ptr) = AutonomousDatabaseSpecBackupConfig{}
		}
	default:
		iter.ReportError("decode AutonomousDatabaseSpecBackupConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutonomousDatabaseSpecConnectionStringsCodec struct {
}

func (AutonomousDatabaseSpecConnectionStringsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutonomousDatabaseSpecConnectionStrings)(ptr) == nil
}

func (AutonomousDatabaseSpecConnectionStringsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutonomousDatabaseSpecConnectionStrings)(ptr)
	var objs []AutonomousDatabaseSpecConnectionStrings
	if obj != nil {
		objs = []AutonomousDatabaseSpecConnectionStrings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecConnectionStrings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutonomousDatabaseSpecConnectionStringsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutonomousDatabaseSpecConnectionStrings)(ptr) = AutonomousDatabaseSpecConnectionStrings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutonomousDatabaseSpecConnectionStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecConnectionStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutonomousDatabaseSpecConnectionStrings)(ptr) = objs[0]
			} else {
				*(*AutonomousDatabaseSpecConnectionStrings)(ptr) = AutonomousDatabaseSpecConnectionStrings{}
			}
		} else {
			*(*AutonomousDatabaseSpecConnectionStrings)(ptr) = AutonomousDatabaseSpecConnectionStrings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutonomousDatabaseSpecConnectionStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecConnectionStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutonomousDatabaseSpecConnectionStrings)(ptr) = obj
		} else {
			*(*AutonomousDatabaseSpecConnectionStrings)(ptr) = AutonomousDatabaseSpecConnectionStrings{}
		}
	default:
		iter.ReportError("decode AutonomousDatabaseSpecConnectionStrings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutonomousDatabaseSpecConnectionUrlsCodec struct {
}

func (AutonomousDatabaseSpecConnectionUrlsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutonomousDatabaseSpecConnectionUrls)(ptr) == nil
}

func (AutonomousDatabaseSpecConnectionUrlsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutonomousDatabaseSpecConnectionUrls)(ptr)
	var objs []AutonomousDatabaseSpecConnectionUrls
	if obj != nil {
		objs = []AutonomousDatabaseSpecConnectionUrls{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecConnectionUrls{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutonomousDatabaseSpecConnectionUrlsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutonomousDatabaseSpecConnectionUrls)(ptr) = AutonomousDatabaseSpecConnectionUrls{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutonomousDatabaseSpecConnectionUrls

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecConnectionUrls{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutonomousDatabaseSpecConnectionUrls)(ptr) = objs[0]
			} else {
				*(*AutonomousDatabaseSpecConnectionUrls)(ptr) = AutonomousDatabaseSpecConnectionUrls{}
			}
		} else {
			*(*AutonomousDatabaseSpecConnectionUrls)(ptr) = AutonomousDatabaseSpecConnectionUrls{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutonomousDatabaseSpecConnectionUrls

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecConnectionUrls{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutonomousDatabaseSpecConnectionUrls)(ptr) = obj
		} else {
			*(*AutonomousDatabaseSpecConnectionUrls)(ptr) = AutonomousDatabaseSpecConnectionUrls{}
		}
	default:
		iter.ReportError("decode AutonomousDatabaseSpecConnectionUrls", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutonomousDatabaseSpecScheduledOperationsDayOfWeekCodec struct {
}

func (AutonomousDatabaseSpecScheduledOperationsDayOfWeekCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutonomousDatabaseSpecScheduledOperationsDayOfWeek)(ptr) == nil
}

func (AutonomousDatabaseSpecScheduledOperationsDayOfWeekCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutonomousDatabaseSpecScheduledOperationsDayOfWeek)(ptr)
	var objs []AutonomousDatabaseSpecScheduledOperationsDayOfWeek
	if obj != nil {
		objs = []AutonomousDatabaseSpecScheduledOperationsDayOfWeek{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecScheduledOperationsDayOfWeek{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutonomousDatabaseSpecScheduledOperationsDayOfWeekCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutonomousDatabaseSpecScheduledOperationsDayOfWeek)(ptr) = AutonomousDatabaseSpecScheduledOperationsDayOfWeek{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutonomousDatabaseSpecScheduledOperationsDayOfWeek

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecScheduledOperationsDayOfWeek{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutonomousDatabaseSpecScheduledOperationsDayOfWeek)(ptr) = objs[0]
			} else {
				*(*AutonomousDatabaseSpecScheduledOperationsDayOfWeek)(ptr) = AutonomousDatabaseSpecScheduledOperationsDayOfWeek{}
			}
		} else {
			*(*AutonomousDatabaseSpecScheduledOperationsDayOfWeek)(ptr) = AutonomousDatabaseSpecScheduledOperationsDayOfWeek{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutonomousDatabaseSpecScheduledOperationsDayOfWeek

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecScheduledOperationsDayOfWeek{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutonomousDatabaseSpecScheduledOperationsDayOfWeek)(ptr) = obj
		} else {
			*(*AutonomousDatabaseSpecScheduledOperationsDayOfWeek)(ptr) = AutonomousDatabaseSpecScheduledOperationsDayOfWeek{}
		}
	default:
		iter.ReportError("decode AutonomousDatabaseSpecScheduledOperationsDayOfWeek", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutonomousDatabaseSpecStandbyDbCodec struct {
}

func (AutonomousDatabaseSpecStandbyDbCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutonomousDatabaseSpecStandbyDb)(ptr) == nil
}

func (AutonomousDatabaseSpecStandbyDbCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutonomousDatabaseSpecStandbyDb)(ptr)
	var objs []AutonomousDatabaseSpecStandbyDb
	if obj != nil {
		objs = []AutonomousDatabaseSpecStandbyDb{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecStandbyDb{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutonomousDatabaseSpecStandbyDbCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutonomousDatabaseSpecStandbyDb)(ptr) = AutonomousDatabaseSpecStandbyDb{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutonomousDatabaseSpecStandbyDb

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecStandbyDb{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutonomousDatabaseSpecStandbyDb)(ptr) = objs[0]
			} else {
				*(*AutonomousDatabaseSpecStandbyDb)(ptr) = AutonomousDatabaseSpecStandbyDb{}
			}
		} else {
			*(*AutonomousDatabaseSpecStandbyDb)(ptr) = AutonomousDatabaseSpecStandbyDb{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutonomousDatabaseSpecStandbyDb

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousDatabaseSpecStandbyDb{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutonomousDatabaseSpecStandbyDb)(ptr) = obj
		} else {
			*(*AutonomousDatabaseSpecStandbyDb)(ptr) = AutonomousDatabaseSpecStandbyDb{}
		}
	default:
		iter.ReportError("decode AutonomousDatabaseSpecStandbyDb", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutonomousExadataInfrastructureSpecMaintenanceWindowCodec struct {
}

func (AutonomousExadataInfrastructureSpecMaintenanceWindowCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutonomousExadataInfrastructureSpecMaintenanceWindow)(ptr) == nil
}

func (AutonomousExadataInfrastructureSpecMaintenanceWindowCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutonomousExadataInfrastructureSpecMaintenanceWindow)(ptr)
	var objs []AutonomousExadataInfrastructureSpecMaintenanceWindow
	if obj != nil {
		objs = []AutonomousExadataInfrastructureSpecMaintenanceWindow{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousExadataInfrastructureSpecMaintenanceWindow{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutonomousExadataInfrastructureSpecMaintenanceWindowCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutonomousExadataInfrastructureSpecMaintenanceWindow)(ptr) = AutonomousExadataInfrastructureSpecMaintenanceWindow{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutonomousExadataInfrastructureSpecMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousExadataInfrastructureSpecMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutonomousExadataInfrastructureSpecMaintenanceWindow)(ptr) = objs[0]
			} else {
				*(*AutonomousExadataInfrastructureSpecMaintenanceWindow)(ptr) = AutonomousExadataInfrastructureSpecMaintenanceWindow{}
			}
		} else {
			*(*AutonomousExadataInfrastructureSpecMaintenanceWindow)(ptr) = AutonomousExadataInfrastructureSpecMaintenanceWindow{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutonomousExadataInfrastructureSpecMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousExadataInfrastructureSpecMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutonomousExadataInfrastructureSpecMaintenanceWindow)(ptr) = obj
		} else {
			*(*AutonomousExadataInfrastructureSpecMaintenanceWindow)(ptr) = AutonomousExadataInfrastructureSpecMaintenanceWindow{}
		}
	default:
		iter.ReportError("decode AutonomousExadataInfrastructureSpecMaintenanceWindow", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutonomousExadataInfrastructureSpecMaintenanceWindowDetailsCodec struct {
}

func (AutonomousExadataInfrastructureSpecMaintenanceWindowDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutonomousExadataInfrastructureSpecMaintenanceWindowDetails)(ptr) == nil
}

func (AutonomousExadataInfrastructureSpecMaintenanceWindowDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutonomousExadataInfrastructureSpecMaintenanceWindowDetails)(ptr)
	var objs []AutonomousExadataInfrastructureSpecMaintenanceWindowDetails
	if obj != nil {
		objs = []AutonomousExadataInfrastructureSpecMaintenanceWindowDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousExadataInfrastructureSpecMaintenanceWindowDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutonomousExadataInfrastructureSpecMaintenanceWindowDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutonomousExadataInfrastructureSpecMaintenanceWindowDetails)(ptr) = AutonomousExadataInfrastructureSpecMaintenanceWindowDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutonomousExadataInfrastructureSpecMaintenanceWindowDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousExadataInfrastructureSpecMaintenanceWindowDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutonomousExadataInfrastructureSpecMaintenanceWindowDetails)(ptr) = objs[0]
			} else {
				*(*AutonomousExadataInfrastructureSpecMaintenanceWindowDetails)(ptr) = AutonomousExadataInfrastructureSpecMaintenanceWindowDetails{}
			}
		} else {
			*(*AutonomousExadataInfrastructureSpecMaintenanceWindowDetails)(ptr) = AutonomousExadataInfrastructureSpecMaintenanceWindowDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutonomousExadataInfrastructureSpecMaintenanceWindowDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutonomousExadataInfrastructureSpecMaintenanceWindowDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutonomousExadataInfrastructureSpecMaintenanceWindowDetails)(ptr) = obj
		} else {
			*(*AutonomousExadataInfrastructureSpecMaintenanceWindowDetails)(ptr) = AutonomousExadataInfrastructureSpecMaintenanceWindowDetails{}
		}
	default:
		iter.ReportError("decode AutonomousExadataInfrastructureSpecMaintenanceWindowDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackupDestinationSpecMountTypeDetailsCodec struct {
}

func (BackupDestinationSpecMountTypeDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackupDestinationSpecMountTypeDetails)(ptr) == nil
}

func (BackupDestinationSpecMountTypeDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackupDestinationSpecMountTypeDetails)(ptr)
	var objs []BackupDestinationSpecMountTypeDetails
	if obj != nil {
		objs = []BackupDestinationSpecMountTypeDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackupDestinationSpecMountTypeDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackupDestinationSpecMountTypeDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackupDestinationSpecMountTypeDetails)(ptr) = BackupDestinationSpecMountTypeDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackupDestinationSpecMountTypeDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackupDestinationSpecMountTypeDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackupDestinationSpecMountTypeDetails)(ptr) = objs[0]
			} else {
				*(*BackupDestinationSpecMountTypeDetails)(ptr) = BackupDestinationSpecMountTypeDetails{}
			}
		} else {
			*(*BackupDestinationSpecMountTypeDetails)(ptr) = BackupDestinationSpecMountTypeDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackupDestinationSpecMountTypeDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackupDestinationSpecMountTypeDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackupDestinationSpecMountTypeDetails)(ptr) = obj
		} else {
			*(*BackupDestinationSpecMountTypeDetails)(ptr) = BackupDestinationSpecMountTypeDetails{}
		}
	default:
		iter.ReportError("decode BackupDestinationSpecMountTypeDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CloudDatabaseManagementSpecCredentialdetailsCodec struct {
}

func (CloudDatabaseManagementSpecCredentialdetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CloudDatabaseManagementSpecCredentialdetails)(ptr) == nil
}

func (CloudDatabaseManagementSpecCredentialdetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CloudDatabaseManagementSpecCredentialdetails)(ptr)
	var objs []CloudDatabaseManagementSpecCredentialdetails
	if obj != nil {
		objs = []CloudDatabaseManagementSpecCredentialdetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CloudDatabaseManagementSpecCredentialdetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CloudDatabaseManagementSpecCredentialdetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CloudDatabaseManagementSpecCredentialdetails)(ptr) = CloudDatabaseManagementSpecCredentialdetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CloudDatabaseManagementSpecCredentialdetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CloudDatabaseManagementSpecCredentialdetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CloudDatabaseManagementSpecCredentialdetails)(ptr) = objs[0]
			} else {
				*(*CloudDatabaseManagementSpecCredentialdetails)(ptr) = CloudDatabaseManagementSpecCredentialdetails{}
			}
		} else {
			*(*CloudDatabaseManagementSpecCredentialdetails)(ptr) = CloudDatabaseManagementSpecCredentialdetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CloudDatabaseManagementSpecCredentialdetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CloudDatabaseManagementSpecCredentialdetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CloudDatabaseManagementSpecCredentialdetails)(ptr) = obj
		} else {
			*(*CloudDatabaseManagementSpecCredentialdetails)(ptr) = CloudDatabaseManagementSpecCredentialdetails{}
		}
	default:
		iter.ReportError("decode CloudDatabaseManagementSpecCredentialdetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CloudExadataInfrastructureSpecMaintenanceWindowCodec struct {
}

func (CloudExadataInfrastructureSpecMaintenanceWindowCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CloudExadataInfrastructureSpecMaintenanceWindow)(ptr) == nil
}

func (CloudExadataInfrastructureSpecMaintenanceWindowCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CloudExadataInfrastructureSpecMaintenanceWindow)(ptr)
	var objs []CloudExadataInfrastructureSpecMaintenanceWindow
	if obj != nil {
		objs = []CloudExadataInfrastructureSpecMaintenanceWindow{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CloudExadataInfrastructureSpecMaintenanceWindow{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CloudExadataInfrastructureSpecMaintenanceWindowCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CloudExadataInfrastructureSpecMaintenanceWindow)(ptr) = CloudExadataInfrastructureSpecMaintenanceWindow{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CloudExadataInfrastructureSpecMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CloudExadataInfrastructureSpecMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CloudExadataInfrastructureSpecMaintenanceWindow)(ptr) = objs[0]
			} else {
				*(*CloudExadataInfrastructureSpecMaintenanceWindow)(ptr) = CloudExadataInfrastructureSpecMaintenanceWindow{}
			}
		} else {
			*(*CloudExadataInfrastructureSpecMaintenanceWindow)(ptr) = CloudExadataInfrastructureSpecMaintenanceWindow{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CloudExadataInfrastructureSpecMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CloudExadataInfrastructureSpecMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CloudExadataInfrastructureSpecMaintenanceWindow)(ptr) = obj
		} else {
			*(*CloudExadataInfrastructureSpecMaintenanceWindow)(ptr) = CloudExadataInfrastructureSpecMaintenanceWindow{}
		}
	default:
		iter.ReportError("decode CloudExadataInfrastructureSpecMaintenanceWindow", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CloudVmClusterSpecIormConfigCacheCodec struct {
}

func (CloudVmClusterSpecIormConfigCacheCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CloudVmClusterSpecIormConfigCache)(ptr) == nil
}

func (CloudVmClusterSpecIormConfigCacheCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CloudVmClusterSpecIormConfigCache)(ptr)
	var objs []CloudVmClusterSpecIormConfigCache
	if obj != nil {
		objs = []CloudVmClusterSpecIormConfigCache{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CloudVmClusterSpecIormConfigCache{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CloudVmClusterSpecIormConfigCacheCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CloudVmClusterSpecIormConfigCache)(ptr) = CloudVmClusterSpecIormConfigCache{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CloudVmClusterSpecIormConfigCache

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CloudVmClusterSpecIormConfigCache{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CloudVmClusterSpecIormConfigCache)(ptr) = objs[0]
			} else {
				*(*CloudVmClusterSpecIormConfigCache)(ptr) = CloudVmClusterSpecIormConfigCache{}
			}
		} else {
			*(*CloudVmClusterSpecIormConfigCache)(ptr) = CloudVmClusterSpecIormConfigCache{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CloudVmClusterSpecIormConfigCache

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CloudVmClusterSpecIormConfigCache{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CloudVmClusterSpecIormConfigCache)(ptr) = obj
		} else {
			*(*CloudVmClusterSpecIormConfigCache)(ptr) = CloudVmClusterSpecIormConfigCache{}
		}
	default:
		iter.ReportError("decode CloudVmClusterSpecIormConfigCache", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatabaseSpecConnectionStringsCodec struct {
}

func (DatabaseSpecConnectionStringsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatabaseSpecConnectionStrings)(ptr) == nil
}

func (DatabaseSpecConnectionStringsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatabaseSpecConnectionStrings)(ptr)
	var objs []DatabaseSpecConnectionStrings
	if obj != nil {
		objs = []DatabaseSpecConnectionStrings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecConnectionStrings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatabaseSpecConnectionStringsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatabaseSpecConnectionStrings)(ptr) = DatabaseSpecConnectionStrings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatabaseSpecConnectionStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecConnectionStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatabaseSpecConnectionStrings)(ptr) = objs[0]
			} else {
				*(*DatabaseSpecConnectionStrings)(ptr) = DatabaseSpecConnectionStrings{}
			}
		} else {
			*(*DatabaseSpecConnectionStrings)(ptr) = DatabaseSpecConnectionStrings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DatabaseSpecConnectionStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecConnectionStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DatabaseSpecConnectionStrings)(ptr) = obj
		} else {
			*(*DatabaseSpecConnectionStrings)(ptr) = DatabaseSpecConnectionStrings{}
		}
	default:
		iter.ReportError("decode DatabaseSpecConnectionStrings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatabaseSpecDatabaseCodec struct {
}

func (DatabaseSpecDatabaseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatabaseSpecDatabase)(ptr) == nil
}

func (DatabaseSpecDatabaseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatabaseSpecDatabase)(ptr)
	var objs []DatabaseSpecDatabase
	if obj != nil {
		objs = []DatabaseSpecDatabase{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDatabase{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatabaseSpecDatabaseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatabaseSpecDatabase)(ptr) = DatabaseSpecDatabase{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatabaseSpecDatabase

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDatabase{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatabaseSpecDatabase)(ptr) = objs[0]
			} else {
				*(*DatabaseSpecDatabase)(ptr) = DatabaseSpecDatabase{}
			}
		} else {
			*(*DatabaseSpecDatabase)(ptr) = DatabaseSpecDatabase{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DatabaseSpecDatabase

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDatabase{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DatabaseSpecDatabase)(ptr) = obj
		} else {
			*(*DatabaseSpecDatabase)(ptr) = DatabaseSpecDatabase{}
		}
	default:
		iter.ReportError("decode DatabaseSpecDatabase", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatabaseSpecDatabaseDbBackupConfigCodec struct {
}

func (DatabaseSpecDatabaseDbBackupConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatabaseSpecDatabaseDbBackupConfig)(ptr) == nil
}

func (DatabaseSpecDatabaseDbBackupConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatabaseSpecDatabaseDbBackupConfig)(ptr)
	var objs []DatabaseSpecDatabaseDbBackupConfig
	if obj != nil {
		objs = []DatabaseSpecDatabaseDbBackupConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDatabaseDbBackupConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatabaseSpecDatabaseDbBackupConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatabaseSpecDatabaseDbBackupConfig)(ptr) = DatabaseSpecDatabaseDbBackupConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatabaseSpecDatabaseDbBackupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDatabaseDbBackupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatabaseSpecDatabaseDbBackupConfig)(ptr) = objs[0]
			} else {
				*(*DatabaseSpecDatabaseDbBackupConfig)(ptr) = DatabaseSpecDatabaseDbBackupConfig{}
			}
		} else {
			*(*DatabaseSpecDatabaseDbBackupConfig)(ptr) = DatabaseSpecDatabaseDbBackupConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DatabaseSpecDatabaseDbBackupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDatabaseDbBackupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DatabaseSpecDatabaseDbBackupConfig)(ptr) = obj
		} else {
			*(*DatabaseSpecDatabaseDbBackupConfig)(ptr) = DatabaseSpecDatabaseDbBackupConfig{}
		}
	default:
		iter.ReportError("decode DatabaseSpecDatabaseDbBackupConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatabaseSpecDatabaseManagementConfigCodec struct {
}

func (DatabaseSpecDatabaseManagementConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatabaseSpecDatabaseManagementConfig)(ptr) == nil
}

func (DatabaseSpecDatabaseManagementConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatabaseSpecDatabaseManagementConfig)(ptr)
	var objs []DatabaseSpecDatabaseManagementConfig
	if obj != nil {
		objs = []DatabaseSpecDatabaseManagementConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDatabaseManagementConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatabaseSpecDatabaseManagementConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatabaseSpecDatabaseManagementConfig)(ptr) = DatabaseSpecDatabaseManagementConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatabaseSpecDatabaseManagementConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDatabaseManagementConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatabaseSpecDatabaseManagementConfig)(ptr) = objs[0]
			} else {
				*(*DatabaseSpecDatabaseManagementConfig)(ptr) = DatabaseSpecDatabaseManagementConfig{}
			}
		} else {
			*(*DatabaseSpecDatabaseManagementConfig)(ptr) = DatabaseSpecDatabaseManagementConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DatabaseSpecDatabaseManagementConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDatabaseManagementConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DatabaseSpecDatabaseManagementConfig)(ptr) = obj
		} else {
			*(*DatabaseSpecDatabaseManagementConfig)(ptr) = DatabaseSpecDatabaseManagementConfig{}
		}
	default:
		iter.ReportError("decode DatabaseSpecDatabaseManagementConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatabaseSpecDbBackupConfigCodec struct {
}

func (DatabaseSpecDbBackupConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatabaseSpecDbBackupConfig)(ptr) == nil
}

func (DatabaseSpecDbBackupConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatabaseSpecDbBackupConfig)(ptr)
	var objs []DatabaseSpecDbBackupConfig
	if obj != nil {
		objs = []DatabaseSpecDbBackupConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDbBackupConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatabaseSpecDbBackupConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatabaseSpecDbBackupConfig)(ptr) = DatabaseSpecDbBackupConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatabaseSpecDbBackupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDbBackupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatabaseSpecDbBackupConfig)(ptr) = objs[0]
			} else {
				*(*DatabaseSpecDbBackupConfig)(ptr) = DatabaseSpecDbBackupConfig{}
			}
		} else {
			*(*DatabaseSpecDbBackupConfig)(ptr) = DatabaseSpecDbBackupConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DatabaseSpecDbBackupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecDbBackupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DatabaseSpecDbBackupConfig)(ptr) = obj
		} else {
			*(*DatabaseSpecDbBackupConfig)(ptr) = DatabaseSpecDbBackupConfig{}
		}
	default:
		iter.ReportError("decode DatabaseSpecDbBackupConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatabaseUpgradeSpecConnectionStringsCodec struct {
}

func (DatabaseUpgradeSpecConnectionStringsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatabaseUpgradeSpecConnectionStrings)(ptr) == nil
}

func (DatabaseUpgradeSpecConnectionStringsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatabaseUpgradeSpecConnectionStrings)(ptr)
	var objs []DatabaseUpgradeSpecConnectionStrings
	if obj != nil {
		objs = []DatabaseUpgradeSpecConnectionStrings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseUpgradeSpecConnectionStrings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatabaseUpgradeSpecConnectionStringsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatabaseUpgradeSpecConnectionStrings)(ptr) = DatabaseUpgradeSpecConnectionStrings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatabaseUpgradeSpecConnectionStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseUpgradeSpecConnectionStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatabaseUpgradeSpecConnectionStrings)(ptr) = objs[0]
			} else {
				*(*DatabaseUpgradeSpecConnectionStrings)(ptr) = DatabaseUpgradeSpecConnectionStrings{}
			}
		} else {
			*(*DatabaseUpgradeSpecConnectionStrings)(ptr) = DatabaseUpgradeSpecConnectionStrings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DatabaseUpgradeSpecConnectionStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseUpgradeSpecConnectionStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DatabaseUpgradeSpecConnectionStrings)(ptr) = obj
		} else {
			*(*DatabaseUpgradeSpecConnectionStrings)(ptr) = DatabaseUpgradeSpecConnectionStrings{}
		}
	default:
		iter.ReportError("decode DatabaseUpgradeSpecConnectionStrings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatabaseUpgradeSpecDatabaseUpgradeSourceDetailsCodec struct {
}

func (DatabaseUpgradeSpecDatabaseUpgradeSourceDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatabaseUpgradeSpecDatabaseUpgradeSourceDetails)(ptr) == nil
}

func (DatabaseUpgradeSpecDatabaseUpgradeSourceDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatabaseUpgradeSpecDatabaseUpgradeSourceDetails)(ptr)
	var objs []DatabaseUpgradeSpecDatabaseUpgradeSourceDetails
	if obj != nil {
		objs = []DatabaseUpgradeSpecDatabaseUpgradeSourceDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseUpgradeSpecDatabaseUpgradeSourceDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatabaseUpgradeSpecDatabaseUpgradeSourceDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatabaseUpgradeSpecDatabaseUpgradeSourceDetails)(ptr) = DatabaseUpgradeSpecDatabaseUpgradeSourceDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatabaseUpgradeSpecDatabaseUpgradeSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseUpgradeSpecDatabaseUpgradeSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatabaseUpgradeSpecDatabaseUpgradeSourceDetails)(ptr) = objs[0]
			} else {
				*(*DatabaseUpgradeSpecDatabaseUpgradeSourceDetails)(ptr) = DatabaseUpgradeSpecDatabaseUpgradeSourceDetails{}
			}
		} else {
			*(*DatabaseUpgradeSpecDatabaseUpgradeSourceDetails)(ptr) = DatabaseUpgradeSpecDatabaseUpgradeSourceDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DatabaseUpgradeSpecDatabaseUpgradeSourceDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseUpgradeSpecDatabaseUpgradeSourceDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DatabaseUpgradeSpecDatabaseUpgradeSourceDetails)(ptr) = obj
		} else {
			*(*DatabaseUpgradeSpecDatabaseUpgradeSourceDetails)(ptr) = DatabaseUpgradeSpecDatabaseUpgradeSourceDetails{}
		}
	default:
		iter.ReportError("decode DatabaseUpgradeSpecDatabaseUpgradeSourceDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatabaseUpgradeSpecDbBackupConfigCodec struct {
}

func (DatabaseUpgradeSpecDbBackupConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatabaseUpgradeSpecDbBackupConfig)(ptr) == nil
}

func (DatabaseUpgradeSpecDbBackupConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatabaseUpgradeSpecDbBackupConfig)(ptr)
	var objs []DatabaseUpgradeSpecDbBackupConfig
	if obj != nil {
		objs = []DatabaseUpgradeSpecDbBackupConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseUpgradeSpecDbBackupConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatabaseUpgradeSpecDbBackupConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatabaseUpgradeSpecDbBackupConfig)(ptr) = DatabaseUpgradeSpecDbBackupConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatabaseUpgradeSpecDbBackupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseUpgradeSpecDbBackupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatabaseUpgradeSpecDbBackupConfig)(ptr) = objs[0]
			} else {
				*(*DatabaseUpgradeSpecDbBackupConfig)(ptr) = DatabaseUpgradeSpecDbBackupConfig{}
			}
		} else {
			*(*DatabaseUpgradeSpecDbBackupConfig)(ptr) = DatabaseUpgradeSpecDbBackupConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DatabaseUpgradeSpecDbBackupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseUpgradeSpecDbBackupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DatabaseUpgradeSpecDbBackupConfig)(ptr) = obj
		} else {
			*(*DatabaseUpgradeSpecDbBackupConfig)(ptr) = DatabaseUpgradeSpecDbBackupConfig{}
		}
	default:
		iter.ReportError("decode DatabaseUpgradeSpecDbBackupConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DbHomeSpecDatabaseCodec struct {
}

func (DbHomeSpecDatabaseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DbHomeSpecDatabase)(ptr) == nil
}

func (DbHomeSpecDatabaseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DbHomeSpecDatabase)(ptr)
	var objs []DbHomeSpecDatabase
	if obj != nil {
		objs = []DbHomeSpecDatabase{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbHomeSpecDatabase{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DbHomeSpecDatabaseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DbHomeSpecDatabase)(ptr) = DbHomeSpecDatabase{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DbHomeSpecDatabase

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbHomeSpecDatabase{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DbHomeSpecDatabase)(ptr) = objs[0]
			} else {
				*(*DbHomeSpecDatabase)(ptr) = DbHomeSpecDatabase{}
			}
		} else {
			*(*DbHomeSpecDatabase)(ptr) = DbHomeSpecDatabase{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DbHomeSpecDatabase

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbHomeSpecDatabase{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DbHomeSpecDatabase)(ptr) = obj
		} else {
			*(*DbHomeSpecDatabase)(ptr) = DbHomeSpecDatabase{}
		}
	default:
		iter.ReportError("decode DbHomeSpecDatabase", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DbHomeSpecDatabaseDbBackupConfigCodec struct {
}

func (DbHomeSpecDatabaseDbBackupConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DbHomeSpecDatabaseDbBackupConfig)(ptr) == nil
}

func (DbHomeSpecDatabaseDbBackupConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DbHomeSpecDatabaseDbBackupConfig)(ptr)
	var objs []DbHomeSpecDatabaseDbBackupConfig
	if obj != nil {
		objs = []DbHomeSpecDatabaseDbBackupConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbHomeSpecDatabaseDbBackupConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DbHomeSpecDatabaseDbBackupConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DbHomeSpecDatabaseDbBackupConfig)(ptr) = DbHomeSpecDatabaseDbBackupConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DbHomeSpecDatabaseDbBackupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbHomeSpecDatabaseDbBackupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DbHomeSpecDatabaseDbBackupConfig)(ptr) = objs[0]
			} else {
				*(*DbHomeSpecDatabaseDbBackupConfig)(ptr) = DbHomeSpecDatabaseDbBackupConfig{}
			}
		} else {
			*(*DbHomeSpecDatabaseDbBackupConfig)(ptr) = DbHomeSpecDatabaseDbBackupConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DbHomeSpecDatabaseDbBackupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbHomeSpecDatabaseDbBackupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DbHomeSpecDatabaseDbBackupConfig)(ptr) = obj
		} else {
			*(*DbHomeSpecDatabaseDbBackupConfig)(ptr) = DbHomeSpecDatabaseDbBackupConfig{}
		}
	default:
		iter.ReportError("decode DbHomeSpecDatabaseDbBackupConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DbSystemSpecDbHomeCodec struct {
}

func (DbSystemSpecDbHomeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DbSystemSpecDbHome)(ptr) == nil
}

func (DbSystemSpecDbHomeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DbSystemSpecDbHome)(ptr)
	var objs []DbSystemSpecDbHome
	if obj != nil {
		objs = []DbSystemSpecDbHome{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbHome{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DbSystemSpecDbHomeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DbSystemSpecDbHome)(ptr) = DbSystemSpecDbHome{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DbSystemSpecDbHome

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbHome{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DbSystemSpecDbHome)(ptr) = objs[0]
			} else {
				*(*DbSystemSpecDbHome)(ptr) = DbSystemSpecDbHome{}
			}
		} else {
			*(*DbSystemSpecDbHome)(ptr) = DbSystemSpecDbHome{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DbSystemSpecDbHome

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbHome{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DbSystemSpecDbHome)(ptr) = obj
		} else {
			*(*DbSystemSpecDbHome)(ptr) = DbSystemSpecDbHome{}
		}
	default:
		iter.ReportError("decode DbSystemSpecDbHome", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DbSystemSpecDbHomeDatabaseCodec struct {
}

func (DbSystemSpecDbHomeDatabaseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DbSystemSpecDbHomeDatabase)(ptr) == nil
}

func (DbSystemSpecDbHomeDatabaseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DbSystemSpecDbHomeDatabase)(ptr)
	var objs []DbSystemSpecDbHomeDatabase
	if obj != nil {
		objs = []DbSystemSpecDbHomeDatabase{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbHomeDatabase{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DbSystemSpecDbHomeDatabaseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DbSystemSpecDbHomeDatabase)(ptr) = DbSystemSpecDbHomeDatabase{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DbSystemSpecDbHomeDatabase

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbHomeDatabase{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DbSystemSpecDbHomeDatabase)(ptr) = objs[0]
			} else {
				*(*DbSystemSpecDbHomeDatabase)(ptr) = DbSystemSpecDbHomeDatabase{}
			}
		} else {
			*(*DbSystemSpecDbHomeDatabase)(ptr) = DbSystemSpecDbHomeDatabase{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DbSystemSpecDbHomeDatabase

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbHomeDatabase{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DbSystemSpecDbHomeDatabase)(ptr) = obj
		} else {
			*(*DbSystemSpecDbHomeDatabase)(ptr) = DbSystemSpecDbHomeDatabase{}
		}
	default:
		iter.ReportError("decode DbSystemSpecDbHomeDatabase", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DbSystemSpecDbHomeDatabaseDbBackupConfigCodec struct {
}

func (DbSystemSpecDbHomeDatabaseDbBackupConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DbSystemSpecDbHomeDatabaseDbBackupConfig)(ptr) == nil
}

func (DbSystemSpecDbHomeDatabaseDbBackupConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DbSystemSpecDbHomeDatabaseDbBackupConfig)(ptr)
	var objs []DbSystemSpecDbHomeDatabaseDbBackupConfig
	if obj != nil {
		objs = []DbSystemSpecDbHomeDatabaseDbBackupConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbHomeDatabaseDbBackupConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DbSystemSpecDbHomeDatabaseDbBackupConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DbSystemSpecDbHomeDatabaseDbBackupConfig)(ptr) = DbSystemSpecDbHomeDatabaseDbBackupConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DbSystemSpecDbHomeDatabaseDbBackupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbHomeDatabaseDbBackupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DbSystemSpecDbHomeDatabaseDbBackupConfig)(ptr) = objs[0]
			} else {
				*(*DbSystemSpecDbHomeDatabaseDbBackupConfig)(ptr) = DbSystemSpecDbHomeDatabaseDbBackupConfig{}
			}
		} else {
			*(*DbSystemSpecDbHomeDatabaseDbBackupConfig)(ptr) = DbSystemSpecDbHomeDatabaseDbBackupConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DbSystemSpecDbHomeDatabaseDbBackupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbHomeDatabaseDbBackupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DbSystemSpecDbHomeDatabaseDbBackupConfig)(ptr) = obj
		} else {
			*(*DbSystemSpecDbHomeDatabaseDbBackupConfig)(ptr) = DbSystemSpecDbHomeDatabaseDbBackupConfig{}
		}
	default:
		iter.ReportError("decode DbSystemSpecDbHomeDatabaseDbBackupConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DbSystemSpecDbSystemOptionsCodec struct {
}

func (DbSystemSpecDbSystemOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DbSystemSpecDbSystemOptions)(ptr) == nil
}

func (DbSystemSpecDbSystemOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DbSystemSpecDbSystemOptions)(ptr)
	var objs []DbSystemSpecDbSystemOptions
	if obj != nil {
		objs = []DbSystemSpecDbSystemOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbSystemOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DbSystemSpecDbSystemOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DbSystemSpecDbSystemOptions)(ptr) = DbSystemSpecDbSystemOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DbSystemSpecDbSystemOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbSystemOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DbSystemSpecDbSystemOptions)(ptr) = objs[0]
			} else {
				*(*DbSystemSpecDbSystemOptions)(ptr) = DbSystemSpecDbSystemOptions{}
			}
		} else {
			*(*DbSystemSpecDbSystemOptions)(ptr) = DbSystemSpecDbSystemOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DbSystemSpecDbSystemOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecDbSystemOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DbSystemSpecDbSystemOptions)(ptr) = obj
		} else {
			*(*DbSystemSpecDbSystemOptions)(ptr) = DbSystemSpecDbSystemOptions{}
		}
	default:
		iter.ReportError("decode DbSystemSpecDbSystemOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DbSystemSpecIormConfigCacheCodec struct {
}

func (DbSystemSpecIormConfigCacheCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DbSystemSpecIormConfigCache)(ptr) == nil
}

func (DbSystemSpecIormConfigCacheCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DbSystemSpecIormConfigCache)(ptr)
	var objs []DbSystemSpecIormConfigCache
	if obj != nil {
		objs = []DbSystemSpecIormConfigCache{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecIormConfigCache{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DbSystemSpecIormConfigCacheCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DbSystemSpecIormConfigCache)(ptr) = DbSystemSpecIormConfigCache{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DbSystemSpecIormConfigCache

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecIormConfigCache{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DbSystemSpecIormConfigCache)(ptr) = objs[0]
			} else {
				*(*DbSystemSpecIormConfigCache)(ptr) = DbSystemSpecIormConfigCache{}
			}
		} else {
			*(*DbSystemSpecIormConfigCache)(ptr) = DbSystemSpecIormConfigCache{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DbSystemSpecIormConfigCache

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecIormConfigCache{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DbSystemSpecIormConfigCache)(ptr) = obj
		} else {
			*(*DbSystemSpecIormConfigCache)(ptr) = DbSystemSpecIormConfigCache{}
		}
	default:
		iter.ReportError("decode DbSystemSpecIormConfigCache", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DbSystemSpecMaintenanceWindowCodec struct {
}

func (DbSystemSpecMaintenanceWindowCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DbSystemSpecMaintenanceWindow)(ptr) == nil
}

func (DbSystemSpecMaintenanceWindowCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DbSystemSpecMaintenanceWindow)(ptr)
	var objs []DbSystemSpecMaintenanceWindow
	if obj != nil {
		objs = []DbSystemSpecMaintenanceWindow{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecMaintenanceWindow{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DbSystemSpecMaintenanceWindowCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DbSystemSpecMaintenanceWindow)(ptr) = DbSystemSpecMaintenanceWindow{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DbSystemSpecMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DbSystemSpecMaintenanceWindow)(ptr) = objs[0]
			} else {
				*(*DbSystemSpecMaintenanceWindow)(ptr) = DbSystemSpecMaintenanceWindow{}
			}
		} else {
			*(*DbSystemSpecMaintenanceWindow)(ptr) = DbSystemSpecMaintenanceWindow{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DbSystemSpecMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DbSystemSpecMaintenanceWindow)(ptr) = obj
		} else {
			*(*DbSystemSpecMaintenanceWindow)(ptr) = DbSystemSpecMaintenanceWindow{}
		}
	default:
		iter.ReportError("decode DbSystemSpecMaintenanceWindow", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DbSystemSpecMaintenanceWindowDetailsCodec struct {
}

func (DbSystemSpecMaintenanceWindowDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DbSystemSpecMaintenanceWindowDetails)(ptr) == nil
}

func (DbSystemSpecMaintenanceWindowDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DbSystemSpecMaintenanceWindowDetails)(ptr)
	var objs []DbSystemSpecMaintenanceWindowDetails
	if obj != nil {
		objs = []DbSystemSpecMaintenanceWindowDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecMaintenanceWindowDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DbSystemSpecMaintenanceWindowDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DbSystemSpecMaintenanceWindowDetails)(ptr) = DbSystemSpecMaintenanceWindowDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DbSystemSpecMaintenanceWindowDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecMaintenanceWindowDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DbSystemSpecMaintenanceWindowDetails)(ptr) = objs[0]
			} else {
				*(*DbSystemSpecMaintenanceWindowDetails)(ptr) = DbSystemSpecMaintenanceWindowDetails{}
			}
		} else {
			*(*DbSystemSpecMaintenanceWindowDetails)(ptr) = DbSystemSpecMaintenanceWindowDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DbSystemSpecMaintenanceWindowDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DbSystemSpecMaintenanceWindowDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DbSystemSpecMaintenanceWindowDetails)(ptr) = obj
		} else {
			*(*DbSystemSpecMaintenanceWindowDetails)(ptr) = DbSystemSpecMaintenanceWindowDetails{}
		}
	default:
		iter.ReportError("decode DbSystemSpecMaintenanceWindowDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ExadataInfrastructureSpecMaintenanceWindowCodec struct {
}

func (ExadataInfrastructureSpecMaintenanceWindowCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ExadataInfrastructureSpecMaintenanceWindow)(ptr) == nil
}

func (ExadataInfrastructureSpecMaintenanceWindowCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ExadataInfrastructureSpecMaintenanceWindow)(ptr)
	var objs []ExadataInfrastructureSpecMaintenanceWindow
	if obj != nil {
		objs = []ExadataInfrastructureSpecMaintenanceWindow{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExadataInfrastructureSpecMaintenanceWindow{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ExadataInfrastructureSpecMaintenanceWindowCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ExadataInfrastructureSpecMaintenanceWindow)(ptr) = ExadataInfrastructureSpecMaintenanceWindow{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ExadataInfrastructureSpecMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExadataInfrastructureSpecMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ExadataInfrastructureSpecMaintenanceWindow)(ptr) = objs[0]
			} else {
				*(*ExadataInfrastructureSpecMaintenanceWindow)(ptr) = ExadataInfrastructureSpecMaintenanceWindow{}
			}
		} else {
			*(*ExadataInfrastructureSpecMaintenanceWindow)(ptr) = ExadataInfrastructureSpecMaintenanceWindow{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ExadataInfrastructureSpecMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExadataInfrastructureSpecMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ExadataInfrastructureSpecMaintenanceWindow)(ptr) = obj
		} else {
			*(*ExadataInfrastructureSpecMaintenanceWindow)(ptr) = ExadataInfrastructureSpecMaintenanceWindow{}
		}
	default:
		iter.ReportError("decode ExadataInfrastructureSpecMaintenanceWindow", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ExadataInfrastructureStorageSpecMaintenanceWindowCodec struct {
}

func (ExadataInfrastructureStorageSpecMaintenanceWindowCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ExadataInfrastructureStorageSpecMaintenanceWindow)(ptr) == nil
}

func (ExadataInfrastructureStorageSpecMaintenanceWindowCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ExadataInfrastructureStorageSpecMaintenanceWindow)(ptr)
	var objs []ExadataInfrastructureStorageSpecMaintenanceWindow
	if obj != nil {
		objs = []ExadataInfrastructureStorageSpecMaintenanceWindow{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExadataInfrastructureStorageSpecMaintenanceWindow{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ExadataInfrastructureStorageSpecMaintenanceWindowCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ExadataInfrastructureStorageSpecMaintenanceWindow)(ptr) = ExadataInfrastructureStorageSpecMaintenanceWindow{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ExadataInfrastructureStorageSpecMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExadataInfrastructureStorageSpecMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ExadataInfrastructureStorageSpecMaintenanceWindow)(ptr) = objs[0]
			} else {
				*(*ExadataInfrastructureStorageSpecMaintenanceWindow)(ptr) = ExadataInfrastructureStorageSpecMaintenanceWindow{}
			}
		} else {
			*(*ExadataInfrastructureStorageSpecMaintenanceWindow)(ptr) = ExadataInfrastructureStorageSpecMaintenanceWindow{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ExadataInfrastructureStorageSpecMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExadataInfrastructureStorageSpecMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ExadataInfrastructureStorageSpecMaintenanceWindow)(ptr) = obj
		} else {
			*(*ExadataInfrastructureStorageSpecMaintenanceWindow)(ptr) = ExadataInfrastructureStorageSpecMaintenanceWindow{}
		}
	default:
		iter.ReportError("decode ExadataInfrastructureStorageSpecMaintenanceWindow", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ExternalContainerDatabaseSpecDatabaseManagementConfigCodec struct {
}

func (ExternalContainerDatabaseSpecDatabaseManagementConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ExternalContainerDatabaseSpecDatabaseManagementConfig)(ptr) == nil
}

func (ExternalContainerDatabaseSpecDatabaseManagementConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ExternalContainerDatabaseSpecDatabaseManagementConfig)(ptr)
	var objs []ExternalContainerDatabaseSpecDatabaseManagementConfig
	if obj != nil {
		objs = []ExternalContainerDatabaseSpecDatabaseManagementConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalContainerDatabaseSpecDatabaseManagementConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ExternalContainerDatabaseSpecDatabaseManagementConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ExternalContainerDatabaseSpecDatabaseManagementConfig)(ptr) = ExternalContainerDatabaseSpecDatabaseManagementConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ExternalContainerDatabaseSpecDatabaseManagementConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalContainerDatabaseSpecDatabaseManagementConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ExternalContainerDatabaseSpecDatabaseManagementConfig)(ptr) = objs[0]
			} else {
				*(*ExternalContainerDatabaseSpecDatabaseManagementConfig)(ptr) = ExternalContainerDatabaseSpecDatabaseManagementConfig{}
			}
		} else {
			*(*ExternalContainerDatabaseSpecDatabaseManagementConfig)(ptr) = ExternalContainerDatabaseSpecDatabaseManagementConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ExternalContainerDatabaseSpecDatabaseManagementConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalContainerDatabaseSpecDatabaseManagementConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ExternalContainerDatabaseSpecDatabaseManagementConfig)(ptr) = obj
		} else {
			*(*ExternalContainerDatabaseSpecDatabaseManagementConfig)(ptr) = ExternalContainerDatabaseSpecDatabaseManagementConfig{}
		}
	default:
		iter.ReportError("decode ExternalContainerDatabaseSpecDatabaseManagementConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ExternalDatabaseConnectorSpecConnectionCredentialsCodec struct {
}

func (ExternalDatabaseConnectorSpecConnectionCredentialsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ExternalDatabaseConnectorSpecConnectionCredentials)(ptr) == nil
}

func (ExternalDatabaseConnectorSpecConnectionCredentialsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ExternalDatabaseConnectorSpecConnectionCredentials)(ptr)
	var objs []ExternalDatabaseConnectorSpecConnectionCredentials
	if obj != nil {
		objs = []ExternalDatabaseConnectorSpecConnectionCredentials{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalDatabaseConnectorSpecConnectionCredentials{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ExternalDatabaseConnectorSpecConnectionCredentialsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ExternalDatabaseConnectorSpecConnectionCredentials)(ptr) = ExternalDatabaseConnectorSpecConnectionCredentials{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ExternalDatabaseConnectorSpecConnectionCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalDatabaseConnectorSpecConnectionCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ExternalDatabaseConnectorSpecConnectionCredentials)(ptr) = objs[0]
			} else {
				*(*ExternalDatabaseConnectorSpecConnectionCredentials)(ptr) = ExternalDatabaseConnectorSpecConnectionCredentials{}
			}
		} else {
			*(*ExternalDatabaseConnectorSpecConnectionCredentials)(ptr) = ExternalDatabaseConnectorSpecConnectionCredentials{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ExternalDatabaseConnectorSpecConnectionCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalDatabaseConnectorSpecConnectionCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ExternalDatabaseConnectorSpecConnectionCredentials)(ptr) = obj
		} else {
			*(*ExternalDatabaseConnectorSpecConnectionCredentials)(ptr) = ExternalDatabaseConnectorSpecConnectionCredentials{}
		}
	default:
		iter.ReportError("decode ExternalDatabaseConnectorSpecConnectionCredentials", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ExternalDatabaseConnectorSpecConnectionStringCodec struct {
}

func (ExternalDatabaseConnectorSpecConnectionStringCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ExternalDatabaseConnectorSpecConnectionString)(ptr) == nil
}

func (ExternalDatabaseConnectorSpecConnectionStringCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ExternalDatabaseConnectorSpecConnectionString)(ptr)
	var objs []ExternalDatabaseConnectorSpecConnectionString
	if obj != nil {
		objs = []ExternalDatabaseConnectorSpecConnectionString{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalDatabaseConnectorSpecConnectionString{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ExternalDatabaseConnectorSpecConnectionStringCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ExternalDatabaseConnectorSpecConnectionString)(ptr) = ExternalDatabaseConnectorSpecConnectionString{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ExternalDatabaseConnectorSpecConnectionString

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalDatabaseConnectorSpecConnectionString{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ExternalDatabaseConnectorSpecConnectionString)(ptr) = objs[0]
			} else {
				*(*ExternalDatabaseConnectorSpecConnectionString)(ptr) = ExternalDatabaseConnectorSpecConnectionString{}
			}
		} else {
			*(*ExternalDatabaseConnectorSpecConnectionString)(ptr) = ExternalDatabaseConnectorSpecConnectionString{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ExternalDatabaseConnectorSpecConnectionString

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalDatabaseConnectorSpecConnectionString{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ExternalDatabaseConnectorSpecConnectionString)(ptr) = obj
		} else {
			*(*ExternalDatabaseConnectorSpecConnectionString)(ptr) = ExternalDatabaseConnectorSpecConnectionString{}
		}
	default:
		iter.ReportError("decode ExternalDatabaseConnectorSpecConnectionString", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ExternalNonContainerDatabaseSpecDatabaseManagementConfigCodec struct {
}

func (ExternalNonContainerDatabaseSpecDatabaseManagementConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ExternalNonContainerDatabaseSpecDatabaseManagementConfig)(ptr) == nil
}

func (ExternalNonContainerDatabaseSpecDatabaseManagementConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ExternalNonContainerDatabaseSpecDatabaseManagementConfig)(ptr)
	var objs []ExternalNonContainerDatabaseSpecDatabaseManagementConfig
	if obj != nil {
		objs = []ExternalNonContainerDatabaseSpecDatabaseManagementConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalNonContainerDatabaseSpecDatabaseManagementConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ExternalNonContainerDatabaseSpecDatabaseManagementConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ExternalNonContainerDatabaseSpecDatabaseManagementConfig)(ptr) = ExternalNonContainerDatabaseSpecDatabaseManagementConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ExternalNonContainerDatabaseSpecDatabaseManagementConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalNonContainerDatabaseSpecDatabaseManagementConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ExternalNonContainerDatabaseSpecDatabaseManagementConfig)(ptr) = objs[0]
			} else {
				*(*ExternalNonContainerDatabaseSpecDatabaseManagementConfig)(ptr) = ExternalNonContainerDatabaseSpecDatabaseManagementConfig{}
			}
		} else {
			*(*ExternalNonContainerDatabaseSpecDatabaseManagementConfig)(ptr) = ExternalNonContainerDatabaseSpecDatabaseManagementConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ExternalNonContainerDatabaseSpecDatabaseManagementConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalNonContainerDatabaseSpecDatabaseManagementConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ExternalNonContainerDatabaseSpecDatabaseManagementConfig)(ptr) = obj
		} else {
			*(*ExternalNonContainerDatabaseSpecDatabaseManagementConfig)(ptr) = ExternalNonContainerDatabaseSpecDatabaseManagementConfig{}
		}
	default:
		iter.ReportError("decode ExternalNonContainerDatabaseSpecDatabaseManagementConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ExternalNonContainerDatabaseSpecOperationsInsightsConfigCodec struct {
}

func (ExternalNonContainerDatabaseSpecOperationsInsightsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ExternalNonContainerDatabaseSpecOperationsInsightsConfig)(ptr) == nil
}

func (ExternalNonContainerDatabaseSpecOperationsInsightsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ExternalNonContainerDatabaseSpecOperationsInsightsConfig)(ptr)
	var objs []ExternalNonContainerDatabaseSpecOperationsInsightsConfig
	if obj != nil {
		objs = []ExternalNonContainerDatabaseSpecOperationsInsightsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalNonContainerDatabaseSpecOperationsInsightsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ExternalNonContainerDatabaseSpecOperationsInsightsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ExternalNonContainerDatabaseSpecOperationsInsightsConfig)(ptr) = ExternalNonContainerDatabaseSpecOperationsInsightsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ExternalNonContainerDatabaseSpecOperationsInsightsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalNonContainerDatabaseSpecOperationsInsightsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ExternalNonContainerDatabaseSpecOperationsInsightsConfig)(ptr) = objs[0]
			} else {
				*(*ExternalNonContainerDatabaseSpecOperationsInsightsConfig)(ptr) = ExternalNonContainerDatabaseSpecOperationsInsightsConfig{}
			}
		} else {
			*(*ExternalNonContainerDatabaseSpecOperationsInsightsConfig)(ptr) = ExternalNonContainerDatabaseSpecOperationsInsightsConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ExternalNonContainerDatabaseSpecOperationsInsightsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalNonContainerDatabaseSpecOperationsInsightsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ExternalNonContainerDatabaseSpecOperationsInsightsConfig)(ptr) = obj
		} else {
			*(*ExternalNonContainerDatabaseSpecOperationsInsightsConfig)(ptr) = ExternalNonContainerDatabaseSpecOperationsInsightsConfig{}
		}
	default:
		iter.ReportError("decode ExternalNonContainerDatabaseSpecOperationsInsightsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ExternalPluggableDatabaseSpecDatabaseManagementConfigCodec struct {
}

func (ExternalPluggableDatabaseSpecDatabaseManagementConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ExternalPluggableDatabaseSpecDatabaseManagementConfig)(ptr) == nil
}

func (ExternalPluggableDatabaseSpecDatabaseManagementConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ExternalPluggableDatabaseSpecDatabaseManagementConfig)(ptr)
	var objs []ExternalPluggableDatabaseSpecDatabaseManagementConfig
	if obj != nil {
		objs = []ExternalPluggableDatabaseSpecDatabaseManagementConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalPluggableDatabaseSpecDatabaseManagementConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ExternalPluggableDatabaseSpecDatabaseManagementConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ExternalPluggableDatabaseSpecDatabaseManagementConfig)(ptr) = ExternalPluggableDatabaseSpecDatabaseManagementConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ExternalPluggableDatabaseSpecDatabaseManagementConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalPluggableDatabaseSpecDatabaseManagementConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ExternalPluggableDatabaseSpecDatabaseManagementConfig)(ptr) = objs[0]
			} else {
				*(*ExternalPluggableDatabaseSpecDatabaseManagementConfig)(ptr) = ExternalPluggableDatabaseSpecDatabaseManagementConfig{}
			}
		} else {
			*(*ExternalPluggableDatabaseSpecDatabaseManagementConfig)(ptr) = ExternalPluggableDatabaseSpecDatabaseManagementConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ExternalPluggableDatabaseSpecDatabaseManagementConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalPluggableDatabaseSpecDatabaseManagementConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ExternalPluggableDatabaseSpecDatabaseManagementConfig)(ptr) = obj
		} else {
			*(*ExternalPluggableDatabaseSpecDatabaseManagementConfig)(ptr) = ExternalPluggableDatabaseSpecDatabaseManagementConfig{}
		}
	default:
		iter.ReportError("decode ExternalPluggableDatabaseSpecDatabaseManagementConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ExternalPluggableDatabaseSpecOperationsInsightsConfigCodec struct {
}

func (ExternalPluggableDatabaseSpecOperationsInsightsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ExternalPluggableDatabaseSpecOperationsInsightsConfig)(ptr) == nil
}

func (ExternalPluggableDatabaseSpecOperationsInsightsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ExternalPluggableDatabaseSpecOperationsInsightsConfig)(ptr)
	var objs []ExternalPluggableDatabaseSpecOperationsInsightsConfig
	if obj != nil {
		objs = []ExternalPluggableDatabaseSpecOperationsInsightsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalPluggableDatabaseSpecOperationsInsightsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ExternalPluggableDatabaseSpecOperationsInsightsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ExternalPluggableDatabaseSpecOperationsInsightsConfig)(ptr) = ExternalPluggableDatabaseSpecOperationsInsightsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ExternalPluggableDatabaseSpecOperationsInsightsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalPluggableDatabaseSpecOperationsInsightsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ExternalPluggableDatabaseSpecOperationsInsightsConfig)(ptr) = objs[0]
			} else {
				*(*ExternalPluggableDatabaseSpecOperationsInsightsConfig)(ptr) = ExternalPluggableDatabaseSpecOperationsInsightsConfig{}
			}
		} else {
			*(*ExternalPluggableDatabaseSpecOperationsInsightsConfig)(ptr) = ExternalPluggableDatabaseSpecOperationsInsightsConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ExternalPluggableDatabaseSpecOperationsInsightsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ExternalPluggableDatabaseSpecOperationsInsightsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ExternalPluggableDatabaseSpecOperationsInsightsConfig)(ptr) = obj
		} else {
			*(*ExternalPluggableDatabaseSpecOperationsInsightsConfig)(ptr) = ExternalPluggableDatabaseSpecOperationsInsightsConfig{}
		}
	default:
		iter.ReportError("decode ExternalPluggableDatabaseSpecOperationsInsightsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KeyStoreSpecTypeDetailsCodec struct {
}

func (KeyStoreSpecTypeDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KeyStoreSpecTypeDetails)(ptr) == nil
}

func (KeyStoreSpecTypeDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KeyStoreSpecTypeDetails)(ptr)
	var objs []KeyStoreSpecTypeDetails
	if obj != nil {
		objs = []KeyStoreSpecTypeDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeyStoreSpecTypeDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KeyStoreSpecTypeDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KeyStoreSpecTypeDetails)(ptr) = KeyStoreSpecTypeDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KeyStoreSpecTypeDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeyStoreSpecTypeDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KeyStoreSpecTypeDetails)(ptr) = objs[0]
			} else {
				*(*KeyStoreSpecTypeDetails)(ptr) = KeyStoreSpecTypeDetails{}
			}
		} else {
			*(*KeyStoreSpecTypeDetails)(ptr) = KeyStoreSpecTypeDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KeyStoreSpecTypeDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeyStoreSpecTypeDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KeyStoreSpecTypeDetails)(ptr) = obj
		} else {
			*(*KeyStoreSpecTypeDetails)(ptr) = KeyStoreSpecTypeDetails{}
		}
	default:
		iter.ReportError("decode KeyStoreSpecTypeDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MaintenanceRunSpecEstimatedPatchingTimeCodec struct {
}

func (MaintenanceRunSpecEstimatedPatchingTimeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MaintenanceRunSpecEstimatedPatchingTime)(ptr) == nil
}

func (MaintenanceRunSpecEstimatedPatchingTimeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MaintenanceRunSpecEstimatedPatchingTime)(ptr)
	var objs []MaintenanceRunSpecEstimatedPatchingTime
	if obj != nil {
		objs = []MaintenanceRunSpecEstimatedPatchingTime{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MaintenanceRunSpecEstimatedPatchingTime{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MaintenanceRunSpecEstimatedPatchingTimeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MaintenanceRunSpecEstimatedPatchingTime)(ptr) = MaintenanceRunSpecEstimatedPatchingTime{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MaintenanceRunSpecEstimatedPatchingTime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MaintenanceRunSpecEstimatedPatchingTime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MaintenanceRunSpecEstimatedPatchingTime)(ptr) = objs[0]
			} else {
				*(*MaintenanceRunSpecEstimatedPatchingTime)(ptr) = MaintenanceRunSpecEstimatedPatchingTime{}
			}
		} else {
			*(*MaintenanceRunSpecEstimatedPatchingTime)(ptr) = MaintenanceRunSpecEstimatedPatchingTime{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MaintenanceRunSpecEstimatedPatchingTime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MaintenanceRunSpecEstimatedPatchingTime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MaintenanceRunSpecEstimatedPatchingTime)(ptr) = obj
		} else {
			*(*MaintenanceRunSpecEstimatedPatchingTime)(ptr) = MaintenanceRunSpecEstimatedPatchingTime{}
		}
	default:
		iter.ReportError("decode MaintenanceRunSpecEstimatedPatchingTime", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementManagedDatabasesChangeDatabaseParameterSpecCredentialsCodec struct {
}

func (ManagementManagedDatabasesChangeDatabaseParameterSpecCredentialsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials)(ptr) == nil
}

func (ManagementManagedDatabasesChangeDatabaseParameterSpecCredentialsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials)(ptr)
	var objs []ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials
	if obj != nil {
		objs = []ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementManagedDatabasesChangeDatabaseParameterSpecCredentialsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials)(ptr) = ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials)(ptr) = objs[0]
			} else {
				*(*ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials)(ptr) = ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials{}
			}
		} else {
			*(*ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials)(ptr) = ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials)(ptr) = obj
		} else {
			*(*ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials)(ptr) = ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials{}
		}
	default:
		iter.ReportError("decode ManagementManagedDatabasesChangeDatabaseParameterSpecCredentials", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementManagedDatabasesResetDatabaseParameterSpecCredentialsCodec struct {
}

func (ManagementManagedDatabasesResetDatabaseParameterSpecCredentialsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementManagedDatabasesResetDatabaseParameterSpecCredentials)(ptr) == nil
}

func (ManagementManagedDatabasesResetDatabaseParameterSpecCredentialsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementManagedDatabasesResetDatabaseParameterSpecCredentials)(ptr)
	var objs []ManagementManagedDatabasesResetDatabaseParameterSpecCredentials
	if obj != nil {
		objs = []ManagementManagedDatabasesResetDatabaseParameterSpecCredentials{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementManagedDatabasesResetDatabaseParameterSpecCredentials{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementManagedDatabasesResetDatabaseParameterSpecCredentialsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementManagedDatabasesResetDatabaseParameterSpecCredentials)(ptr) = ManagementManagedDatabasesResetDatabaseParameterSpecCredentials{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementManagedDatabasesResetDatabaseParameterSpecCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementManagedDatabasesResetDatabaseParameterSpecCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementManagedDatabasesResetDatabaseParameterSpecCredentials)(ptr) = objs[0]
			} else {
				*(*ManagementManagedDatabasesResetDatabaseParameterSpecCredentials)(ptr) = ManagementManagedDatabasesResetDatabaseParameterSpecCredentials{}
			}
		} else {
			*(*ManagementManagedDatabasesResetDatabaseParameterSpecCredentials)(ptr) = ManagementManagedDatabasesResetDatabaseParameterSpecCredentials{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ManagementManagedDatabasesResetDatabaseParameterSpecCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementManagedDatabasesResetDatabaseParameterSpecCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ManagementManagedDatabasesResetDatabaseParameterSpecCredentials)(ptr) = obj
		} else {
			*(*ManagementManagedDatabasesResetDatabaseParameterSpecCredentials)(ptr) = ManagementManagedDatabasesResetDatabaseParameterSpecCredentials{}
		}
	default:
		iter.ReportError("decode ManagementManagedDatabasesResetDatabaseParameterSpecCredentials", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationConnectionSpecAdminCredentialsCodec struct {
}

func (MigrationConnectionSpecAdminCredentialsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationConnectionSpecAdminCredentials)(ptr) == nil
}

func (MigrationConnectionSpecAdminCredentialsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationConnectionSpecAdminCredentials)(ptr)
	var objs []MigrationConnectionSpecAdminCredentials
	if obj != nil {
		objs = []MigrationConnectionSpecAdminCredentials{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecAdminCredentials{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationConnectionSpecAdminCredentialsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationConnectionSpecAdminCredentials)(ptr) = MigrationConnectionSpecAdminCredentials{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationConnectionSpecAdminCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecAdminCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationConnectionSpecAdminCredentials)(ptr) = objs[0]
			} else {
				*(*MigrationConnectionSpecAdminCredentials)(ptr) = MigrationConnectionSpecAdminCredentials{}
			}
		} else {
			*(*MigrationConnectionSpecAdminCredentials)(ptr) = MigrationConnectionSpecAdminCredentials{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationConnectionSpecAdminCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecAdminCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationConnectionSpecAdminCredentials)(ptr) = obj
		} else {
			*(*MigrationConnectionSpecAdminCredentials)(ptr) = MigrationConnectionSpecAdminCredentials{}
		}
	default:
		iter.ReportError("decode MigrationConnectionSpecAdminCredentials", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationConnectionSpecConnectDescriptorCodec struct {
}

func (MigrationConnectionSpecConnectDescriptorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationConnectionSpecConnectDescriptor)(ptr) == nil
}

func (MigrationConnectionSpecConnectDescriptorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationConnectionSpecConnectDescriptor)(ptr)
	var objs []MigrationConnectionSpecConnectDescriptor
	if obj != nil {
		objs = []MigrationConnectionSpecConnectDescriptor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecConnectDescriptor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationConnectionSpecConnectDescriptorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationConnectionSpecConnectDescriptor)(ptr) = MigrationConnectionSpecConnectDescriptor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationConnectionSpecConnectDescriptor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecConnectDescriptor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationConnectionSpecConnectDescriptor)(ptr) = objs[0]
			} else {
				*(*MigrationConnectionSpecConnectDescriptor)(ptr) = MigrationConnectionSpecConnectDescriptor{}
			}
		} else {
			*(*MigrationConnectionSpecConnectDescriptor)(ptr) = MigrationConnectionSpecConnectDescriptor{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationConnectionSpecConnectDescriptor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecConnectDescriptor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationConnectionSpecConnectDescriptor)(ptr) = obj
		} else {
			*(*MigrationConnectionSpecConnectDescriptor)(ptr) = MigrationConnectionSpecConnectDescriptor{}
		}
	default:
		iter.ReportError("decode MigrationConnectionSpecConnectDescriptor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationConnectionSpecPrivateEndpointCodec struct {
}

func (MigrationConnectionSpecPrivateEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationConnectionSpecPrivateEndpoint)(ptr) == nil
}

func (MigrationConnectionSpecPrivateEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationConnectionSpecPrivateEndpoint)(ptr)
	var objs []MigrationConnectionSpecPrivateEndpoint
	if obj != nil {
		objs = []MigrationConnectionSpecPrivateEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecPrivateEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationConnectionSpecPrivateEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationConnectionSpecPrivateEndpoint)(ptr) = MigrationConnectionSpecPrivateEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationConnectionSpecPrivateEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecPrivateEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationConnectionSpecPrivateEndpoint)(ptr) = objs[0]
			} else {
				*(*MigrationConnectionSpecPrivateEndpoint)(ptr) = MigrationConnectionSpecPrivateEndpoint{}
			}
		} else {
			*(*MigrationConnectionSpecPrivateEndpoint)(ptr) = MigrationConnectionSpecPrivateEndpoint{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationConnectionSpecPrivateEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecPrivateEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationConnectionSpecPrivateEndpoint)(ptr) = obj
		} else {
			*(*MigrationConnectionSpecPrivateEndpoint)(ptr) = MigrationConnectionSpecPrivateEndpoint{}
		}
	default:
		iter.ReportError("decode MigrationConnectionSpecPrivateEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationConnectionSpecSshDetailsCodec struct {
}

func (MigrationConnectionSpecSshDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationConnectionSpecSshDetails)(ptr) == nil
}

func (MigrationConnectionSpecSshDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationConnectionSpecSshDetails)(ptr)
	var objs []MigrationConnectionSpecSshDetails
	if obj != nil {
		objs = []MigrationConnectionSpecSshDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecSshDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationConnectionSpecSshDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationConnectionSpecSshDetails)(ptr) = MigrationConnectionSpecSshDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationConnectionSpecSshDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecSshDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationConnectionSpecSshDetails)(ptr) = objs[0]
			} else {
				*(*MigrationConnectionSpecSshDetails)(ptr) = MigrationConnectionSpecSshDetails{}
			}
		} else {
			*(*MigrationConnectionSpecSshDetails)(ptr) = MigrationConnectionSpecSshDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationConnectionSpecSshDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecSshDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationConnectionSpecSshDetails)(ptr) = obj
		} else {
			*(*MigrationConnectionSpecSshDetails)(ptr) = MigrationConnectionSpecSshDetails{}
		}
	default:
		iter.ReportError("decode MigrationConnectionSpecSshDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationConnectionSpecVaultDetailsCodec struct {
}

func (MigrationConnectionSpecVaultDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationConnectionSpecVaultDetails)(ptr) == nil
}

func (MigrationConnectionSpecVaultDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationConnectionSpecVaultDetails)(ptr)
	var objs []MigrationConnectionSpecVaultDetails
	if obj != nil {
		objs = []MigrationConnectionSpecVaultDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecVaultDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationConnectionSpecVaultDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationConnectionSpecVaultDetails)(ptr) = MigrationConnectionSpecVaultDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationConnectionSpecVaultDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecVaultDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationConnectionSpecVaultDetails)(ptr) = objs[0]
			} else {
				*(*MigrationConnectionSpecVaultDetails)(ptr) = MigrationConnectionSpecVaultDetails{}
			}
		} else {
			*(*MigrationConnectionSpecVaultDetails)(ptr) = MigrationConnectionSpecVaultDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationConnectionSpecVaultDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationConnectionSpecVaultDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationConnectionSpecVaultDetails)(ptr) = obj
		} else {
			*(*MigrationConnectionSpecVaultDetails)(ptr) = MigrationConnectionSpecVaultDetails{}
		}
	default:
		iter.ReportError("decode MigrationConnectionSpecVaultDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationJobSpecProgressCodec struct {
}

func (MigrationJobSpecProgressCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationJobSpecProgress)(ptr) == nil
}

func (MigrationJobSpecProgressCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationJobSpecProgress)(ptr)
	var objs []MigrationJobSpecProgress
	if obj != nil {
		objs = []MigrationJobSpecProgress{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationJobSpecProgress{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationJobSpecProgressCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationJobSpecProgress)(ptr) = MigrationJobSpecProgress{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationJobSpecProgress

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationJobSpecProgress{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationJobSpecProgress)(ptr) = objs[0]
			} else {
				*(*MigrationJobSpecProgress)(ptr) = MigrationJobSpecProgress{}
			}
		} else {
			*(*MigrationJobSpecProgress)(ptr) = MigrationJobSpecProgress{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationJobSpecProgress

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationJobSpecProgress{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationJobSpecProgress)(ptr) = obj
		} else {
			*(*MigrationJobSpecProgress)(ptr) = MigrationJobSpecProgress{}
		}
	default:
		iter.ReportError("decode MigrationJobSpecProgress", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationJobSpecProgressPhasesLogLocationCodec struct {
}

func (MigrationJobSpecProgressPhasesLogLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationJobSpecProgressPhasesLogLocation)(ptr) == nil
}

func (MigrationJobSpecProgressPhasesLogLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationJobSpecProgressPhasesLogLocation)(ptr)
	var objs []MigrationJobSpecProgressPhasesLogLocation
	if obj != nil {
		objs = []MigrationJobSpecProgressPhasesLogLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationJobSpecProgressPhasesLogLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationJobSpecProgressPhasesLogLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationJobSpecProgressPhasesLogLocation)(ptr) = MigrationJobSpecProgressPhasesLogLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationJobSpecProgressPhasesLogLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationJobSpecProgressPhasesLogLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationJobSpecProgressPhasesLogLocation)(ptr) = objs[0]
			} else {
				*(*MigrationJobSpecProgressPhasesLogLocation)(ptr) = MigrationJobSpecProgressPhasesLogLocation{}
			}
		} else {
			*(*MigrationJobSpecProgressPhasesLogLocation)(ptr) = MigrationJobSpecProgressPhasesLogLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationJobSpecProgressPhasesLogLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationJobSpecProgressPhasesLogLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationJobSpecProgressPhasesLogLocation)(ptr) = obj
		} else {
			*(*MigrationJobSpecProgressPhasesLogLocation)(ptr) = MigrationJobSpecProgressPhasesLogLocation{}
		}
	default:
		iter.ReportError("decode MigrationJobSpecProgressPhasesLogLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecAdvisorSettingsCodec struct {
}

func (MigrationMigrationSpecAdvisorSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecAdvisorSettings)(ptr) == nil
}

func (MigrationMigrationSpecAdvisorSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecAdvisorSettings)(ptr)
	var objs []MigrationMigrationSpecAdvisorSettings
	if obj != nil {
		objs = []MigrationMigrationSpecAdvisorSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecAdvisorSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecAdvisorSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecAdvisorSettings)(ptr) = MigrationMigrationSpecAdvisorSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecAdvisorSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecAdvisorSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecAdvisorSettings)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecAdvisorSettings)(ptr) = MigrationMigrationSpecAdvisorSettings{}
			}
		} else {
			*(*MigrationMigrationSpecAdvisorSettings)(ptr) = MigrationMigrationSpecAdvisorSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecAdvisorSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecAdvisorSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecAdvisorSettings)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecAdvisorSettings)(ptr) = MigrationMigrationSpecAdvisorSettings{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecAdvisorSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecDataTransferMediumDetailsCodec struct {
}

func (MigrationMigrationSpecDataTransferMediumDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecDataTransferMediumDetails)(ptr) == nil
}

func (MigrationMigrationSpecDataTransferMediumDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecDataTransferMediumDetails)(ptr)
	var objs []MigrationMigrationSpecDataTransferMediumDetails
	if obj != nil {
		objs = []MigrationMigrationSpecDataTransferMediumDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecDataTransferMediumDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecDataTransferMediumDetails)(ptr) = MigrationMigrationSpecDataTransferMediumDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecDataTransferMediumDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecDataTransferMediumDetails)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecDataTransferMediumDetails)(ptr) = MigrationMigrationSpecDataTransferMediumDetails{}
			}
		} else {
			*(*MigrationMigrationSpecDataTransferMediumDetails)(ptr) = MigrationMigrationSpecDataTransferMediumDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecDataTransferMediumDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecDataTransferMediumDetails)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecDataTransferMediumDetails)(ptr) = MigrationMigrationSpecDataTransferMediumDetails{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecDataTransferMediumDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsCodec struct {
}

func (MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails)(ptr) == nil
}

func (MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails)(ptr)
	var objs []MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails
	if obj != nil {
		objs = []MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails)(ptr) = MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails)(ptr) = MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails{}
			}
		} else {
			*(*MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails)(ptr) = MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails)(ptr) = MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucketCodec struct {
}

func (MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucketCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket)(ptr) == nil
}

func (MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucketCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket)(ptr)
	var objs []MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket
	if obj != nil {
		objs = []MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucketCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket)(ptr) = MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket)(ptr) = MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket{}
			}
		} else {
			*(*MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket)(ptr) = MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket)(ptr) = MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecDataTransferMediumDetailsDatabaseLinkDetailsWalletBucket", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetailsCodec struct {
}

func (MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails)(ptr) == nil
}

func (MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails)(ptr)
	var objs []MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails
	if obj != nil {
		objs = []MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails)(ptr) = MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails)(ptr) = MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails{}
			}
		} else {
			*(*MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails)(ptr) = MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails)(ptr) = MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecDataTransferMediumDetailsObjectStorageDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecDatapumpSettingsCodec struct {
}

func (MigrationMigrationSpecDatapumpSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecDatapumpSettings)(ptr) == nil
}

func (MigrationMigrationSpecDatapumpSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecDatapumpSettings)(ptr)
	var objs []MigrationMigrationSpecDatapumpSettings
	if obj != nil {
		objs = []MigrationMigrationSpecDatapumpSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecDatapumpSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecDatapumpSettings)(ptr) = MigrationMigrationSpecDatapumpSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecDatapumpSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecDatapumpSettings)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecDatapumpSettings)(ptr) = MigrationMigrationSpecDatapumpSettings{}
			}
		} else {
			*(*MigrationMigrationSpecDatapumpSettings)(ptr) = MigrationMigrationSpecDatapumpSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecDatapumpSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecDatapumpSettings)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecDatapumpSettings)(ptr) = MigrationMigrationSpecDatapumpSettings{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecDatapumpSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecDatapumpSettingsDataPumpParametersCodec struct {
}

func (MigrationMigrationSpecDatapumpSettingsDataPumpParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecDatapumpSettingsDataPumpParameters)(ptr) == nil
}

func (MigrationMigrationSpecDatapumpSettingsDataPumpParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecDatapumpSettingsDataPumpParameters)(ptr)
	var objs []MigrationMigrationSpecDatapumpSettingsDataPumpParameters
	if obj != nil {
		objs = []MigrationMigrationSpecDatapumpSettingsDataPumpParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettingsDataPumpParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecDatapumpSettingsDataPumpParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecDatapumpSettingsDataPumpParameters)(ptr) = MigrationMigrationSpecDatapumpSettingsDataPumpParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecDatapumpSettingsDataPumpParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettingsDataPumpParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecDatapumpSettingsDataPumpParameters)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecDatapumpSettingsDataPumpParameters)(ptr) = MigrationMigrationSpecDatapumpSettingsDataPumpParameters{}
			}
		} else {
			*(*MigrationMigrationSpecDatapumpSettingsDataPumpParameters)(ptr) = MigrationMigrationSpecDatapumpSettingsDataPumpParameters{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecDatapumpSettingsDataPumpParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettingsDataPumpParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecDatapumpSettingsDataPumpParameters)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecDatapumpSettingsDataPumpParameters)(ptr) = MigrationMigrationSpecDatapumpSettingsDataPumpParameters{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecDatapumpSettingsDataPumpParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecDatapumpSettingsExportDirectoryObjectCodec struct {
}

func (MigrationMigrationSpecDatapumpSettingsExportDirectoryObjectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecDatapumpSettingsExportDirectoryObject)(ptr) == nil
}

func (MigrationMigrationSpecDatapumpSettingsExportDirectoryObjectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecDatapumpSettingsExportDirectoryObject)(ptr)
	var objs []MigrationMigrationSpecDatapumpSettingsExportDirectoryObject
	if obj != nil {
		objs = []MigrationMigrationSpecDatapumpSettingsExportDirectoryObject{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettingsExportDirectoryObject{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecDatapumpSettingsExportDirectoryObjectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecDatapumpSettingsExportDirectoryObject)(ptr) = MigrationMigrationSpecDatapumpSettingsExportDirectoryObject{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecDatapumpSettingsExportDirectoryObject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettingsExportDirectoryObject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecDatapumpSettingsExportDirectoryObject)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecDatapumpSettingsExportDirectoryObject)(ptr) = MigrationMigrationSpecDatapumpSettingsExportDirectoryObject{}
			}
		} else {
			*(*MigrationMigrationSpecDatapumpSettingsExportDirectoryObject)(ptr) = MigrationMigrationSpecDatapumpSettingsExportDirectoryObject{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecDatapumpSettingsExportDirectoryObject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettingsExportDirectoryObject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecDatapumpSettingsExportDirectoryObject)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecDatapumpSettingsExportDirectoryObject)(ptr) = MigrationMigrationSpecDatapumpSettingsExportDirectoryObject{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecDatapumpSettingsExportDirectoryObject", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecDatapumpSettingsImportDirectoryObjectCodec struct {
}

func (MigrationMigrationSpecDatapumpSettingsImportDirectoryObjectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecDatapumpSettingsImportDirectoryObject)(ptr) == nil
}

func (MigrationMigrationSpecDatapumpSettingsImportDirectoryObjectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecDatapumpSettingsImportDirectoryObject)(ptr)
	var objs []MigrationMigrationSpecDatapumpSettingsImportDirectoryObject
	if obj != nil {
		objs = []MigrationMigrationSpecDatapumpSettingsImportDirectoryObject{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettingsImportDirectoryObject{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecDatapumpSettingsImportDirectoryObjectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecDatapumpSettingsImportDirectoryObject)(ptr) = MigrationMigrationSpecDatapumpSettingsImportDirectoryObject{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecDatapumpSettingsImportDirectoryObject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettingsImportDirectoryObject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecDatapumpSettingsImportDirectoryObject)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecDatapumpSettingsImportDirectoryObject)(ptr) = MigrationMigrationSpecDatapumpSettingsImportDirectoryObject{}
			}
		} else {
			*(*MigrationMigrationSpecDatapumpSettingsImportDirectoryObject)(ptr) = MigrationMigrationSpecDatapumpSettingsImportDirectoryObject{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecDatapumpSettingsImportDirectoryObject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDatapumpSettingsImportDirectoryObject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecDatapumpSettingsImportDirectoryObject)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecDatapumpSettingsImportDirectoryObject)(ptr) = MigrationMigrationSpecDatapumpSettingsImportDirectoryObject{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecDatapumpSettingsImportDirectoryObject", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecDumpTransferDetailsCodec struct {
}

func (MigrationMigrationSpecDumpTransferDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecDumpTransferDetails)(ptr) == nil
}

func (MigrationMigrationSpecDumpTransferDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecDumpTransferDetails)(ptr)
	var objs []MigrationMigrationSpecDumpTransferDetails
	if obj != nil {
		objs = []MigrationMigrationSpecDumpTransferDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDumpTransferDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecDumpTransferDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecDumpTransferDetails)(ptr) = MigrationMigrationSpecDumpTransferDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecDumpTransferDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDumpTransferDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecDumpTransferDetails)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecDumpTransferDetails)(ptr) = MigrationMigrationSpecDumpTransferDetails{}
			}
		} else {
			*(*MigrationMigrationSpecDumpTransferDetails)(ptr) = MigrationMigrationSpecDumpTransferDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecDumpTransferDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDumpTransferDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecDumpTransferDetails)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecDumpTransferDetails)(ptr) = MigrationMigrationSpecDumpTransferDetails{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecDumpTransferDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecDumpTransferDetailsSourceCodec struct {
}

func (MigrationMigrationSpecDumpTransferDetailsSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecDumpTransferDetailsSource)(ptr) == nil
}

func (MigrationMigrationSpecDumpTransferDetailsSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecDumpTransferDetailsSource)(ptr)
	var objs []MigrationMigrationSpecDumpTransferDetailsSource
	if obj != nil {
		objs = []MigrationMigrationSpecDumpTransferDetailsSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDumpTransferDetailsSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecDumpTransferDetailsSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecDumpTransferDetailsSource)(ptr) = MigrationMigrationSpecDumpTransferDetailsSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecDumpTransferDetailsSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDumpTransferDetailsSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecDumpTransferDetailsSource)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecDumpTransferDetailsSource)(ptr) = MigrationMigrationSpecDumpTransferDetailsSource{}
			}
		} else {
			*(*MigrationMigrationSpecDumpTransferDetailsSource)(ptr) = MigrationMigrationSpecDumpTransferDetailsSource{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecDumpTransferDetailsSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDumpTransferDetailsSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecDumpTransferDetailsSource)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecDumpTransferDetailsSource)(ptr) = MigrationMigrationSpecDumpTransferDetailsSource{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecDumpTransferDetailsSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecDumpTransferDetailsTargetCodec struct {
}

func (MigrationMigrationSpecDumpTransferDetailsTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecDumpTransferDetailsTarget)(ptr) == nil
}

func (MigrationMigrationSpecDumpTransferDetailsTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecDumpTransferDetailsTarget)(ptr)
	var objs []MigrationMigrationSpecDumpTransferDetailsTarget
	if obj != nil {
		objs = []MigrationMigrationSpecDumpTransferDetailsTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDumpTransferDetailsTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecDumpTransferDetailsTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecDumpTransferDetailsTarget)(ptr) = MigrationMigrationSpecDumpTransferDetailsTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecDumpTransferDetailsTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDumpTransferDetailsTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecDumpTransferDetailsTarget)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecDumpTransferDetailsTarget)(ptr) = MigrationMigrationSpecDumpTransferDetailsTarget{}
			}
		} else {
			*(*MigrationMigrationSpecDumpTransferDetailsTarget)(ptr) = MigrationMigrationSpecDumpTransferDetailsTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecDumpTransferDetailsTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecDumpTransferDetailsTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecDumpTransferDetailsTarget)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecDumpTransferDetailsTarget)(ptr) = MigrationMigrationSpecDumpTransferDetailsTarget{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecDumpTransferDetailsTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecGoldenGateDetailsCodec struct {
}

func (MigrationMigrationSpecGoldenGateDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecGoldenGateDetails)(ptr) == nil
}

func (MigrationMigrationSpecGoldenGateDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecGoldenGateDetails)(ptr)
	var objs []MigrationMigrationSpecGoldenGateDetails
	if obj != nil {
		objs = []MigrationMigrationSpecGoldenGateDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecGoldenGateDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecGoldenGateDetails)(ptr) = MigrationMigrationSpecGoldenGateDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecGoldenGateDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecGoldenGateDetails)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecGoldenGateDetails)(ptr) = MigrationMigrationSpecGoldenGateDetails{}
			}
		} else {
			*(*MigrationMigrationSpecGoldenGateDetails)(ptr) = MigrationMigrationSpecGoldenGateDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecGoldenGateDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecGoldenGateDetails)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecGoldenGateDetails)(ptr) = MigrationMigrationSpecGoldenGateDetails{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecGoldenGateDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecGoldenGateDetailsHubCodec struct {
}

func (MigrationMigrationSpecGoldenGateDetailsHubCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecGoldenGateDetailsHub)(ptr) == nil
}

func (MigrationMigrationSpecGoldenGateDetailsHubCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecGoldenGateDetailsHub)(ptr)
	var objs []MigrationMigrationSpecGoldenGateDetailsHub
	if obj != nil {
		objs = []MigrationMigrationSpecGoldenGateDetailsHub{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHub{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecGoldenGateDetailsHubCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecGoldenGateDetailsHub)(ptr) = MigrationMigrationSpecGoldenGateDetailsHub{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecGoldenGateDetailsHub

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHub{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecGoldenGateDetailsHub)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecGoldenGateDetailsHub)(ptr) = MigrationMigrationSpecGoldenGateDetailsHub{}
			}
		} else {
			*(*MigrationMigrationSpecGoldenGateDetailsHub)(ptr) = MigrationMigrationSpecGoldenGateDetailsHub{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecGoldenGateDetailsHub

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHub{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecGoldenGateDetailsHub)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecGoldenGateDetailsHub)(ptr) = MigrationMigrationSpecGoldenGateDetailsHub{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecGoldenGateDetailsHub", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentialsCodec struct {
}

func (MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentialsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials)(ptr) == nil
}

func (MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentialsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials)(ptr)
	var objs []MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials
	if obj != nil {
		objs = []MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentialsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials)(ptr) = MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials)(ptr) = MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials{}
			}
		} else {
			*(*MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials)(ptr) = MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials)(ptr) = MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecGoldenGateDetailsHubRestAdminCredentials", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentialsCodec struct {
}

func (MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentialsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials)(ptr) == nil
}

func (MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentialsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials)(ptr)
	var objs []MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials
	if obj != nil {
		objs = []MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentialsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials)(ptr) = MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials)(ptr) = MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials{}
			}
		} else {
			*(*MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials)(ptr) = MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials)(ptr) = MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecGoldenGateDetailsHubSourceContainerDbAdminCredentials", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentialsCodec struct {
}

func (MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentialsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials)(ptr) == nil
}

func (MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentialsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials)(ptr)
	var objs []MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials
	if obj != nil {
		objs = []MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentialsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials)(ptr) = MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials)(ptr) = MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials{}
			}
		} else {
			*(*MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials)(ptr) = MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials)(ptr) = MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecGoldenGateDetailsHubSourceDbAdminCredentials", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentialsCodec struct {
}

func (MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentialsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials)(ptr) == nil
}

func (MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentialsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials)(ptr)
	var objs []MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials
	if obj != nil {
		objs = []MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentialsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials)(ptr) = MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials)(ptr) = MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials{}
			}
		} else {
			*(*MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials)(ptr) = MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials)(ptr) = MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecGoldenGateDetailsHubTargetDbAdminCredentials", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecGoldenGateDetailsSettingsCodec struct {
}

func (MigrationMigrationSpecGoldenGateDetailsSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecGoldenGateDetailsSettings)(ptr) == nil
}

func (MigrationMigrationSpecGoldenGateDetailsSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecGoldenGateDetailsSettings)(ptr)
	var objs []MigrationMigrationSpecGoldenGateDetailsSettings
	if obj != nil {
		objs = []MigrationMigrationSpecGoldenGateDetailsSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecGoldenGateDetailsSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecGoldenGateDetailsSettings)(ptr) = MigrationMigrationSpecGoldenGateDetailsSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecGoldenGateDetailsSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecGoldenGateDetailsSettings)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecGoldenGateDetailsSettings)(ptr) = MigrationMigrationSpecGoldenGateDetailsSettings{}
			}
		} else {
			*(*MigrationMigrationSpecGoldenGateDetailsSettings)(ptr) = MigrationMigrationSpecGoldenGateDetailsSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecGoldenGateDetailsSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecGoldenGateDetailsSettings)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecGoldenGateDetailsSettings)(ptr) = MigrationMigrationSpecGoldenGateDetailsSettings{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecGoldenGateDetailsSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecGoldenGateDetailsSettingsExtractCodec struct {
}

func (MigrationMigrationSpecGoldenGateDetailsSettingsExtractCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecGoldenGateDetailsSettingsExtract)(ptr) == nil
}

func (MigrationMigrationSpecGoldenGateDetailsSettingsExtractCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecGoldenGateDetailsSettingsExtract)(ptr)
	var objs []MigrationMigrationSpecGoldenGateDetailsSettingsExtract
	if obj != nil {
		objs = []MigrationMigrationSpecGoldenGateDetailsSettingsExtract{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsSettingsExtract{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecGoldenGateDetailsSettingsExtractCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecGoldenGateDetailsSettingsExtract)(ptr) = MigrationMigrationSpecGoldenGateDetailsSettingsExtract{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecGoldenGateDetailsSettingsExtract

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsSettingsExtract{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecGoldenGateDetailsSettingsExtract)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecGoldenGateDetailsSettingsExtract)(ptr) = MigrationMigrationSpecGoldenGateDetailsSettingsExtract{}
			}
		} else {
			*(*MigrationMigrationSpecGoldenGateDetailsSettingsExtract)(ptr) = MigrationMigrationSpecGoldenGateDetailsSettingsExtract{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecGoldenGateDetailsSettingsExtract

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsSettingsExtract{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecGoldenGateDetailsSettingsExtract)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecGoldenGateDetailsSettingsExtract)(ptr) = MigrationMigrationSpecGoldenGateDetailsSettingsExtract{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecGoldenGateDetailsSettingsExtract", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecGoldenGateDetailsSettingsReplicatCodec struct {
}

func (MigrationMigrationSpecGoldenGateDetailsSettingsReplicatCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecGoldenGateDetailsSettingsReplicat)(ptr) == nil
}

func (MigrationMigrationSpecGoldenGateDetailsSettingsReplicatCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecGoldenGateDetailsSettingsReplicat)(ptr)
	var objs []MigrationMigrationSpecGoldenGateDetailsSettingsReplicat
	if obj != nil {
		objs = []MigrationMigrationSpecGoldenGateDetailsSettingsReplicat{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsSettingsReplicat{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecGoldenGateDetailsSettingsReplicatCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecGoldenGateDetailsSettingsReplicat)(ptr) = MigrationMigrationSpecGoldenGateDetailsSettingsReplicat{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecGoldenGateDetailsSettingsReplicat

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsSettingsReplicat{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecGoldenGateDetailsSettingsReplicat)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecGoldenGateDetailsSettingsReplicat)(ptr) = MigrationMigrationSpecGoldenGateDetailsSettingsReplicat{}
			}
		} else {
			*(*MigrationMigrationSpecGoldenGateDetailsSettingsReplicat)(ptr) = MigrationMigrationSpecGoldenGateDetailsSettingsReplicat{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecGoldenGateDetailsSettingsReplicat

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecGoldenGateDetailsSettingsReplicat{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecGoldenGateDetailsSettingsReplicat)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecGoldenGateDetailsSettingsReplicat)(ptr) = MigrationMigrationSpecGoldenGateDetailsSettingsReplicat{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecGoldenGateDetailsSettingsReplicat", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MigrationMigrationSpecVaultDetailsCodec struct {
}

func (MigrationMigrationSpecVaultDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MigrationMigrationSpecVaultDetails)(ptr) == nil
}

func (MigrationMigrationSpecVaultDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MigrationMigrationSpecVaultDetails)(ptr)
	var objs []MigrationMigrationSpecVaultDetails
	if obj != nil {
		objs = []MigrationMigrationSpecVaultDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecVaultDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MigrationMigrationSpecVaultDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MigrationMigrationSpecVaultDetails)(ptr) = MigrationMigrationSpecVaultDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MigrationMigrationSpecVaultDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecVaultDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MigrationMigrationSpecVaultDetails)(ptr) = objs[0]
			} else {
				*(*MigrationMigrationSpecVaultDetails)(ptr) = MigrationMigrationSpecVaultDetails{}
			}
		} else {
			*(*MigrationMigrationSpecVaultDetails)(ptr) = MigrationMigrationSpecVaultDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MigrationMigrationSpecVaultDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MigrationMigrationSpecVaultDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MigrationMigrationSpecVaultDetails)(ptr) = obj
		} else {
			*(*MigrationMigrationSpecVaultDetails)(ptr) = MigrationMigrationSpecVaultDetails{}
		}
	default:
		iter.ReportError("decode MigrationMigrationSpecVaultDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PluggableDatabaseSpecConnectionStringsCodec struct {
}

func (PluggableDatabaseSpecConnectionStringsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PluggableDatabaseSpecConnectionStrings)(ptr) == nil
}

func (PluggableDatabaseSpecConnectionStringsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PluggableDatabaseSpecConnectionStrings)(ptr)
	var objs []PluggableDatabaseSpecConnectionStrings
	if obj != nil {
		objs = []PluggableDatabaseSpecConnectionStrings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PluggableDatabaseSpecConnectionStrings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PluggableDatabaseSpecConnectionStringsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PluggableDatabaseSpecConnectionStrings)(ptr) = PluggableDatabaseSpecConnectionStrings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PluggableDatabaseSpecConnectionStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PluggableDatabaseSpecConnectionStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PluggableDatabaseSpecConnectionStrings)(ptr) = objs[0]
			} else {
				*(*PluggableDatabaseSpecConnectionStrings)(ptr) = PluggableDatabaseSpecConnectionStrings{}
			}
		} else {
			*(*PluggableDatabaseSpecConnectionStrings)(ptr) = PluggableDatabaseSpecConnectionStrings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj PluggableDatabaseSpecConnectionStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PluggableDatabaseSpecConnectionStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*PluggableDatabaseSpecConnectionStrings)(ptr) = obj
		} else {
			*(*PluggableDatabaseSpecConnectionStrings)(ptr) = PluggableDatabaseSpecConnectionStrings{}
		}
	default:
		iter.ReportError("decode PluggableDatabaseSpecConnectionStrings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PluggableDatabasesLocalCloneSpecConnectionStringsCodec struct {
}

func (PluggableDatabasesLocalCloneSpecConnectionStringsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PluggableDatabasesLocalCloneSpecConnectionStrings)(ptr) == nil
}

func (PluggableDatabasesLocalCloneSpecConnectionStringsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PluggableDatabasesLocalCloneSpecConnectionStrings)(ptr)
	var objs []PluggableDatabasesLocalCloneSpecConnectionStrings
	if obj != nil {
		objs = []PluggableDatabasesLocalCloneSpecConnectionStrings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PluggableDatabasesLocalCloneSpecConnectionStrings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PluggableDatabasesLocalCloneSpecConnectionStringsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PluggableDatabasesLocalCloneSpecConnectionStrings)(ptr) = PluggableDatabasesLocalCloneSpecConnectionStrings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PluggableDatabasesLocalCloneSpecConnectionStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PluggableDatabasesLocalCloneSpecConnectionStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PluggableDatabasesLocalCloneSpecConnectionStrings)(ptr) = objs[0]
			} else {
				*(*PluggableDatabasesLocalCloneSpecConnectionStrings)(ptr) = PluggableDatabasesLocalCloneSpecConnectionStrings{}
			}
		} else {
			*(*PluggableDatabasesLocalCloneSpecConnectionStrings)(ptr) = PluggableDatabasesLocalCloneSpecConnectionStrings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj PluggableDatabasesLocalCloneSpecConnectionStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PluggableDatabasesLocalCloneSpecConnectionStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*PluggableDatabasesLocalCloneSpecConnectionStrings)(ptr) = obj
		} else {
			*(*PluggableDatabasesLocalCloneSpecConnectionStrings)(ptr) = PluggableDatabasesLocalCloneSpecConnectionStrings{}
		}
	default:
		iter.ReportError("decode PluggableDatabasesLocalCloneSpecConnectionStrings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PluggableDatabasesRemoteCloneSpecConnectionStringsCodec struct {
}

func (PluggableDatabasesRemoteCloneSpecConnectionStringsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PluggableDatabasesRemoteCloneSpecConnectionStrings)(ptr) == nil
}

func (PluggableDatabasesRemoteCloneSpecConnectionStringsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PluggableDatabasesRemoteCloneSpecConnectionStrings)(ptr)
	var objs []PluggableDatabasesRemoteCloneSpecConnectionStrings
	if obj != nil {
		objs = []PluggableDatabasesRemoteCloneSpecConnectionStrings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PluggableDatabasesRemoteCloneSpecConnectionStrings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PluggableDatabasesRemoteCloneSpecConnectionStringsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PluggableDatabasesRemoteCloneSpecConnectionStrings)(ptr) = PluggableDatabasesRemoteCloneSpecConnectionStrings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PluggableDatabasesRemoteCloneSpecConnectionStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PluggableDatabasesRemoteCloneSpecConnectionStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PluggableDatabasesRemoteCloneSpecConnectionStrings)(ptr) = objs[0]
			} else {
				*(*PluggableDatabasesRemoteCloneSpecConnectionStrings)(ptr) = PluggableDatabasesRemoteCloneSpecConnectionStrings{}
			}
		} else {
			*(*PluggableDatabasesRemoteCloneSpecConnectionStrings)(ptr) = PluggableDatabasesRemoteCloneSpecConnectionStrings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj PluggableDatabasesRemoteCloneSpecConnectionStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PluggableDatabasesRemoteCloneSpecConnectionStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*PluggableDatabasesRemoteCloneSpecConnectionStrings)(ptr) = obj
		} else {
			*(*PluggableDatabasesRemoteCloneSpecConnectionStrings)(ptr) = PluggableDatabasesRemoteCloneSpecConnectionStrings{}
		}
	default:
		iter.ReportError("decode PluggableDatabasesRemoteCloneSpecConnectionStrings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContentCodec struct {
}

func (ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContentCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent)(ptr) == nil
}

func (ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContentCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent)(ptr)
	var objs []ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent
	if obj != nil {
		objs = []ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContentCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent)(ptr) = ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent)(ptr) = objs[0]
			} else {
				*(*ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent)(ptr) = ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent{}
			}
		} else {
			*(*ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent)(ptr) = ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent)(ptr) = obj
		} else {
			*(*ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent)(ptr) = ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent{}
		}
	default:
		iter.ReportError("decode ToolsDatabaseToolsConnectionSpecKeyStoresKeyStoreContent", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePasswordCodec struct {
}

func (ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword)(ptr) == nil
}

func (ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword)(ptr)
	var objs []ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword
	if obj != nil {
		objs = []ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword)(ptr) = ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword)(ptr) = objs[0]
			} else {
				*(*ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword)(ptr) = ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword{}
			}
		} else {
			*(*ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword)(ptr) = ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword)(ptr) = obj
		} else {
			*(*ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword)(ptr) = ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword{}
		}
	default:
		iter.ReportError("decode ToolsDatabaseToolsConnectionSpecKeyStoresKeyStorePassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ToolsDatabaseToolsConnectionSpecRelatedResourceCodec struct {
}

func (ToolsDatabaseToolsConnectionSpecRelatedResourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ToolsDatabaseToolsConnectionSpecRelatedResource)(ptr) == nil
}

func (ToolsDatabaseToolsConnectionSpecRelatedResourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ToolsDatabaseToolsConnectionSpecRelatedResource)(ptr)
	var objs []ToolsDatabaseToolsConnectionSpecRelatedResource
	if obj != nil {
		objs = []ToolsDatabaseToolsConnectionSpecRelatedResource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecRelatedResource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ToolsDatabaseToolsConnectionSpecRelatedResourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ToolsDatabaseToolsConnectionSpecRelatedResource)(ptr) = ToolsDatabaseToolsConnectionSpecRelatedResource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ToolsDatabaseToolsConnectionSpecRelatedResource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecRelatedResource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ToolsDatabaseToolsConnectionSpecRelatedResource)(ptr) = objs[0]
			} else {
				*(*ToolsDatabaseToolsConnectionSpecRelatedResource)(ptr) = ToolsDatabaseToolsConnectionSpecRelatedResource{}
			}
		} else {
			*(*ToolsDatabaseToolsConnectionSpecRelatedResource)(ptr) = ToolsDatabaseToolsConnectionSpecRelatedResource{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ToolsDatabaseToolsConnectionSpecRelatedResource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecRelatedResource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ToolsDatabaseToolsConnectionSpecRelatedResource)(ptr) = obj
		} else {
			*(*ToolsDatabaseToolsConnectionSpecRelatedResource)(ptr) = ToolsDatabaseToolsConnectionSpecRelatedResource{}
		}
	default:
		iter.ReportError("decode ToolsDatabaseToolsConnectionSpecRelatedResource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ToolsDatabaseToolsConnectionSpecUserPasswordCodec struct {
}

func (ToolsDatabaseToolsConnectionSpecUserPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ToolsDatabaseToolsConnectionSpecUserPassword)(ptr) == nil
}

func (ToolsDatabaseToolsConnectionSpecUserPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ToolsDatabaseToolsConnectionSpecUserPassword)(ptr)
	var objs []ToolsDatabaseToolsConnectionSpecUserPassword
	if obj != nil {
		objs = []ToolsDatabaseToolsConnectionSpecUserPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecUserPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ToolsDatabaseToolsConnectionSpecUserPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ToolsDatabaseToolsConnectionSpecUserPassword)(ptr) = ToolsDatabaseToolsConnectionSpecUserPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ToolsDatabaseToolsConnectionSpecUserPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecUserPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ToolsDatabaseToolsConnectionSpecUserPassword)(ptr) = objs[0]
			} else {
				*(*ToolsDatabaseToolsConnectionSpecUserPassword)(ptr) = ToolsDatabaseToolsConnectionSpecUserPassword{}
			}
		} else {
			*(*ToolsDatabaseToolsConnectionSpecUserPassword)(ptr) = ToolsDatabaseToolsConnectionSpecUserPassword{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ToolsDatabaseToolsConnectionSpecUserPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsConnectionSpecUserPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ToolsDatabaseToolsConnectionSpecUserPassword)(ptr) = obj
		} else {
			*(*ToolsDatabaseToolsConnectionSpecUserPassword)(ptr) = ToolsDatabaseToolsConnectionSpecUserPassword{}
		}
	default:
		iter.ReportError("decode ToolsDatabaseToolsConnectionSpecUserPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfigurationCodec struct {
}

func (ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration)(ptr) == nil
}

func (ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration)(ptr)
	var objs []ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration
	if obj != nil {
		objs = []ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration)(ptr) = ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration)(ptr) = objs[0]
			} else {
				*(*ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration)(ptr) = ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration{}
			}
		} else {
			*(*ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration)(ptr) = ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration)(ptr) = obj
		} else {
			*(*ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration)(ptr) = ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration{}
		}
	default:
		iter.ReportError("decode ToolsDatabaseToolsPrivateEndpointSpecReverseConnectionConfiguration", "unexpected JSON type")
	}
}
