/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetails{}).Type1()):                                                                ModelDeploymentSpecCategoryLogDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsAccess{}).Type1()):                                                          ModelDeploymentSpecCategoryLogDetailsAccessCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsPredict{}).Type1()):                                                         ModelDeploymentSpecCategoryLogDetailsPredictCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetails{}).Type1()):                                               ModelDeploymentSpecModelDeploymentConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}).Type1()):                      ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}).Type1()): ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}).Type1()):         ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetails{}).Type1()):                                               NotebookSessionSpecNotebookSessionConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}).Type1()):              NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetails{}).Type1()):                                                                ModelDeploymentSpecCategoryLogDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsAccess{}).Type1()):                                                          ModelDeploymentSpecCategoryLogDetailsAccessCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsPredict{}).Type1()):                                                         ModelDeploymentSpecCategoryLogDetailsPredictCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetails{}).Type1()):                                               ModelDeploymentSpecModelDeploymentConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}).Type1()):                      ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}).Type1()): ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}).Type1()):         ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetails{}).Type1()):                                               NotebookSessionSpecNotebookSessionConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}).Type1()):              NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ModelDeploymentSpecCategoryLogDetailsCodec struct {
}

func (ModelDeploymentSpecCategoryLogDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ModelDeploymentSpecCategoryLogDetails)(ptr) == nil
}

func (ModelDeploymentSpecCategoryLogDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ModelDeploymentSpecCategoryLogDetails)(ptr)
	var objs []ModelDeploymentSpecCategoryLogDetails
	if obj != nil {
		objs = []ModelDeploymentSpecCategoryLogDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ModelDeploymentSpecCategoryLogDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ModelDeploymentSpecCategoryLogDetails)(ptr) = ModelDeploymentSpecCategoryLogDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ModelDeploymentSpecCategoryLogDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ModelDeploymentSpecCategoryLogDetails)(ptr) = objs[0]
			} else {
				*(*ModelDeploymentSpecCategoryLogDetails)(ptr) = ModelDeploymentSpecCategoryLogDetails{}
			}
		} else {
			*(*ModelDeploymentSpecCategoryLogDetails)(ptr) = ModelDeploymentSpecCategoryLogDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ModelDeploymentSpecCategoryLogDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ModelDeploymentSpecCategoryLogDetails)(ptr) = obj
		} else {
			*(*ModelDeploymentSpecCategoryLogDetails)(ptr) = ModelDeploymentSpecCategoryLogDetails{}
		}
	default:
		iter.ReportError("decode ModelDeploymentSpecCategoryLogDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ModelDeploymentSpecCategoryLogDetailsAccessCodec struct {
}

func (ModelDeploymentSpecCategoryLogDetailsAccessCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ModelDeploymentSpecCategoryLogDetailsAccess)(ptr) == nil
}

func (ModelDeploymentSpecCategoryLogDetailsAccessCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ModelDeploymentSpecCategoryLogDetailsAccess)(ptr)
	var objs []ModelDeploymentSpecCategoryLogDetailsAccess
	if obj != nil {
		objs = []ModelDeploymentSpecCategoryLogDetailsAccess{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsAccess{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ModelDeploymentSpecCategoryLogDetailsAccessCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ModelDeploymentSpecCategoryLogDetailsAccess)(ptr) = ModelDeploymentSpecCategoryLogDetailsAccess{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ModelDeploymentSpecCategoryLogDetailsAccess

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsAccess{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ModelDeploymentSpecCategoryLogDetailsAccess)(ptr) = objs[0]
			} else {
				*(*ModelDeploymentSpecCategoryLogDetailsAccess)(ptr) = ModelDeploymentSpecCategoryLogDetailsAccess{}
			}
		} else {
			*(*ModelDeploymentSpecCategoryLogDetailsAccess)(ptr) = ModelDeploymentSpecCategoryLogDetailsAccess{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ModelDeploymentSpecCategoryLogDetailsAccess

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsAccess{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ModelDeploymentSpecCategoryLogDetailsAccess)(ptr) = obj
		} else {
			*(*ModelDeploymentSpecCategoryLogDetailsAccess)(ptr) = ModelDeploymentSpecCategoryLogDetailsAccess{}
		}
	default:
		iter.ReportError("decode ModelDeploymentSpecCategoryLogDetailsAccess", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ModelDeploymentSpecCategoryLogDetailsPredictCodec struct {
}

func (ModelDeploymentSpecCategoryLogDetailsPredictCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ModelDeploymentSpecCategoryLogDetailsPredict)(ptr) == nil
}

func (ModelDeploymentSpecCategoryLogDetailsPredictCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ModelDeploymentSpecCategoryLogDetailsPredict)(ptr)
	var objs []ModelDeploymentSpecCategoryLogDetailsPredict
	if obj != nil {
		objs = []ModelDeploymentSpecCategoryLogDetailsPredict{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsPredict{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ModelDeploymentSpecCategoryLogDetailsPredictCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ModelDeploymentSpecCategoryLogDetailsPredict)(ptr) = ModelDeploymentSpecCategoryLogDetailsPredict{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ModelDeploymentSpecCategoryLogDetailsPredict

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsPredict{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ModelDeploymentSpecCategoryLogDetailsPredict)(ptr) = objs[0]
			} else {
				*(*ModelDeploymentSpecCategoryLogDetailsPredict)(ptr) = ModelDeploymentSpecCategoryLogDetailsPredict{}
			}
		} else {
			*(*ModelDeploymentSpecCategoryLogDetailsPredict)(ptr) = ModelDeploymentSpecCategoryLogDetailsPredict{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ModelDeploymentSpecCategoryLogDetailsPredict

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsPredict{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ModelDeploymentSpecCategoryLogDetailsPredict)(ptr) = obj
		} else {
			*(*ModelDeploymentSpecCategoryLogDetailsPredict)(ptr) = ModelDeploymentSpecCategoryLogDetailsPredict{}
		}
	default:
		iter.ReportError("decode ModelDeploymentSpecCategoryLogDetailsPredict", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ModelDeploymentSpecModelDeploymentConfigurationDetailsCodec struct {
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ModelDeploymentSpecModelDeploymentConfigurationDetails)(ptr) == nil
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ModelDeploymentSpecModelDeploymentConfigurationDetails)(ptr)
	var objs []ModelDeploymentSpecModelDeploymentConfigurationDetails
	if obj != nil {
		objs = []ModelDeploymentSpecModelDeploymentConfigurationDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ModelDeploymentSpecModelDeploymentConfigurationDetails)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ModelDeploymentSpecModelDeploymentConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ModelDeploymentSpecModelDeploymentConfigurationDetails)(ptr) = objs[0]
			} else {
				*(*ModelDeploymentSpecModelDeploymentConfigurationDetails)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetails{}
			}
		} else {
			*(*ModelDeploymentSpecModelDeploymentConfigurationDetails)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ModelDeploymentSpecModelDeploymentConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ModelDeploymentSpecModelDeploymentConfigurationDetails)(ptr) = obj
		} else {
			*(*ModelDeploymentSpecModelDeploymentConfigurationDetails)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetails{}
		}
	default:
		iter.ReportError("decode ModelDeploymentSpecModelDeploymentConfigurationDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsCodec struct {
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails)(ptr) == nil
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails)(ptr)
	var objs []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails
	if obj != nil {
		objs = []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails)(ptr) = objs[0]
			} else {
				*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}
			}
		} else {
			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails)(ptr) = obj
		} else {
			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}
		}
	default:
		iter.ReportError("decode ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationCodec struct {
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration)(ptr) == nil
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration)(ptr)
	var objs []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration
	if obj != nil {
		objs = []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration)(ptr) = objs[0]
			} else {
				*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}
			}
		} else {
			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration)(ptr) = obj
		} else {
			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}
		}
	default:
		iter.ReportError("decode ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyCodec struct {
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy)(ptr) == nil
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy)(ptr)
	var objs []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy
	if obj != nil {
		objs = []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy)(ptr) = objs[0]
			} else {
				*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}
			}
		} else {
			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy)(ptr) = obj
		} else {
			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}
		}
	default:
		iter.ReportError("decode ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotebookSessionSpecNotebookSessionConfigurationDetailsCodec struct {
}

func (NotebookSessionSpecNotebookSessionConfigurationDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotebookSessionSpecNotebookSessionConfigurationDetails)(ptr) == nil
}

func (NotebookSessionSpecNotebookSessionConfigurationDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotebookSessionSpecNotebookSessionConfigurationDetails)(ptr)
	var objs []NotebookSessionSpecNotebookSessionConfigurationDetails
	if obj != nil {
		objs = []NotebookSessionSpecNotebookSessionConfigurationDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotebookSessionSpecNotebookSessionConfigurationDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotebookSessionSpecNotebookSessionConfigurationDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigurationDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotebookSessionSpecNotebookSessionConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotebookSessionSpecNotebookSessionConfigurationDetails)(ptr) = objs[0]
			} else {
				*(*NotebookSessionSpecNotebookSessionConfigurationDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigurationDetails{}
			}
		} else {
			*(*NotebookSessionSpecNotebookSessionConfigurationDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigurationDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotebookSessionSpecNotebookSessionConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotebookSessionSpecNotebookSessionConfigurationDetails)(ptr) = obj
		} else {
			*(*NotebookSessionSpecNotebookSessionConfigurationDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigurationDetails{}
		}
	default:
		iter.ReportError("decode NotebookSessionSpecNotebookSessionConfigurationDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsCodec struct {
}

func (NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails)(ptr) == nil
}

func (NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails)(ptr)
	var objs []NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails
	if obj != nil {
		objs = []NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails)(ptr) = objs[0]
			} else {
				*(*NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}
			}
		} else {
			*(*NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails)(ptr) = obj
		} else {
			*(*NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}
		}
	default:
		iter.ReportError("decode NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails", "unexpected JSON type")
	}
}
