/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecJobConfigurationDetails{}).Type1()):                                                                       JobSpecJobConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecJobInfrastructureConfigurationDetails{}).Type1()):                                                         JobSpecJobInfrastructureConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecJobLogConfigurationDetails{}).Type1()):                                                                    JobSpecJobLogConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecJobConfigurationOverrideDetails{}).Type1()):                                                            JobRunSpecJobConfigurationOverrideDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecJobInfrastructureConfigurationDetails{}).Type1()):                                                      JobRunSpecJobInfrastructureConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecJobLogConfigurationOverrideDetails{}).Type1()):                                                         JobRunSpecJobLogConfigurationOverrideDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecLogDetails{}).Type1()):                                                                                 JobRunSpecLogDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetails{}).Type1()):                                                                ModelDeploymentSpecCategoryLogDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsAccess{}).Type1()):                                                          ModelDeploymentSpecCategoryLogDetailsAccessCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsPredict{}).Type1()):                                                         ModelDeploymentSpecCategoryLogDetailsPredictCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetails{}).Type1()):                                               ModelDeploymentSpecModelDeploymentConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}).Type1()):                      ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}).Type1()): ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}).Type1()):         ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigDetails{}).Type1()):                                                      NotebookSessionSpecNotebookSessionConfigDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails{}).Type1()):                     NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetails{}).Type1()):                                               NotebookSessionSpecNotebookSessionConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}).Type1()):              NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecJobConfigurationDetails{}).Type1()):                                                                       JobSpecJobConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecJobInfrastructureConfigurationDetails{}).Type1()):                                                         JobSpecJobInfrastructureConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecJobLogConfigurationDetails{}).Type1()):                                                                    JobSpecJobLogConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecJobConfigurationOverrideDetails{}).Type1()):                                                            JobRunSpecJobConfigurationOverrideDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecJobInfrastructureConfigurationDetails{}).Type1()):                                                      JobRunSpecJobInfrastructureConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecJobLogConfigurationOverrideDetails{}).Type1()):                                                         JobRunSpecJobLogConfigurationOverrideDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecLogDetails{}).Type1()):                                                                                 JobRunSpecLogDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetails{}).Type1()):                                                                ModelDeploymentSpecCategoryLogDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsAccess{}).Type1()):                                                          ModelDeploymentSpecCategoryLogDetailsAccessCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsPredict{}).Type1()):                                                         ModelDeploymentSpecCategoryLogDetailsPredictCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetails{}).Type1()):                                               ModelDeploymentSpecModelDeploymentConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}).Type1()):                      ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}).Type1()): ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}).Type1()):         ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigDetails{}).Type1()):                                                      NotebookSessionSpecNotebookSessionConfigDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails{}).Type1()):                     NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetails{}).Type1()):                                               NotebookSessionSpecNotebookSessionConfigurationDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}).Type1()):              NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type JobSpecJobConfigurationDetailsCodec struct {
}

func (JobSpecJobConfigurationDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecJobConfigurationDetails)(ptr) == nil
}

func (JobSpecJobConfigurationDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecJobConfigurationDetails)(ptr)
	var objs []JobSpecJobConfigurationDetails
	if obj != nil {
		objs = []JobSpecJobConfigurationDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecJobConfigurationDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecJobConfigurationDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecJobConfigurationDetails)(ptr) = JobSpecJobConfigurationDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecJobConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecJobConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecJobConfigurationDetails)(ptr) = objs[0]
			} else {
				*(*JobSpecJobConfigurationDetails)(ptr) = JobSpecJobConfigurationDetails{}
			}
		} else {
			*(*JobSpecJobConfigurationDetails)(ptr) = JobSpecJobConfigurationDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecJobConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecJobConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecJobConfigurationDetails)(ptr) = obj
		} else {
			*(*JobSpecJobConfigurationDetails)(ptr) = JobSpecJobConfigurationDetails{}
		}
	default:
		iter.ReportError("decode JobSpecJobConfigurationDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecJobInfrastructureConfigurationDetailsCodec struct {
}

func (JobSpecJobInfrastructureConfigurationDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecJobInfrastructureConfigurationDetails)(ptr) == nil
}

func (JobSpecJobInfrastructureConfigurationDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecJobInfrastructureConfigurationDetails)(ptr)
	var objs []JobSpecJobInfrastructureConfigurationDetails
	if obj != nil {
		objs = []JobSpecJobInfrastructureConfigurationDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecJobInfrastructureConfigurationDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecJobInfrastructureConfigurationDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecJobInfrastructureConfigurationDetails)(ptr) = JobSpecJobInfrastructureConfigurationDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecJobInfrastructureConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecJobInfrastructureConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecJobInfrastructureConfigurationDetails)(ptr) = objs[0]
			} else {
				*(*JobSpecJobInfrastructureConfigurationDetails)(ptr) = JobSpecJobInfrastructureConfigurationDetails{}
			}
		} else {
			*(*JobSpecJobInfrastructureConfigurationDetails)(ptr) = JobSpecJobInfrastructureConfigurationDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecJobInfrastructureConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecJobInfrastructureConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecJobInfrastructureConfigurationDetails)(ptr) = obj
		} else {
			*(*JobSpecJobInfrastructureConfigurationDetails)(ptr) = JobSpecJobInfrastructureConfigurationDetails{}
		}
	default:
		iter.ReportError("decode JobSpecJobInfrastructureConfigurationDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecJobLogConfigurationDetailsCodec struct {
}

func (JobSpecJobLogConfigurationDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecJobLogConfigurationDetails)(ptr) == nil
}

func (JobSpecJobLogConfigurationDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecJobLogConfigurationDetails)(ptr)
	var objs []JobSpecJobLogConfigurationDetails
	if obj != nil {
		objs = []JobSpecJobLogConfigurationDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecJobLogConfigurationDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecJobLogConfigurationDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecJobLogConfigurationDetails)(ptr) = JobSpecJobLogConfigurationDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecJobLogConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecJobLogConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecJobLogConfigurationDetails)(ptr) = objs[0]
			} else {
				*(*JobSpecJobLogConfigurationDetails)(ptr) = JobSpecJobLogConfigurationDetails{}
			}
		} else {
			*(*JobSpecJobLogConfigurationDetails)(ptr) = JobSpecJobLogConfigurationDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobSpecJobLogConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecJobLogConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobSpecJobLogConfigurationDetails)(ptr) = obj
		} else {
			*(*JobSpecJobLogConfigurationDetails)(ptr) = JobSpecJobLogConfigurationDetails{}
		}
	default:
		iter.ReportError("decode JobSpecJobLogConfigurationDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobRunSpecJobConfigurationOverrideDetailsCodec struct {
}

func (JobRunSpecJobConfigurationOverrideDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobRunSpecJobConfigurationOverrideDetails)(ptr) == nil
}

func (JobRunSpecJobConfigurationOverrideDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobRunSpecJobConfigurationOverrideDetails)(ptr)
	var objs []JobRunSpecJobConfigurationOverrideDetails
	if obj != nil {
		objs = []JobRunSpecJobConfigurationOverrideDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecJobConfigurationOverrideDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobRunSpecJobConfigurationOverrideDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobRunSpecJobConfigurationOverrideDetails)(ptr) = JobRunSpecJobConfigurationOverrideDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobRunSpecJobConfigurationOverrideDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecJobConfigurationOverrideDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobRunSpecJobConfigurationOverrideDetails)(ptr) = objs[0]
			} else {
				*(*JobRunSpecJobConfigurationOverrideDetails)(ptr) = JobRunSpecJobConfigurationOverrideDetails{}
			}
		} else {
			*(*JobRunSpecJobConfigurationOverrideDetails)(ptr) = JobRunSpecJobConfigurationOverrideDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobRunSpecJobConfigurationOverrideDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecJobConfigurationOverrideDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobRunSpecJobConfigurationOverrideDetails)(ptr) = obj
		} else {
			*(*JobRunSpecJobConfigurationOverrideDetails)(ptr) = JobRunSpecJobConfigurationOverrideDetails{}
		}
	default:
		iter.ReportError("decode JobRunSpecJobConfigurationOverrideDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobRunSpecJobInfrastructureConfigurationDetailsCodec struct {
}

func (JobRunSpecJobInfrastructureConfigurationDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobRunSpecJobInfrastructureConfigurationDetails)(ptr) == nil
}

func (JobRunSpecJobInfrastructureConfigurationDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobRunSpecJobInfrastructureConfigurationDetails)(ptr)
	var objs []JobRunSpecJobInfrastructureConfigurationDetails
	if obj != nil {
		objs = []JobRunSpecJobInfrastructureConfigurationDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecJobInfrastructureConfigurationDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobRunSpecJobInfrastructureConfigurationDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobRunSpecJobInfrastructureConfigurationDetails)(ptr) = JobRunSpecJobInfrastructureConfigurationDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobRunSpecJobInfrastructureConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecJobInfrastructureConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobRunSpecJobInfrastructureConfigurationDetails)(ptr) = objs[0]
			} else {
				*(*JobRunSpecJobInfrastructureConfigurationDetails)(ptr) = JobRunSpecJobInfrastructureConfigurationDetails{}
			}
		} else {
			*(*JobRunSpecJobInfrastructureConfigurationDetails)(ptr) = JobRunSpecJobInfrastructureConfigurationDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobRunSpecJobInfrastructureConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecJobInfrastructureConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobRunSpecJobInfrastructureConfigurationDetails)(ptr) = obj
		} else {
			*(*JobRunSpecJobInfrastructureConfigurationDetails)(ptr) = JobRunSpecJobInfrastructureConfigurationDetails{}
		}
	default:
		iter.ReportError("decode JobRunSpecJobInfrastructureConfigurationDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobRunSpecJobLogConfigurationOverrideDetailsCodec struct {
}

func (JobRunSpecJobLogConfigurationOverrideDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobRunSpecJobLogConfigurationOverrideDetails)(ptr) == nil
}

func (JobRunSpecJobLogConfigurationOverrideDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobRunSpecJobLogConfigurationOverrideDetails)(ptr)
	var objs []JobRunSpecJobLogConfigurationOverrideDetails
	if obj != nil {
		objs = []JobRunSpecJobLogConfigurationOverrideDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecJobLogConfigurationOverrideDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobRunSpecJobLogConfigurationOverrideDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobRunSpecJobLogConfigurationOverrideDetails)(ptr) = JobRunSpecJobLogConfigurationOverrideDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobRunSpecJobLogConfigurationOverrideDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecJobLogConfigurationOverrideDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobRunSpecJobLogConfigurationOverrideDetails)(ptr) = objs[0]
			} else {
				*(*JobRunSpecJobLogConfigurationOverrideDetails)(ptr) = JobRunSpecJobLogConfigurationOverrideDetails{}
			}
		} else {
			*(*JobRunSpecJobLogConfigurationOverrideDetails)(ptr) = JobRunSpecJobLogConfigurationOverrideDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobRunSpecJobLogConfigurationOverrideDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecJobLogConfigurationOverrideDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobRunSpecJobLogConfigurationOverrideDetails)(ptr) = obj
		} else {
			*(*JobRunSpecJobLogConfigurationOverrideDetails)(ptr) = JobRunSpecJobLogConfigurationOverrideDetails{}
		}
	default:
		iter.ReportError("decode JobRunSpecJobLogConfigurationOverrideDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobRunSpecLogDetailsCodec struct {
}

func (JobRunSpecLogDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobRunSpecLogDetails)(ptr) == nil
}

func (JobRunSpecLogDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobRunSpecLogDetails)(ptr)
	var objs []JobRunSpecLogDetails
	if obj != nil {
		objs = []JobRunSpecLogDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecLogDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobRunSpecLogDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobRunSpecLogDetails)(ptr) = JobRunSpecLogDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobRunSpecLogDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecLogDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobRunSpecLogDetails)(ptr) = objs[0]
			} else {
				*(*JobRunSpecLogDetails)(ptr) = JobRunSpecLogDetails{}
			}
		} else {
			*(*JobRunSpecLogDetails)(ptr) = JobRunSpecLogDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj JobRunSpecLogDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobRunSpecLogDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*JobRunSpecLogDetails)(ptr) = obj
		} else {
			*(*JobRunSpecLogDetails)(ptr) = JobRunSpecLogDetails{}
		}
	default:
		iter.ReportError("decode JobRunSpecLogDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ModelDeploymentSpecCategoryLogDetailsCodec struct {
}

func (ModelDeploymentSpecCategoryLogDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ModelDeploymentSpecCategoryLogDetails)(ptr) == nil
}

func (ModelDeploymentSpecCategoryLogDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ModelDeploymentSpecCategoryLogDetails)(ptr)
	var objs []ModelDeploymentSpecCategoryLogDetails
	if obj != nil {
		objs = []ModelDeploymentSpecCategoryLogDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ModelDeploymentSpecCategoryLogDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ModelDeploymentSpecCategoryLogDetails)(ptr) = ModelDeploymentSpecCategoryLogDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ModelDeploymentSpecCategoryLogDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ModelDeploymentSpecCategoryLogDetails)(ptr) = objs[0]
			} else {
				*(*ModelDeploymentSpecCategoryLogDetails)(ptr) = ModelDeploymentSpecCategoryLogDetails{}
			}
		} else {
			*(*ModelDeploymentSpecCategoryLogDetails)(ptr) = ModelDeploymentSpecCategoryLogDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ModelDeploymentSpecCategoryLogDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ModelDeploymentSpecCategoryLogDetails)(ptr) = obj
		} else {
			*(*ModelDeploymentSpecCategoryLogDetails)(ptr) = ModelDeploymentSpecCategoryLogDetails{}
		}
	default:
		iter.ReportError("decode ModelDeploymentSpecCategoryLogDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ModelDeploymentSpecCategoryLogDetailsAccessCodec struct {
}

func (ModelDeploymentSpecCategoryLogDetailsAccessCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ModelDeploymentSpecCategoryLogDetailsAccess)(ptr) == nil
}

func (ModelDeploymentSpecCategoryLogDetailsAccessCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ModelDeploymentSpecCategoryLogDetailsAccess)(ptr)
	var objs []ModelDeploymentSpecCategoryLogDetailsAccess
	if obj != nil {
		objs = []ModelDeploymentSpecCategoryLogDetailsAccess{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsAccess{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ModelDeploymentSpecCategoryLogDetailsAccessCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ModelDeploymentSpecCategoryLogDetailsAccess)(ptr) = ModelDeploymentSpecCategoryLogDetailsAccess{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ModelDeploymentSpecCategoryLogDetailsAccess

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsAccess{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ModelDeploymentSpecCategoryLogDetailsAccess)(ptr) = objs[0]
			} else {
				*(*ModelDeploymentSpecCategoryLogDetailsAccess)(ptr) = ModelDeploymentSpecCategoryLogDetailsAccess{}
			}
		} else {
			*(*ModelDeploymentSpecCategoryLogDetailsAccess)(ptr) = ModelDeploymentSpecCategoryLogDetailsAccess{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ModelDeploymentSpecCategoryLogDetailsAccess

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsAccess{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ModelDeploymentSpecCategoryLogDetailsAccess)(ptr) = obj
		} else {
			*(*ModelDeploymentSpecCategoryLogDetailsAccess)(ptr) = ModelDeploymentSpecCategoryLogDetailsAccess{}
		}
	default:
		iter.ReportError("decode ModelDeploymentSpecCategoryLogDetailsAccess", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ModelDeploymentSpecCategoryLogDetailsPredictCodec struct {
}

func (ModelDeploymentSpecCategoryLogDetailsPredictCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ModelDeploymentSpecCategoryLogDetailsPredict)(ptr) == nil
}

func (ModelDeploymentSpecCategoryLogDetailsPredictCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ModelDeploymentSpecCategoryLogDetailsPredict)(ptr)
	var objs []ModelDeploymentSpecCategoryLogDetailsPredict
	if obj != nil {
		objs = []ModelDeploymentSpecCategoryLogDetailsPredict{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsPredict{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ModelDeploymentSpecCategoryLogDetailsPredictCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ModelDeploymentSpecCategoryLogDetailsPredict)(ptr) = ModelDeploymentSpecCategoryLogDetailsPredict{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ModelDeploymentSpecCategoryLogDetailsPredict

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsPredict{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ModelDeploymentSpecCategoryLogDetailsPredict)(ptr) = objs[0]
			} else {
				*(*ModelDeploymentSpecCategoryLogDetailsPredict)(ptr) = ModelDeploymentSpecCategoryLogDetailsPredict{}
			}
		} else {
			*(*ModelDeploymentSpecCategoryLogDetailsPredict)(ptr) = ModelDeploymentSpecCategoryLogDetailsPredict{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ModelDeploymentSpecCategoryLogDetailsPredict

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecCategoryLogDetailsPredict{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ModelDeploymentSpecCategoryLogDetailsPredict)(ptr) = obj
		} else {
			*(*ModelDeploymentSpecCategoryLogDetailsPredict)(ptr) = ModelDeploymentSpecCategoryLogDetailsPredict{}
		}
	default:
		iter.ReportError("decode ModelDeploymentSpecCategoryLogDetailsPredict", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ModelDeploymentSpecModelDeploymentConfigurationDetailsCodec struct {
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ModelDeploymentSpecModelDeploymentConfigurationDetails)(ptr) == nil
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ModelDeploymentSpecModelDeploymentConfigurationDetails)(ptr)
	var objs []ModelDeploymentSpecModelDeploymentConfigurationDetails
	if obj != nil {
		objs = []ModelDeploymentSpecModelDeploymentConfigurationDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ModelDeploymentSpecModelDeploymentConfigurationDetails)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ModelDeploymentSpecModelDeploymentConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ModelDeploymentSpecModelDeploymentConfigurationDetails)(ptr) = objs[0]
			} else {
				*(*ModelDeploymentSpecModelDeploymentConfigurationDetails)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetails{}
			}
		} else {
			*(*ModelDeploymentSpecModelDeploymentConfigurationDetails)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ModelDeploymentSpecModelDeploymentConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ModelDeploymentSpecModelDeploymentConfigurationDetails)(ptr) = obj
		} else {
			*(*ModelDeploymentSpecModelDeploymentConfigurationDetails)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetails{}
		}
	default:
		iter.ReportError("decode ModelDeploymentSpecModelDeploymentConfigurationDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsCodec struct {
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails)(ptr) == nil
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails)(ptr)
	var objs []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails
	if obj != nil {
		objs = []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails)(ptr) = objs[0]
			} else {
				*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}
			}
		} else {
			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails)(ptr) = obj
		} else {
			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails{}
		}
	default:
		iter.ReportError("decode ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationCodec struct {
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration)(ptr) == nil
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration)(ptr)
	var objs []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration
	if obj != nil {
		objs = []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration)(ptr) = objs[0]
			} else {
				*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}
			}
		} else {
			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration)(ptr) = obj
		} else {
			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration{}
		}
	default:
		iter.ReportError("decode ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyCodec struct {
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy)(ptr) == nil
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy)(ptr)
	var objs []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy
	if obj != nil {
		objs = []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy)(ptr) = objs[0]
			} else {
				*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}
			}
		} else {
			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy)(ptr) = obj
		} else {
			*(*ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy)(ptr) = ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy{}
		}
	default:
		iter.ReportError("decode ModelDeploymentSpecModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotebookSessionSpecNotebookSessionConfigDetailsCodec struct {
}

func (NotebookSessionSpecNotebookSessionConfigDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotebookSessionSpecNotebookSessionConfigDetails)(ptr) == nil
}

func (NotebookSessionSpecNotebookSessionConfigDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotebookSessionSpecNotebookSessionConfigDetails)(ptr)
	var objs []NotebookSessionSpecNotebookSessionConfigDetails
	if obj != nil {
		objs = []NotebookSessionSpecNotebookSessionConfigDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotebookSessionSpecNotebookSessionConfigDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotebookSessionSpecNotebookSessionConfigDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotebookSessionSpecNotebookSessionConfigDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotebookSessionSpecNotebookSessionConfigDetails)(ptr) = objs[0]
			} else {
				*(*NotebookSessionSpecNotebookSessionConfigDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigDetails{}
			}
		} else {
			*(*NotebookSessionSpecNotebookSessionConfigDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotebookSessionSpecNotebookSessionConfigDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotebookSessionSpecNotebookSessionConfigDetails)(ptr) = obj
		} else {
			*(*NotebookSessionSpecNotebookSessionConfigDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigDetails{}
		}
	default:
		iter.ReportError("decode NotebookSessionSpecNotebookSessionConfigDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetailsCodec struct {
}

func (NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails)(ptr) == nil
}

func (NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails)(ptr)
	var objs []NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails
	if obj != nil {
		objs = []NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails)(ptr) = objs[0]
			} else {
				*(*NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails{}
			}
		} else {
			*(*NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails)(ptr) = obj
		} else {
			*(*NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails{}
		}
	default:
		iter.ReportError("decode NotebookSessionSpecNotebookSessionConfigDetailsNotebookSessionShapeConfigDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotebookSessionSpecNotebookSessionConfigurationDetailsCodec struct {
}

func (NotebookSessionSpecNotebookSessionConfigurationDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotebookSessionSpecNotebookSessionConfigurationDetails)(ptr) == nil
}

func (NotebookSessionSpecNotebookSessionConfigurationDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotebookSessionSpecNotebookSessionConfigurationDetails)(ptr)
	var objs []NotebookSessionSpecNotebookSessionConfigurationDetails
	if obj != nil {
		objs = []NotebookSessionSpecNotebookSessionConfigurationDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotebookSessionSpecNotebookSessionConfigurationDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotebookSessionSpecNotebookSessionConfigurationDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigurationDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotebookSessionSpecNotebookSessionConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotebookSessionSpecNotebookSessionConfigurationDetails)(ptr) = objs[0]
			} else {
				*(*NotebookSessionSpecNotebookSessionConfigurationDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigurationDetails{}
			}
		} else {
			*(*NotebookSessionSpecNotebookSessionConfigurationDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigurationDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotebookSessionSpecNotebookSessionConfigurationDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotebookSessionSpecNotebookSessionConfigurationDetails)(ptr) = obj
		} else {
			*(*NotebookSessionSpecNotebookSessionConfigurationDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigurationDetails{}
		}
	default:
		iter.ReportError("decode NotebookSessionSpecNotebookSessionConfigurationDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsCodec struct {
}

func (NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails)(ptr) == nil
}

func (NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails)(ptr)
	var objs []NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails
	if obj != nil {
		objs = []NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails)(ptr) = objs[0]
			} else {
				*(*NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}
			}
		} else {
			*(*NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails)(ptr) = obj
		} else {
			*(*NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails)(ptr) = NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails{}
		}
	default:
		iter.ReportError("decode NotebookSessionSpecNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetails", "unexpected JSON type")
	}
}
