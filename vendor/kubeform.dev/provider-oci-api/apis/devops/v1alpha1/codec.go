/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DeployArtifactSpecDeployArtifactSource{}).Type1()):                                DeployArtifactSpecDeployArtifactSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployEnvironmentSpecComputeInstanceGroupSelectors{}).Type1()):                    DeployEnvironmentSpecComputeInstanceGroupSelectorsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifacts{}).Type1()):                             DeployPipelineSpecDeployPipelineArtifactsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1()):    DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironments{}).Type1()):                          DeployPipelineSpecDeployPipelineEnvironmentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1()): DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineParameters{}).Type1()):                            DeployPipelineSpecDeployPipelineParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecApprovalPolicy{}).Type1()):                                         DeployStageSpecApprovalPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecBlueBackendIPS{}).Type1()):                                         DeployStageSpecBlueBackendIPSCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecDeployStagePredecessorCollection{}).Type1()):                       DeployStageSpecDeployStagePredecessorCollectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecFailurePolicy{}).Type1()):                                          DeployStageSpecFailurePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecGreenBackendIPS{}).Type1()):                                        DeployStageSpecGreenBackendIPSCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecLoadBalancerConfig{}).Type1()):                                     DeployStageSpecLoadBalancerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRollbackPolicy{}).Type1()):                                         DeployStageSpecRollbackPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRolloutPolicy{}).Type1()):                                          DeployStageSpecRolloutPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecWaitCriteria{}).Type1()):                                           DeployStageSpecWaitCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployArtifactOverrideArguments{}).Type1()):                         DeploymentSpecDeployArtifactOverrideArgumentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifacts{}).Type1()):                                 DeploymentSpecDeployPipelineArtifactsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1()):        DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironments{}).Type1()):                              DeploymentSpecDeployPipelineEnvironmentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1()):     DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentArguments{}).Type1()):                                     DeploymentSpecDeploymentArgumentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentExecutionProgress{}).Type1()):                             DeploymentSpecDeploymentExecutionProgressCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ProjectSpecNotificationConfig{}).Type1()):                                         ProjectSpecNotificationConfigCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DeployArtifactSpecDeployArtifactSource{}).Type1()):                                DeployArtifactSpecDeployArtifactSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployEnvironmentSpecComputeInstanceGroupSelectors{}).Type1()):                    DeployEnvironmentSpecComputeInstanceGroupSelectorsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifacts{}).Type1()):                             DeployPipelineSpecDeployPipelineArtifactsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1()):    DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironments{}).Type1()):                          DeployPipelineSpecDeployPipelineEnvironmentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1()): DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineParameters{}).Type1()):                            DeployPipelineSpecDeployPipelineParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecApprovalPolicy{}).Type1()):                                         DeployStageSpecApprovalPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecBlueBackendIPS{}).Type1()):                                         DeployStageSpecBlueBackendIPSCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecDeployStagePredecessorCollection{}).Type1()):                       DeployStageSpecDeployStagePredecessorCollectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecFailurePolicy{}).Type1()):                                          DeployStageSpecFailurePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecGreenBackendIPS{}).Type1()):                                        DeployStageSpecGreenBackendIPSCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecLoadBalancerConfig{}).Type1()):                                     DeployStageSpecLoadBalancerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRollbackPolicy{}).Type1()):                                         DeployStageSpecRollbackPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRolloutPolicy{}).Type1()):                                          DeployStageSpecRolloutPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecWaitCriteria{}).Type1()):                                           DeployStageSpecWaitCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployArtifactOverrideArguments{}).Type1()):                         DeploymentSpecDeployArtifactOverrideArgumentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifacts{}).Type1()):                                 DeploymentSpecDeployPipelineArtifactsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1()):        DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironments{}).Type1()):                              DeploymentSpecDeployPipelineEnvironmentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1()):     DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentArguments{}).Type1()):                                     DeploymentSpecDeploymentArgumentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentExecutionProgress{}).Type1()):                             DeploymentSpecDeploymentExecutionProgressCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ProjectSpecNotificationConfig{}).Type1()):                                         ProjectSpecNotificationConfigCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type DeployArtifactSpecDeployArtifactSourceCodec struct {
}

func (DeployArtifactSpecDeployArtifactSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployArtifactSpecDeployArtifactSource)(ptr) == nil
}

func (DeployArtifactSpecDeployArtifactSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployArtifactSpecDeployArtifactSource)(ptr)
	var objs []DeployArtifactSpecDeployArtifactSource
	if obj != nil {
		objs = []DeployArtifactSpecDeployArtifactSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployArtifactSpecDeployArtifactSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployArtifactSpecDeployArtifactSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployArtifactSpecDeployArtifactSource)(ptr) = DeployArtifactSpecDeployArtifactSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployArtifactSpecDeployArtifactSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployArtifactSpecDeployArtifactSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployArtifactSpecDeployArtifactSource)(ptr) = objs[0]
			} else {
				*(*DeployArtifactSpecDeployArtifactSource)(ptr) = DeployArtifactSpecDeployArtifactSource{}
			}
		} else {
			*(*DeployArtifactSpecDeployArtifactSource)(ptr) = DeployArtifactSpecDeployArtifactSource{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployArtifactSpecDeployArtifactSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployArtifactSpecDeployArtifactSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployArtifactSpecDeployArtifactSource)(ptr) = obj
		} else {
			*(*DeployArtifactSpecDeployArtifactSource)(ptr) = DeployArtifactSpecDeployArtifactSource{}
		}
	default:
		iter.ReportError("decode DeployArtifactSpecDeployArtifactSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployEnvironmentSpecComputeInstanceGroupSelectorsCodec struct {
}

func (DeployEnvironmentSpecComputeInstanceGroupSelectorsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployEnvironmentSpecComputeInstanceGroupSelectors)(ptr) == nil
}

func (DeployEnvironmentSpecComputeInstanceGroupSelectorsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployEnvironmentSpecComputeInstanceGroupSelectors)(ptr)
	var objs []DeployEnvironmentSpecComputeInstanceGroupSelectors
	if obj != nil {
		objs = []DeployEnvironmentSpecComputeInstanceGroupSelectors{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployEnvironmentSpecComputeInstanceGroupSelectors{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployEnvironmentSpecComputeInstanceGroupSelectorsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployEnvironmentSpecComputeInstanceGroupSelectors)(ptr) = DeployEnvironmentSpecComputeInstanceGroupSelectors{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployEnvironmentSpecComputeInstanceGroupSelectors

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployEnvironmentSpecComputeInstanceGroupSelectors{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployEnvironmentSpecComputeInstanceGroupSelectors)(ptr) = objs[0]
			} else {
				*(*DeployEnvironmentSpecComputeInstanceGroupSelectors)(ptr) = DeployEnvironmentSpecComputeInstanceGroupSelectors{}
			}
		} else {
			*(*DeployEnvironmentSpecComputeInstanceGroupSelectors)(ptr) = DeployEnvironmentSpecComputeInstanceGroupSelectors{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployEnvironmentSpecComputeInstanceGroupSelectors

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployEnvironmentSpecComputeInstanceGroupSelectors{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployEnvironmentSpecComputeInstanceGroupSelectors)(ptr) = obj
		} else {
			*(*DeployEnvironmentSpecComputeInstanceGroupSelectors)(ptr) = DeployEnvironmentSpecComputeInstanceGroupSelectors{}
		}
	default:
		iter.ReportError("decode DeployEnvironmentSpecComputeInstanceGroupSelectors", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployPipelineSpecDeployPipelineArtifactsCodec struct {
}

func (DeployPipelineSpecDeployPipelineArtifactsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployPipelineSpecDeployPipelineArtifacts)(ptr) == nil
}

func (DeployPipelineSpecDeployPipelineArtifactsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployPipelineSpecDeployPipelineArtifacts)(ptr)
	var objs []DeployPipelineSpecDeployPipelineArtifacts
	if obj != nil {
		objs = []DeployPipelineSpecDeployPipelineArtifacts{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifacts{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployPipelineSpecDeployPipelineArtifactsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployPipelineSpecDeployPipelineArtifacts)(ptr) = DeployPipelineSpecDeployPipelineArtifacts{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployPipelineSpecDeployPipelineArtifacts

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifacts{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployPipelineSpecDeployPipelineArtifacts)(ptr) = objs[0]
			} else {
				*(*DeployPipelineSpecDeployPipelineArtifacts)(ptr) = DeployPipelineSpecDeployPipelineArtifacts{}
			}
		} else {
			*(*DeployPipelineSpecDeployPipelineArtifacts)(ptr) = DeployPipelineSpecDeployPipelineArtifacts{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployPipelineSpecDeployPipelineArtifacts

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifacts{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployPipelineSpecDeployPipelineArtifacts)(ptr) = obj
		} else {
			*(*DeployPipelineSpecDeployPipelineArtifacts)(ptr) = DeployPipelineSpecDeployPipelineArtifacts{}
		}
	default:
		iter.ReportError("decode DeployPipelineSpecDeployPipelineArtifacts", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec struct {
}

func (DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) == nil
}

func (DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr)
	var objs []DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages
	if obj != nil {
		objs = []DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = objs[0]
			} else {
				*(*DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}
			}
		} else {
			*(*DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = obj
		} else {
			*(*DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}
		}
	default:
		iter.ReportError("decode DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployPipelineSpecDeployPipelineEnvironmentsCodec struct {
}

func (DeployPipelineSpecDeployPipelineEnvironmentsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployPipelineSpecDeployPipelineEnvironments)(ptr) == nil
}

func (DeployPipelineSpecDeployPipelineEnvironmentsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployPipelineSpecDeployPipelineEnvironments)(ptr)
	var objs []DeployPipelineSpecDeployPipelineEnvironments
	if obj != nil {
		objs = []DeployPipelineSpecDeployPipelineEnvironments{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironments{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployPipelineSpecDeployPipelineEnvironmentsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployPipelineSpecDeployPipelineEnvironments)(ptr) = DeployPipelineSpecDeployPipelineEnvironments{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployPipelineSpecDeployPipelineEnvironments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployPipelineSpecDeployPipelineEnvironments)(ptr) = objs[0]
			} else {
				*(*DeployPipelineSpecDeployPipelineEnvironments)(ptr) = DeployPipelineSpecDeployPipelineEnvironments{}
			}
		} else {
			*(*DeployPipelineSpecDeployPipelineEnvironments)(ptr) = DeployPipelineSpecDeployPipelineEnvironments{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployPipelineSpecDeployPipelineEnvironments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployPipelineSpecDeployPipelineEnvironments)(ptr) = obj
		} else {
			*(*DeployPipelineSpecDeployPipelineEnvironments)(ptr) = DeployPipelineSpecDeployPipelineEnvironments{}
		}
	default:
		iter.ReportError("decode DeployPipelineSpecDeployPipelineEnvironments", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec struct {
}

func (DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) == nil
}

func (DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr)
	var objs []DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages
	if obj != nil {
		objs = []DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = objs[0]
			} else {
				*(*DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}
			}
		} else {
			*(*DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = obj
		} else {
			*(*DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}
		}
	default:
		iter.ReportError("decode DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployPipelineSpecDeployPipelineParametersCodec struct {
}

func (DeployPipelineSpecDeployPipelineParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployPipelineSpecDeployPipelineParameters)(ptr) == nil
}

func (DeployPipelineSpecDeployPipelineParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployPipelineSpecDeployPipelineParameters)(ptr)
	var objs []DeployPipelineSpecDeployPipelineParameters
	if obj != nil {
		objs = []DeployPipelineSpecDeployPipelineParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployPipelineSpecDeployPipelineParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployPipelineSpecDeployPipelineParameters)(ptr) = DeployPipelineSpecDeployPipelineParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployPipelineSpecDeployPipelineParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployPipelineSpecDeployPipelineParameters)(ptr) = objs[0]
			} else {
				*(*DeployPipelineSpecDeployPipelineParameters)(ptr) = DeployPipelineSpecDeployPipelineParameters{}
			}
		} else {
			*(*DeployPipelineSpecDeployPipelineParameters)(ptr) = DeployPipelineSpecDeployPipelineParameters{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployPipelineSpecDeployPipelineParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployPipelineSpecDeployPipelineParameters)(ptr) = obj
		} else {
			*(*DeployPipelineSpecDeployPipelineParameters)(ptr) = DeployPipelineSpecDeployPipelineParameters{}
		}
	default:
		iter.ReportError("decode DeployPipelineSpecDeployPipelineParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecApprovalPolicyCodec struct {
}

func (DeployStageSpecApprovalPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecApprovalPolicy)(ptr) == nil
}

func (DeployStageSpecApprovalPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecApprovalPolicy)(ptr)
	var objs []DeployStageSpecApprovalPolicy
	if obj != nil {
		objs = []DeployStageSpecApprovalPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecApprovalPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecApprovalPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecApprovalPolicy)(ptr) = DeployStageSpecApprovalPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecApprovalPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecApprovalPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecApprovalPolicy)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecApprovalPolicy)(ptr) = DeployStageSpecApprovalPolicy{}
			}
		} else {
			*(*DeployStageSpecApprovalPolicy)(ptr) = DeployStageSpecApprovalPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecApprovalPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecApprovalPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecApprovalPolicy)(ptr) = obj
		} else {
			*(*DeployStageSpecApprovalPolicy)(ptr) = DeployStageSpecApprovalPolicy{}
		}
	default:
		iter.ReportError("decode DeployStageSpecApprovalPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecBlueBackendIPSCodec struct {
}

func (DeployStageSpecBlueBackendIPSCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecBlueBackendIPS)(ptr) == nil
}

func (DeployStageSpecBlueBackendIPSCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecBlueBackendIPS)(ptr)
	var objs []DeployStageSpecBlueBackendIPS
	if obj != nil {
		objs = []DeployStageSpecBlueBackendIPS{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecBlueBackendIPS{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecBlueBackendIPSCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecBlueBackendIPS)(ptr) = DeployStageSpecBlueBackendIPS{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecBlueBackendIPS

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecBlueBackendIPS{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecBlueBackendIPS)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecBlueBackendIPS)(ptr) = DeployStageSpecBlueBackendIPS{}
			}
		} else {
			*(*DeployStageSpecBlueBackendIPS)(ptr) = DeployStageSpecBlueBackendIPS{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecBlueBackendIPS

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecBlueBackendIPS{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecBlueBackendIPS)(ptr) = obj
		} else {
			*(*DeployStageSpecBlueBackendIPS)(ptr) = DeployStageSpecBlueBackendIPS{}
		}
	default:
		iter.ReportError("decode DeployStageSpecBlueBackendIPS", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecDeployStagePredecessorCollectionCodec struct {
}

func (DeployStageSpecDeployStagePredecessorCollectionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecDeployStagePredecessorCollection)(ptr) == nil
}

func (DeployStageSpecDeployStagePredecessorCollectionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecDeployStagePredecessorCollection)(ptr)
	var objs []DeployStageSpecDeployStagePredecessorCollection
	if obj != nil {
		objs = []DeployStageSpecDeployStagePredecessorCollection{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecDeployStagePredecessorCollection{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecDeployStagePredecessorCollectionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecDeployStagePredecessorCollection)(ptr) = DeployStageSpecDeployStagePredecessorCollection{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecDeployStagePredecessorCollection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecDeployStagePredecessorCollection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecDeployStagePredecessorCollection)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecDeployStagePredecessorCollection)(ptr) = DeployStageSpecDeployStagePredecessorCollection{}
			}
		} else {
			*(*DeployStageSpecDeployStagePredecessorCollection)(ptr) = DeployStageSpecDeployStagePredecessorCollection{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecDeployStagePredecessorCollection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecDeployStagePredecessorCollection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecDeployStagePredecessorCollection)(ptr) = obj
		} else {
			*(*DeployStageSpecDeployStagePredecessorCollection)(ptr) = DeployStageSpecDeployStagePredecessorCollection{}
		}
	default:
		iter.ReportError("decode DeployStageSpecDeployStagePredecessorCollection", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecFailurePolicyCodec struct {
}

func (DeployStageSpecFailurePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecFailurePolicy)(ptr) == nil
}

func (DeployStageSpecFailurePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecFailurePolicy)(ptr)
	var objs []DeployStageSpecFailurePolicy
	if obj != nil {
		objs = []DeployStageSpecFailurePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecFailurePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecFailurePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecFailurePolicy)(ptr) = DeployStageSpecFailurePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecFailurePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecFailurePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecFailurePolicy)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecFailurePolicy)(ptr) = DeployStageSpecFailurePolicy{}
			}
		} else {
			*(*DeployStageSpecFailurePolicy)(ptr) = DeployStageSpecFailurePolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecFailurePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecFailurePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecFailurePolicy)(ptr) = obj
		} else {
			*(*DeployStageSpecFailurePolicy)(ptr) = DeployStageSpecFailurePolicy{}
		}
	default:
		iter.ReportError("decode DeployStageSpecFailurePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecGreenBackendIPSCodec struct {
}

func (DeployStageSpecGreenBackendIPSCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecGreenBackendIPS)(ptr) == nil
}

func (DeployStageSpecGreenBackendIPSCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecGreenBackendIPS)(ptr)
	var objs []DeployStageSpecGreenBackendIPS
	if obj != nil {
		objs = []DeployStageSpecGreenBackendIPS{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecGreenBackendIPS{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecGreenBackendIPSCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecGreenBackendIPS)(ptr) = DeployStageSpecGreenBackendIPS{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecGreenBackendIPS

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecGreenBackendIPS{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecGreenBackendIPS)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecGreenBackendIPS)(ptr) = DeployStageSpecGreenBackendIPS{}
			}
		} else {
			*(*DeployStageSpecGreenBackendIPS)(ptr) = DeployStageSpecGreenBackendIPS{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecGreenBackendIPS

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecGreenBackendIPS{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecGreenBackendIPS)(ptr) = obj
		} else {
			*(*DeployStageSpecGreenBackendIPS)(ptr) = DeployStageSpecGreenBackendIPS{}
		}
	default:
		iter.ReportError("decode DeployStageSpecGreenBackendIPS", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecLoadBalancerConfigCodec struct {
}

func (DeployStageSpecLoadBalancerConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecLoadBalancerConfig)(ptr) == nil
}

func (DeployStageSpecLoadBalancerConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecLoadBalancerConfig)(ptr)
	var objs []DeployStageSpecLoadBalancerConfig
	if obj != nil {
		objs = []DeployStageSpecLoadBalancerConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecLoadBalancerConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecLoadBalancerConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecLoadBalancerConfig)(ptr) = DeployStageSpecLoadBalancerConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecLoadBalancerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecLoadBalancerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecLoadBalancerConfig)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecLoadBalancerConfig)(ptr) = DeployStageSpecLoadBalancerConfig{}
			}
		} else {
			*(*DeployStageSpecLoadBalancerConfig)(ptr) = DeployStageSpecLoadBalancerConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecLoadBalancerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecLoadBalancerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecLoadBalancerConfig)(ptr) = obj
		} else {
			*(*DeployStageSpecLoadBalancerConfig)(ptr) = DeployStageSpecLoadBalancerConfig{}
		}
	default:
		iter.ReportError("decode DeployStageSpecLoadBalancerConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecRollbackPolicyCodec struct {
}

func (DeployStageSpecRollbackPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecRollbackPolicy)(ptr) == nil
}

func (DeployStageSpecRollbackPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecRollbackPolicy)(ptr)
	var objs []DeployStageSpecRollbackPolicy
	if obj != nil {
		objs = []DeployStageSpecRollbackPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRollbackPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecRollbackPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecRollbackPolicy)(ptr) = DeployStageSpecRollbackPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecRollbackPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRollbackPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecRollbackPolicy)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecRollbackPolicy)(ptr) = DeployStageSpecRollbackPolicy{}
			}
		} else {
			*(*DeployStageSpecRollbackPolicy)(ptr) = DeployStageSpecRollbackPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecRollbackPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRollbackPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecRollbackPolicy)(ptr) = obj
		} else {
			*(*DeployStageSpecRollbackPolicy)(ptr) = DeployStageSpecRollbackPolicy{}
		}
	default:
		iter.ReportError("decode DeployStageSpecRollbackPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecRolloutPolicyCodec struct {
}

func (DeployStageSpecRolloutPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecRolloutPolicy)(ptr) == nil
}

func (DeployStageSpecRolloutPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecRolloutPolicy)(ptr)
	var objs []DeployStageSpecRolloutPolicy
	if obj != nil {
		objs = []DeployStageSpecRolloutPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRolloutPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecRolloutPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecRolloutPolicy)(ptr) = DeployStageSpecRolloutPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecRolloutPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRolloutPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecRolloutPolicy)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecRolloutPolicy)(ptr) = DeployStageSpecRolloutPolicy{}
			}
		} else {
			*(*DeployStageSpecRolloutPolicy)(ptr) = DeployStageSpecRolloutPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecRolloutPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRolloutPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecRolloutPolicy)(ptr) = obj
		} else {
			*(*DeployStageSpecRolloutPolicy)(ptr) = DeployStageSpecRolloutPolicy{}
		}
	default:
		iter.ReportError("decode DeployStageSpecRolloutPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecWaitCriteriaCodec struct {
}

func (DeployStageSpecWaitCriteriaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecWaitCriteria)(ptr) == nil
}

func (DeployStageSpecWaitCriteriaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecWaitCriteria)(ptr)
	var objs []DeployStageSpecWaitCriteria
	if obj != nil {
		objs = []DeployStageSpecWaitCriteria{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecWaitCriteria{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecWaitCriteriaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecWaitCriteria)(ptr) = DeployStageSpecWaitCriteria{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecWaitCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecWaitCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecWaitCriteria)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecWaitCriteria)(ptr) = DeployStageSpecWaitCriteria{}
			}
		} else {
			*(*DeployStageSpecWaitCriteria)(ptr) = DeployStageSpecWaitCriteria{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecWaitCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecWaitCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecWaitCriteria)(ptr) = obj
		} else {
			*(*DeployStageSpecWaitCriteria)(ptr) = DeployStageSpecWaitCriteria{}
		}
	default:
		iter.ReportError("decode DeployStageSpecWaitCriteria", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecDeployArtifactOverrideArgumentsCodec struct {
}

func (DeploymentSpecDeployArtifactOverrideArgumentsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecDeployArtifactOverrideArguments)(ptr) == nil
}

func (DeploymentSpecDeployArtifactOverrideArgumentsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecDeployArtifactOverrideArguments)(ptr)
	var objs []DeploymentSpecDeployArtifactOverrideArguments
	if obj != nil {
		objs = []DeploymentSpecDeployArtifactOverrideArguments{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployArtifactOverrideArguments{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecDeployArtifactOverrideArgumentsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecDeployArtifactOverrideArguments)(ptr) = DeploymentSpecDeployArtifactOverrideArguments{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecDeployArtifactOverrideArguments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployArtifactOverrideArguments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecDeployArtifactOverrideArguments)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecDeployArtifactOverrideArguments)(ptr) = DeploymentSpecDeployArtifactOverrideArguments{}
			}
		} else {
			*(*DeploymentSpecDeployArtifactOverrideArguments)(ptr) = DeploymentSpecDeployArtifactOverrideArguments{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecDeployArtifactOverrideArguments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployArtifactOverrideArguments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecDeployArtifactOverrideArguments)(ptr) = obj
		} else {
			*(*DeploymentSpecDeployArtifactOverrideArguments)(ptr) = DeploymentSpecDeployArtifactOverrideArguments{}
		}
	default:
		iter.ReportError("decode DeploymentSpecDeployArtifactOverrideArguments", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecDeployPipelineArtifactsCodec struct {
}

func (DeploymentSpecDeployPipelineArtifactsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecDeployPipelineArtifacts)(ptr) == nil
}

func (DeploymentSpecDeployPipelineArtifactsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecDeployPipelineArtifacts)(ptr)
	var objs []DeploymentSpecDeployPipelineArtifacts
	if obj != nil {
		objs = []DeploymentSpecDeployPipelineArtifacts{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifacts{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecDeployPipelineArtifactsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecDeployPipelineArtifacts)(ptr) = DeploymentSpecDeployPipelineArtifacts{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecDeployPipelineArtifacts

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifacts{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecDeployPipelineArtifacts)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecDeployPipelineArtifacts)(ptr) = DeploymentSpecDeployPipelineArtifacts{}
			}
		} else {
			*(*DeploymentSpecDeployPipelineArtifacts)(ptr) = DeploymentSpecDeployPipelineArtifacts{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecDeployPipelineArtifacts

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifacts{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecDeployPipelineArtifacts)(ptr) = obj
		} else {
			*(*DeploymentSpecDeployPipelineArtifacts)(ptr) = DeploymentSpecDeployPipelineArtifacts{}
		}
	default:
		iter.ReportError("decode DeploymentSpecDeployPipelineArtifacts", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec struct {
}

func (DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) == nil
}

func (DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr)
	var objs []DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages
	if obj != nil {
		objs = []DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}
			}
		} else {
			*(*DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = obj
		} else {
			*(*DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}
		}
	default:
		iter.ReportError("decode DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecDeployPipelineEnvironmentsCodec struct {
}

func (DeploymentSpecDeployPipelineEnvironmentsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecDeployPipelineEnvironments)(ptr) == nil
}

func (DeploymentSpecDeployPipelineEnvironmentsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecDeployPipelineEnvironments)(ptr)
	var objs []DeploymentSpecDeployPipelineEnvironments
	if obj != nil {
		objs = []DeploymentSpecDeployPipelineEnvironments{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironments{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecDeployPipelineEnvironmentsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecDeployPipelineEnvironments)(ptr) = DeploymentSpecDeployPipelineEnvironments{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecDeployPipelineEnvironments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecDeployPipelineEnvironments)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecDeployPipelineEnvironments)(ptr) = DeploymentSpecDeployPipelineEnvironments{}
			}
		} else {
			*(*DeploymentSpecDeployPipelineEnvironments)(ptr) = DeploymentSpecDeployPipelineEnvironments{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecDeployPipelineEnvironments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecDeployPipelineEnvironments)(ptr) = obj
		} else {
			*(*DeploymentSpecDeployPipelineEnvironments)(ptr) = DeploymentSpecDeployPipelineEnvironments{}
		}
	default:
		iter.ReportError("decode DeploymentSpecDeployPipelineEnvironments", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec struct {
}

func (DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) == nil
}

func (DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr)
	var objs []DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages
	if obj != nil {
		objs = []DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}
			}
		} else {
			*(*DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = obj
		} else {
			*(*DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}
		}
	default:
		iter.ReportError("decode DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecDeploymentArgumentsCodec struct {
}

func (DeploymentSpecDeploymentArgumentsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecDeploymentArguments)(ptr) == nil
}

func (DeploymentSpecDeploymentArgumentsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecDeploymentArguments)(ptr)
	var objs []DeploymentSpecDeploymentArguments
	if obj != nil {
		objs = []DeploymentSpecDeploymentArguments{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentArguments{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecDeploymentArgumentsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecDeploymentArguments)(ptr) = DeploymentSpecDeploymentArguments{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecDeploymentArguments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentArguments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecDeploymentArguments)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecDeploymentArguments)(ptr) = DeploymentSpecDeploymentArguments{}
			}
		} else {
			*(*DeploymentSpecDeploymentArguments)(ptr) = DeploymentSpecDeploymentArguments{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecDeploymentArguments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentArguments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecDeploymentArguments)(ptr) = obj
		} else {
			*(*DeploymentSpecDeploymentArguments)(ptr) = DeploymentSpecDeploymentArguments{}
		}
	default:
		iter.ReportError("decode DeploymentSpecDeploymentArguments", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecDeploymentExecutionProgressCodec struct {
}

func (DeploymentSpecDeploymentExecutionProgressCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecDeploymentExecutionProgress)(ptr) == nil
}

func (DeploymentSpecDeploymentExecutionProgressCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecDeploymentExecutionProgress)(ptr)
	var objs []DeploymentSpecDeploymentExecutionProgress
	if obj != nil {
		objs = []DeploymentSpecDeploymentExecutionProgress{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentExecutionProgress{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecDeploymentExecutionProgressCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecDeploymentExecutionProgress)(ptr) = DeploymentSpecDeploymentExecutionProgress{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecDeploymentExecutionProgress

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentExecutionProgress{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecDeploymentExecutionProgress)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecDeploymentExecutionProgress)(ptr) = DeploymentSpecDeploymentExecutionProgress{}
			}
		} else {
			*(*DeploymentSpecDeploymentExecutionProgress)(ptr) = DeploymentSpecDeploymentExecutionProgress{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecDeploymentExecutionProgress

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentExecutionProgress{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecDeploymentExecutionProgress)(ptr) = obj
		} else {
			*(*DeploymentSpecDeploymentExecutionProgress)(ptr) = DeploymentSpecDeploymentExecutionProgress{}
		}
	default:
		iter.ReportError("decode DeploymentSpecDeploymentExecutionProgress", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ProjectSpecNotificationConfigCodec struct {
}

func (ProjectSpecNotificationConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ProjectSpecNotificationConfig)(ptr) == nil
}

func (ProjectSpecNotificationConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ProjectSpecNotificationConfig)(ptr)
	var objs []ProjectSpecNotificationConfig
	if obj != nil {
		objs = []ProjectSpecNotificationConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProjectSpecNotificationConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ProjectSpecNotificationConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ProjectSpecNotificationConfig)(ptr) = ProjectSpecNotificationConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ProjectSpecNotificationConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProjectSpecNotificationConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ProjectSpecNotificationConfig)(ptr) = objs[0]
			} else {
				*(*ProjectSpecNotificationConfig)(ptr) = ProjectSpecNotificationConfig{}
			}
		} else {
			*(*ProjectSpecNotificationConfig)(ptr) = ProjectSpecNotificationConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ProjectSpecNotificationConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProjectSpecNotificationConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ProjectSpecNotificationConfig)(ptr) = obj
		} else {
			*(*ProjectSpecNotificationConfig)(ptr) = ProjectSpecNotificationConfig{}
		}
	default:
		iter.ReportError("decode ProjectSpecNotificationConfig", "unexpected JSON type")
	}
}
