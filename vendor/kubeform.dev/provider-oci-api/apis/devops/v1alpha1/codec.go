/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineSpecBuildPipelineParameters{}).Type1()):                              BuildPipelineSpecBuildPipelineParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecBuildPipelineStagePredecessorCollection{}).Type1()):         BuildPipelineStageSpecBuildPipelineStagePredecessorCollectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecBuildSourceCollection{}).Type1()):                           BuildPipelineStageSpecBuildSourceCollectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecDeliverArtifactCollection{}).Type1()):                       BuildPipelineStageSpecDeliverArtifactCollectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecWaitCriteria{}).Type1()):                                    BuildPipelineStageSpecWaitCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputs{}).Type1()):                                              BuildRunSpecBuildOutputsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputsArtifactOverrideParameters{}).Type1()):                    BuildRunSpecBuildOutputsArtifactOverrideParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputsDeliveredArtifacts{}).Type1()):                            BuildRunSpecBuildOutputsDeliveredArtifactsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputsExportedVariables{}).Type1()):                             BuildRunSpecBuildOutputsExportedVariablesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunArguments{}).Type1()):                                         BuildRunSpecBuildRunArgumentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunProgress{}).Type1()):                                          BuildRunSpecBuildRunProgressCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSource{}).Type1()):                                            BuildRunSpecBuildRunSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSourceTriggerInfo{}).Type1()):                                 BuildRunSpecBuildRunSourceTriggerInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSourceTriggerInfoActionsFilter{}).Type1()):                    BuildRunSpecBuildRunSourceTriggerInfoActionsFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude{}).Type1()):             BuildRunSpecBuildRunSourceTriggerInfoActionsFilterIncludeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecCommitInfo{}).Type1()):                                                BuildRunSpecCommitInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployArtifactSpecDeployArtifactSource{}).Type1()):                                DeployArtifactSpecDeployArtifactSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployEnvironmentSpecComputeInstanceGroupSelectors{}).Type1()):                    DeployEnvironmentSpecComputeInstanceGroupSelectorsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifacts{}).Type1()):                             DeployPipelineSpecDeployPipelineArtifactsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1()):    DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironments{}).Type1()):                          DeployPipelineSpecDeployPipelineEnvironmentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1()): DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineParameters{}).Type1()):                            DeployPipelineSpecDeployPipelineParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecApprovalPolicy{}).Type1()):                                         DeployStageSpecApprovalPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecBlueBackendIPS{}).Type1()):                                         DeployStageSpecBlueBackendIPSCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecDeployStagePredecessorCollection{}).Type1()):                       DeployStageSpecDeployStagePredecessorCollectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecFailurePolicy{}).Type1()):                                          DeployStageSpecFailurePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecGreenBackendIPS{}).Type1()):                                        DeployStageSpecGreenBackendIPSCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecLoadBalancerConfig{}).Type1()):                                     DeployStageSpecLoadBalancerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRollbackPolicy{}).Type1()):                                         DeployStageSpecRollbackPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRolloutPolicy{}).Type1()):                                          DeployStageSpecRolloutPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecWaitCriteria{}).Type1()):                                           DeployStageSpecWaitCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployArtifactOverrideArguments{}).Type1()):                         DeploymentSpecDeployArtifactOverrideArgumentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifacts{}).Type1()):                                 DeploymentSpecDeployPipelineArtifactsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1()):        DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironments{}).Type1()):                              DeploymentSpecDeployPipelineEnvironmentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1()):     DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentArguments{}).Type1()):                                     DeploymentSpecDeploymentArgumentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentExecutionProgress{}).Type1()):                             DeploymentSpecDeploymentExecutionProgressCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ProjectSpecNotificationConfig{}).Type1()):                                         ProjectSpecNotificationConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RepositorySpecMirrorRepositoryConfig{}).Type1()):                                  RepositorySpecMirrorRepositoryConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RepositorySpecMirrorRepositoryConfigTriggerSchedule{}).Type1()):                   RepositorySpecMirrorRepositoryConfigTriggerScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecActionsFilter{}).Type1()):                                              TriggerSpecActionsFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecActionsFilterInclude{}).Type1()):                                       TriggerSpecActionsFilterIncludeCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineSpecBuildPipelineParameters{}).Type1()):                              BuildPipelineSpecBuildPipelineParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecBuildPipelineStagePredecessorCollection{}).Type1()):         BuildPipelineStageSpecBuildPipelineStagePredecessorCollectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecBuildSourceCollection{}).Type1()):                           BuildPipelineStageSpecBuildSourceCollectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecDeliverArtifactCollection{}).Type1()):                       BuildPipelineStageSpecDeliverArtifactCollectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecWaitCriteria{}).Type1()):                                    BuildPipelineStageSpecWaitCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputs{}).Type1()):                                              BuildRunSpecBuildOutputsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputsArtifactOverrideParameters{}).Type1()):                    BuildRunSpecBuildOutputsArtifactOverrideParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputsDeliveredArtifacts{}).Type1()):                            BuildRunSpecBuildOutputsDeliveredArtifactsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputsExportedVariables{}).Type1()):                             BuildRunSpecBuildOutputsExportedVariablesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunArguments{}).Type1()):                                         BuildRunSpecBuildRunArgumentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunProgress{}).Type1()):                                          BuildRunSpecBuildRunProgressCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSource{}).Type1()):                                            BuildRunSpecBuildRunSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSourceTriggerInfo{}).Type1()):                                 BuildRunSpecBuildRunSourceTriggerInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSourceTriggerInfoActionsFilter{}).Type1()):                    BuildRunSpecBuildRunSourceTriggerInfoActionsFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude{}).Type1()):             BuildRunSpecBuildRunSourceTriggerInfoActionsFilterIncludeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecCommitInfo{}).Type1()):                                                BuildRunSpecCommitInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployArtifactSpecDeployArtifactSource{}).Type1()):                                DeployArtifactSpecDeployArtifactSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployEnvironmentSpecComputeInstanceGroupSelectors{}).Type1()):                    DeployEnvironmentSpecComputeInstanceGroupSelectorsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifacts{}).Type1()):                             DeployPipelineSpecDeployPipelineArtifactsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1()):    DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironments{}).Type1()):                          DeployPipelineSpecDeployPipelineEnvironmentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1()): DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineParameters{}).Type1()):                            DeployPipelineSpecDeployPipelineParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecApprovalPolicy{}).Type1()):                                         DeployStageSpecApprovalPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecBlueBackendIPS{}).Type1()):                                         DeployStageSpecBlueBackendIPSCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecDeployStagePredecessorCollection{}).Type1()):                       DeployStageSpecDeployStagePredecessorCollectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecFailurePolicy{}).Type1()):                                          DeployStageSpecFailurePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecGreenBackendIPS{}).Type1()):                                        DeployStageSpecGreenBackendIPSCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecLoadBalancerConfig{}).Type1()):                                     DeployStageSpecLoadBalancerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRollbackPolicy{}).Type1()):                                         DeployStageSpecRollbackPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRolloutPolicy{}).Type1()):                                          DeployStageSpecRolloutPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecWaitCriteria{}).Type1()):                                           DeployStageSpecWaitCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployArtifactOverrideArguments{}).Type1()):                         DeploymentSpecDeployArtifactOverrideArgumentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifacts{}).Type1()):                                 DeploymentSpecDeployPipelineArtifactsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1()):        DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironments{}).Type1()):                              DeploymentSpecDeployPipelineEnvironmentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1()):     DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentArguments{}).Type1()):                                     DeploymentSpecDeploymentArgumentsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentExecutionProgress{}).Type1()):                             DeploymentSpecDeploymentExecutionProgressCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ProjectSpecNotificationConfig{}).Type1()):                                         ProjectSpecNotificationConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RepositorySpecMirrorRepositoryConfig{}).Type1()):                                  RepositorySpecMirrorRepositoryConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RepositorySpecMirrorRepositoryConfigTriggerSchedule{}).Type1()):                   RepositorySpecMirrorRepositoryConfigTriggerScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecActionsFilter{}).Type1()):                                              TriggerSpecActionsFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecActionsFilterInclude{}).Type1()):                                       TriggerSpecActionsFilterIncludeCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type BuildPipelineSpecBuildPipelineParametersCodec struct {
}

func (BuildPipelineSpecBuildPipelineParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BuildPipelineSpecBuildPipelineParameters)(ptr) == nil
}

func (BuildPipelineSpecBuildPipelineParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BuildPipelineSpecBuildPipelineParameters)(ptr)
	var objs []BuildPipelineSpecBuildPipelineParameters
	if obj != nil {
		objs = []BuildPipelineSpecBuildPipelineParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineSpecBuildPipelineParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BuildPipelineSpecBuildPipelineParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BuildPipelineSpecBuildPipelineParameters)(ptr) = BuildPipelineSpecBuildPipelineParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BuildPipelineSpecBuildPipelineParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineSpecBuildPipelineParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BuildPipelineSpecBuildPipelineParameters)(ptr) = objs[0]
			} else {
				*(*BuildPipelineSpecBuildPipelineParameters)(ptr) = BuildPipelineSpecBuildPipelineParameters{}
			}
		} else {
			*(*BuildPipelineSpecBuildPipelineParameters)(ptr) = BuildPipelineSpecBuildPipelineParameters{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BuildPipelineSpecBuildPipelineParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineSpecBuildPipelineParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BuildPipelineSpecBuildPipelineParameters)(ptr) = obj
		} else {
			*(*BuildPipelineSpecBuildPipelineParameters)(ptr) = BuildPipelineSpecBuildPipelineParameters{}
		}
	default:
		iter.ReportError("decode BuildPipelineSpecBuildPipelineParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BuildPipelineStageSpecBuildPipelineStagePredecessorCollectionCodec struct {
}

func (BuildPipelineStageSpecBuildPipelineStagePredecessorCollectionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BuildPipelineStageSpecBuildPipelineStagePredecessorCollection)(ptr) == nil
}

func (BuildPipelineStageSpecBuildPipelineStagePredecessorCollectionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BuildPipelineStageSpecBuildPipelineStagePredecessorCollection)(ptr)
	var objs []BuildPipelineStageSpecBuildPipelineStagePredecessorCollection
	if obj != nil {
		objs = []BuildPipelineStageSpecBuildPipelineStagePredecessorCollection{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecBuildPipelineStagePredecessorCollection{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BuildPipelineStageSpecBuildPipelineStagePredecessorCollectionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BuildPipelineStageSpecBuildPipelineStagePredecessorCollection)(ptr) = BuildPipelineStageSpecBuildPipelineStagePredecessorCollection{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BuildPipelineStageSpecBuildPipelineStagePredecessorCollection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecBuildPipelineStagePredecessorCollection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BuildPipelineStageSpecBuildPipelineStagePredecessorCollection)(ptr) = objs[0]
			} else {
				*(*BuildPipelineStageSpecBuildPipelineStagePredecessorCollection)(ptr) = BuildPipelineStageSpecBuildPipelineStagePredecessorCollection{}
			}
		} else {
			*(*BuildPipelineStageSpecBuildPipelineStagePredecessorCollection)(ptr) = BuildPipelineStageSpecBuildPipelineStagePredecessorCollection{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BuildPipelineStageSpecBuildPipelineStagePredecessorCollection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecBuildPipelineStagePredecessorCollection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BuildPipelineStageSpecBuildPipelineStagePredecessorCollection)(ptr) = obj
		} else {
			*(*BuildPipelineStageSpecBuildPipelineStagePredecessorCollection)(ptr) = BuildPipelineStageSpecBuildPipelineStagePredecessorCollection{}
		}
	default:
		iter.ReportError("decode BuildPipelineStageSpecBuildPipelineStagePredecessorCollection", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BuildPipelineStageSpecBuildSourceCollectionCodec struct {
}

func (BuildPipelineStageSpecBuildSourceCollectionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BuildPipelineStageSpecBuildSourceCollection)(ptr) == nil
}

func (BuildPipelineStageSpecBuildSourceCollectionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BuildPipelineStageSpecBuildSourceCollection)(ptr)
	var objs []BuildPipelineStageSpecBuildSourceCollection
	if obj != nil {
		objs = []BuildPipelineStageSpecBuildSourceCollection{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecBuildSourceCollection{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BuildPipelineStageSpecBuildSourceCollectionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BuildPipelineStageSpecBuildSourceCollection)(ptr) = BuildPipelineStageSpecBuildSourceCollection{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BuildPipelineStageSpecBuildSourceCollection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecBuildSourceCollection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BuildPipelineStageSpecBuildSourceCollection)(ptr) = objs[0]
			} else {
				*(*BuildPipelineStageSpecBuildSourceCollection)(ptr) = BuildPipelineStageSpecBuildSourceCollection{}
			}
		} else {
			*(*BuildPipelineStageSpecBuildSourceCollection)(ptr) = BuildPipelineStageSpecBuildSourceCollection{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BuildPipelineStageSpecBuildSourceCollection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecBuildSourceCollection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BuildPipelineStageSpecBuildSourceCollection)(ptr) = obj
		} else {
			*(*BuildPipelineStageSpecBuildSourceCollection)(ptr) = BuildPipelineStageSpecBuildSourceCollection{}
		}
	default:
		iter.ReportError("decode BuildPipelineStageSpecBuildSourceCollection", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BuildPipelineStageSpecDeliverArtifactCollectionCodec struct {
}

func (BuildPipelineStageSpecDeliverArtifactCollectionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BuildPipelineStageSpecDeliverArtifactCollection)(ptr) == nil
}

func (BuildPipelineStageSpecDeliverArtifactCollectionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BuildPipelineStageSpecDeliverArtifactCollection)(ptr)
	var objs []BuildPipelineStageSpecDeliverArtifactCollection
	if obj != nil {
		objs = []BuildPipelineStageSpecDeliverArtifactCollection{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecDeliverArtifactCollection{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BuildPipelineStageSpecDeliverArtifactCollectionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BuildPipelineStageSpecDeliverArtifactCollection)(ptr) = BuildPipelineStageSpecDeliverArtifactCollection{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BuildPipelineStageSpecDeliverArtifactCollection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecDeliverArtifactCollection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BuildPipelineStageSpecDeliverArtifactCollection)(ptr) = objs[0]
			} else {
				*(*BuildPipelineStageSpecDeliverArtifactCollection)(ptr) = BuildPipelineStageSpecDeliverArtifactCollection{}
			}
		} else {
			*(*BuildPipelineStageSpecDeliverArtifactCollection)(ptr) = BuildPipelineStageSpecDeliverArtifactCollection{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BuildPipelineStageSpecDeliverArtifactCollection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecDeliverArtifactCollection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BuildPipelineStageSpecDeliverArtifactCollection)(ptr) = obj
		} else {
			*(*BuildPipelineStageSpecDeliverArtifactCollection)(ptr) = BuildPipelineStageSpecDeliverArtifactCollection{}
		}
	default:
		iter.ReportError("decode BuildPipelineStageSpecDeliverArtifactCollection", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BuildPipelineStageSpecWaitCriteriaCodec struct {
}

func (BuildPipelineStageSpecWaitCriteriaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BuildPipelineStageSpecWaitCriteria)(ptr) == nil
}

func (BuildPipelineStageSpecWaitCriteriaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BuildPipelineStageSpecWaitCriteria)(ptr)
	var objs []BuildPipelineStageSpecWaitCriteria
	if obj != nil {
		objs = []BuildPipelineStageSpecWaitCriteria{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecWaitCriteria{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BuildPipelineStageSpecWaitCriteriaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BuildPipelineStageSpecWaitCriteria)(ptr) = BuildPipelineStageSpecWaitCriteria{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BuildPipelineStageSpecWaitCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecWaitCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BuildPipelineStageSpecWaitCriteria)(ptr) = objs[0]
			} else {
				*(*BuildPipelineStageSpecWaitCriteria)(ptr) = BuildPipelineStageSpecWaitCriteria{}
			}
		} else {
			*(*BuildPipelineStageSpecWaitCriteria)(ptr) = BuildPipelineStageSpecWaitCriteria{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BuildPipelineStageSpecWaitCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildPipelineStageSpecWaitCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BuildPipelineStageSpecWaitCriteria)(ptr) = obj
		} else {
			*(*BuildPipelineStageSpecWaitCriteria)(ptr) = BuildPipelineStageSpecWaitCriteria{}
		}
	default:
		iter.ReportError("decode BuildPipelineStageSpecWaitCriteria", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BuildRunSpecBuildOutputsCodec struct {
}

func (BuildRunSpecBuildOutputsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BuildRunSpecBuildOutputs)(ptr) == nil
}

func (BuildRunSpecBuildOutputsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BuildRunSpecBuildOutputs)(ptr)
	var objs []BuildRunSpecBuildOutputs
	if obj != nil {
		objs = []BuildRunSpecBuildOutputs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BuildRunSpecBuildOutputsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BuildRunSpecBuildOutputs)(ptr) = BuildRunSpecBuildOutputs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BuildRunSpecBuildOutputs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BuildRunSpecBuildOutputs)(ptr) = objs[0]
			} else {
				*(*BuildRunSpecBuildOutputs)(ptr) = BuildRunSpecBuildOutputs{}
			}
		} else {
			*(*BuildRunSpecBuildOutputs)(ptr) = BuildRunSpecBuildOutputs{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BuildRunSpecBuildOutputs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BuildRunSpecBuildOutputs)(ptr) = obj
		} else {
			*(*BuildRunSpecBuildOutputs)(ptr) = BuildRunSpecBuildOutputs{}
		}
	default:
		iter.ReportError("decode BuildRunSpecBuildOutputs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BuildRunSpecBuildOutputsArtifactOverrideParametersCodec struct {
}

func (BuildRunSpecBuildOutputsArtifactOverrideParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BuildRunSpecBuildOutputsArtifactOverrideParameters)(ptr) == nil
}

func (BuildRunSpecBuildOutputsArtifactOverrideParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BuildRunSpecBuildOutputsArtifactOverrideParameters)(ptr)
	var objs []BuildRunSpecBuildOutputsArtifactOverrideParameters
	if obj != nil {
		objs = []BuildRunSpecBuildOutputsArtifactOverrideParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputsArtifactOverrideParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BuildRunSpecBuildOutputsArtifactOverrideParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BuildRunSpecBuildOutputsArtifactOverrideParameters)(ptr) = BuildRunSpecBuildOutputsArtifactOverrideParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BuildRunSpecBuildOutputsArtifactOverrideParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputsArtifactOverrideParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BuildRunSpecBuildOutputsArtifactOverrideParameters)(ptr) = objs[0]
			} else {
				*(*BuildRunSpecBuildOutputsArtifactOverrideParameters)(ptr) = BuildRunSpecBuildOutputsArtifactOverrideParameters{}
			}
		} else {
			*(*BuildRunSpecBuildOutputsArtifactOverrideParameters)(ptr) = BuildRunSpecBuildOutputsArtifactOverrideParameters{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BuildRunSpecBuildOutputsArtifactOverrideParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputsArtifactOverrideParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BuildRunSpecBuildOutputsArtifactOverrideParameters)(ptr) = obj
		} else {
			*(*BuildRunSpecBuildOutputsArtifactOverrideParameters)(ptr) = BuildRunSpecBuildOutputsArtifactOverrideParameters{}
		}
	default:
		iter.ReportError("decode BuildRunSpecBuildOutputsArtifactOverrideParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BuildRunSpecBuildOutputsDeliveredArtifactsCodec struct {
}

func (BuildRunSpecBuildOutputsDeliveredArtifactsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BuildRunSpecBuildOutputsDeliveredArtifacts)(ptr) == nil
}

func (BuildRunSpecBuildOutputsDeliveredArtifactsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BuildRunSpecBuildOutputsDeliveredArtifacts)(ptr)
	var objs []BuildRunSpecBuildOutputsDeliveredArtifacts
	if obj != nil {
		objs = []BuildRunSpecBuildOutputsDeliveredArtifacts{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputsDeliveredArtifacts{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BuildRunSpecBuildOutputsDeliveredArtifactsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BuildRunSpecBuildOutputsDeliveredArtifacts)(ptr) = BuildRunSpecBuildOutputsDeliveredArtifacts{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BuildRunSpecBuildOutputsDeliveredArtifacts

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputsDeliveredArtifacts{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BuildRunSpecBuildOutputsDeliveredArtifacts)(ptr) = objs[0]
			} else {
				*(*BuildRunSpecBuildOutputsDeliveredArtifacts)(ptr) = BuildRunSpecBuildOutputsDeliveredArtifacts{}
			}
		} else {
			*(*BuildRunSpecBuildOutputsDeliveredArtifacts)(ptr) = BuildRunSpecBuildOutputsDeliveredArtifacts{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BuildRunSpecBuildOutputsDeliveredArtifacts

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputsDeliveredArtifacts{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BuildRunSpecBuildOutputsDeliveredArtifacts)(ptr) = obj
		} else {
			*(*BuildRunSpecBuildOutputsDeliveredArtifacts)(ptr) = BuildRunSpecBuildOutputsDeliveredArtifacts{}
		}
	default:
		iter.ReportError("decode BuildRunSpecBuildOutputsDeliveredArtifacts", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BuildRunSpecBuildOutputsExportedVariablesCodec struct {
}

func (BuildRunSpecBuildOutputsExportedVariablesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BuildRunSpecBuildOutputsExportedVariables)(ptr) == nil
}

func (BuildRunSpecBuildOutputsExportedVariablesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BuildRunSpecBuildOutputsExportedVariables)(ptr)
	var objs []BuildRunSpecBuildOutputsExportedVariables
	if obj != nil {
		objs = []BuildRunSpecBuildOutputsExportedVariables{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputsExportedVariables{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BuildRunSpecBuildOutputsExportedVariablesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BuildRunSpecBuildOutputsExportedVariables)(ptr) = BuildRunSpecBuildOutputsExportedVariables{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BuildRunSpecBuildOutputsExportedVariables

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputsExportedVariables{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BuildRunSpecBuildOutputsExportedVariables)(ptr) = objs[0]
			} else {
				*(*BuildRunSpecBuildOutputsExportedVariables)(ptr) = BuildRunSpecBuildOutputsExportedVariables{}
			}
		} else {
			*(*BuildRunSpecBuildOutputsExportedVariables)(ptr) = BuildRunSpecBuildOutputsExportedVariables{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BuildRunSpecBuildOutputsExportedVariables

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildOutputsExportedVariables{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BuildRunSpecBuildOutputsExportedVariables)(ptr) = obj
		} else {
			*(*BuildRunSpecBuildOutputsExportedVariables)(ptr) = BuildRunSpecBuildOutputsExportedVariables{}
		}
	default:
		iter.ReportError("decode BuildRunSpecBuildOutputsExportedVariables", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BuildRunSpecBuildRunArgumentsCodec struct {
}

func (BuildRunSpecBuildRunArgumentsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BuildRunSpecBuildRunArguments)(ptr) == nil
}

func (BuildRunSpecBuildRunArgumentsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BuildRunSpecBuildRunArguments)(ptr)
	var objs []BuildRunSpecBuildRunArguments
	if obj != nil {
		objs = []BuildRunSpecBuildRunArguments{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunArguments{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BuildRunSpecBuildRunArgumentsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BuildRunSpecBuildRunArguments)(ptr) = BuildRunSpecBuildRunArguments{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BuildRunSpecBuildRunArguments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunArguments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BuildRunSpecBuildRunArguments)(ptr) = objs[0]
			} else {
				*(*BuildRunSpecBuildRunArguments)(ptr) = BuildRunSpecBuildRunArguments{}
			}
		} else {
			*(*BuildRunSpecBuildRunArguments)(ptr) = BuildRunSpecBuildRunArguments{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BuildRunSpecBuildRunArguments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunArguments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BuildRunSpecBuildRunArguments)(ptr) = obj
		} else {
			*(*BuildRunSpecBuildRunArguments)(ptr) = BuildRunSpecBuildRunArguments{}
		}
	default:
		iter.ReportError("decode BuildRunSpecBuildRunArguments", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BuildRunSpecBuildRunProgressCodec struct {
}

func (BuildRunSpecBuildRunProgressCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BuildRunSpecBuildRunProgress)(ptr) == nil
}

func (BuildRunSpecBuildRunProgressCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BuildRunSpecBuildRunProgress)(ptr)
	var objs []BuildRunSpecBuildRunProgress
	if obj != nil {
		objs = []BuildRunSpecBuildRunProgress{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunProgress{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BuildRunSpecBuildRunProgressCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BuildRunSpecBuildRunProgress)(ptr) = BuildRunSpecBuildRunProgress{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BuildRunSpecBuildRunProgress

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunProgress{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BuildRunSpecBuildRunProgress)(ptr) = objs[0]
			} else {
				*(*BuildRunSpecBuildRunProgress)(ptr) = BuildRunSpecBuildRunProgress{}
			}
		} else {
			*(*BuildRunSpecBuildRunProgress)(ptr) = BuildRunSpecBuildRunProgress{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BuildRunSpecBuildRunProgress

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunProgress{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BuildRunSpecBuildRunProgress)(ptr) = obj
		} else {
			*(*BuildRunSpecBuildRunProgress)(ptr) = BuildRunSpecBuildRunProgress{}
		}
	default:
		iter.ReportError("decode BuildRunSpecBuildRunProgress", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BuildRunSpecBuildRunSourceCodec struct {
}

func (BuildRunSpecBuildRunSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BuildRunSpecBuildRunSource)(ptr) == nil
}

func (BuildRunSpecBuildRunSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BuildRunSpecBuildRunSource)(ptr)
	var objs []BuildRunSpecBuildRunSource
	if obj != nil {
		objs = []BuildRunSpecBuildRunSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BuildRunSpecBuildRunSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BuildRunSpecBuildRunSource)(ptr) = BuildRunSpecBuildRunSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BuildRunSpecBuildRunSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BuildRunSpecBuildRunSource)(ptr) = objs[0]
			} else {
				*(*BuildRunSpecBuildRunSource)(ptr) = BuildRunSpecBuildRunSource{}
			}
		} else {
			*(*BuildRunSpecBuildRunSource)(ptr) = BuildRunSpecBuildRunSource{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BuildRunSpecBuildRunSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BuildRunSpecBuildRunSource)(ptr) = obj
		} else {
			*(*BuildRunSpecBuildRunSource)(ptr) = BuildRunSpecBuildRunSource{}
		}
	default:
		iter.ReportError("decode BuildRunSpecBuildRunSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BuildRunSpecBuildRunSourceTriggerInfoCodec struct {
}

func (BuildRunSpecBuildRunSourceTriggerInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BuildRunSpecBuildRunSourceTriggerInfo)(ptr) == nil
}

func (BuildRunSpecBuildRunSourceTriggerInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BuildRunSpecBuildRunSourceTriggerInfo)(ptr)
	var objs []BuildRunSpecBuildRunSourceTriggerInfo
	if obj != nil {
		objs = []BuildRunSpecBuildRunSourceTriggerInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSourceTriggerInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BuildRunSpecBuildRunSourceTriggerInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BuildRunSpecBuildRunSourceTriggerInfo)(ptr) = BuildRunSpecBuildRunSourceTriggerInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BuildRunSpecBuildRunSourceTriggerInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSourceTriggerInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BuildRunSpecBuildRunSourceTriggerInfo)(ptr) = objs[0]
			} else {
				*(*BuildRunSpecBuildRunSourceTriggerInfo)(ptr) = BuildRunSpecBuildRunSourceTriggerInfo{}
			}
		} else {
			*(*BuildRunSpecBuildRunSourceTriggerInfo)(ptr) = BuildRunSpecBuildRunSourceTriggerInfo{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BuildRunSpecBuildRunSourceTriggerInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSourceTriggerInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BuildRunSpecBuildRunSourceTriggerInfo)(ptr) = obj
		} else {
			*(*BuildRunSpecBuildRunSourceTriggerInfo)(ptr) = BuildRunSpecBuildRunSourceTriggerInfo{}
		}
	default:
		iter.ReportError("decode BuildRunSpecBuildRunSourceTriggerInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BuildRunSpecBuildRunSourceTriggerInfoActionsFilterCodec struct {
}

func (BuildRunSpecBuildRunSourceTriggerInfoActionsFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BuildRunSpecBuildRunSourceTriggerInfoActionsFilter)(ptr) == nil
}

func (BuildRunSpecBuildRunSourceTriggerInfoActionsFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BuildRunSpecBuildRunSourceTriggerInfoActionsFilter)(ptr)
	var objs []BuildRunSpecBuildRunSourceTriggerInfoActionsFilter
	if obj != nil {
		objs = []BuildRunSpecBuildRunSourceTriggerInfoActionsFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSourceTriggerInfoActionsFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BuildRunSpecBuildRunSourceTriggerInfoActionsFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BuildRunSpecBuildRunSourceTriggerInfoActionsFilter)(ptr) = BuildRunSpecBuildRunSourceTriggerInfoActionsFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BuildRunSpecBuildRunSourceTriggerInfoActionsFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSourceTriggerInfoActionsFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BuildRunSpecBuildRunSourceTriggerInfoActionsFilter)(ptr) = objs[0]
			} else {
				*(*BuildRunSpecBuildRunSourceTriggerInfoActionsFilter)(ptr) = BuildRunSpecBuildRunSourceTriggerInfoActionsFilter{}
			}
		} else {
			*(*BuildRunSpecBuildRunSourceTriggerInfoActionsFilter)(ptr) = BuildRunSpecBuildRunSourceTriggerInfoActionsFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BuildRunSpecBuildRunSourceTriggerInfoActionsFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSourceTriggerInfoActionsFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BuildRunSpecBuildRunSourceTriggerInfoActionsFilter)(ptr) = obj
		} else {
			*(*BuildRunSpecBuildRunSourceTriggerInfoActionsFilter)(ptr) = BuildRunSpecBuildRunSourceTriggerInfoActionsFilter{}
		}
	default:
		iter.ReportError("decode BuildRunSpecBuildRunSourceTriggerInfoActionsFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BuildRunSpecBuildRunSourceTriggerInfoActionsFilterIncludeCodec struct {
}

func (BuildRunSpecBuildRunSourceTriggerInfoActionsFilterIncludeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude)(ptr) == nil
}

func (BuildRunSpecBuildRunSourceTriggerInfoActionsFilterIncludeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude)(ptr)
	var objs []BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude
	if obj != nil {
		objs = []BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BuildRunSpecBuildRunSourceTriggerInfoActionsFilterIncludeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude)(ptr) = BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude)(ptr) = objs[0]
			} else {
				*(*BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude)(ptr) = BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude{}
			}
		} else {
			*(*BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude)(ptr) = BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude)(ptr) = obj
		} else {
			*(*BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude)(ptr) = BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude{}
		}
	default:
		iter.ReportError("decode BuildRunSpecBuildRunSourceTriggerInfoActionsFilterInclude", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BuildRunSpecCommitInfoCodec struct {
}

func (BuildRunSpecCommitInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BuildRunSpecCommitInfo)(ptr) == nil
}

func (BuildRunSpecCommitInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BuildRunSpecCommitInfo)(ptr)
	var objs []BuildRunSpecCommitInfo
	if obj != nil {
		objs = []BuildRunSpecCommitInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecCommitInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BuildRunSpecCommitInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BuildRunSpecCommitInfo)(ptr) = BuildRunSpecCommitInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BuildRunSpecCommitInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecCommitInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BuildRunSpecCommitInfo)(ptr) = objs[0]
			} else {
				*(*BuildRunSpecCommitInfo)(ptr) = BuildRunSpecCommitInfo{}
			}
		} else {
			*(*BuildRunSpecCommitInfo)(ptr) = BuildRunSpecCommitInfo{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BuildRunSpecCommitInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BuildRunSpecCommitInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BuildRunSpecCommitInfo)(ptr) = obj
		} else {
			*(*BuildRunSpecCommitInfo)(ptr) = BuildRunSpecCommitInfo{}
		}
	default:
		iter.ReportError("decode BuildRunSpecCommitInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployArtifactSpecDeployArtifactSourceCodec struct {
}

func (DeployArtifactSpecDeployArtifactSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployArtifactSpecDeployArtifactSource)(ptr) == nil
}

func (DeployArtifactSpecDeployArtifactSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployArtifactSpecDeployArtifactSource)(ptr)
	var objs []DeployArtifactSpecDeployArtifactSource
	if obj != nil {
		objs = []DeployArtifactSpecDeployArtifactSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployArtifactSpecDeployArtifactSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployArtifactSpecDeployArtifactSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployArtifactSpecDeployArtifactSource)(ptr) = DeployArtifactSpecDeployArtifactSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployArtifactSpecDeployArtifactSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployArtifactSpecDeployArtifactSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployArtifactSpecDeployArtifactSource)(ptr) = objs[0]
			} else {
				*(*DeployArtifactSpecDeployArtifactSource)(ptr) = DeployArtifactSpecDeployArtifactSource{}
			}
		} else {
			*(*DeployArtifactSpecDeployArtifactSource)(ptr) = DeployArtifactSpecDeployArtifactSource{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployArtifactSpecDeployArtifactSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployArtifactSpecDeployArtifactSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployArtifactSpecDeployArtifactSource)(ptr) = obj
		} else {
			*(*DeployArtifactSpecDeployArtifactSource)(ptr) = DeployArtifactSpecDeployArtifactSource{}
		}
	default:
		iter.ReportError("decode DeployArtifactSpecDeployArtifactSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployEnvironmentSpecComputeInstanceGroupSelectorsCodec struct {
}

func (DeployEnvironmentSpecComputeInstanceGroupSelectorsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployEnvironmentSpecComputeInstanceGroupSelectors)(ptr) == nil
}

func (DeployEnvironmentSpecComputeInstanceGroupSelectorsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployEnvironmentSpecComputeInstanceGroupSelectors)(ptr)
	var objs []DeployEnvironmentSpecComputeInstanceGroupSelectors
	if obj != nil {
		objs = []DeployEnvironmentSpecComputeInstanceGroupSelectors{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployEnvironmentSpecComputeInstanceGroupSelectors{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployEnvironmentSpecComputeInstanceGroupSelectorsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployEnvironmentSpecComputeInstanceGroupSelectors)(ptr) = DeployEnvironmentSpecComputeInstanceGroupSelectors{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployEnvironmentSpecComputeInstanceGroupSelectors

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployEnvironmentSpecComputeInstanceGroupSelectors{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployEnvironmentSpecComputeInstanceGroupSelectors)(ptr) = objs[0]
			} else {
				*(*DeployEnvironmentSpecComputeInstanceGroupSelectors)(ptr) = DeployEnvironmentSpecComputeInstanceGroupSelectors{}
			}
		} else {
			*(*DeployEnvironmentSpecComputeInstanceGroupSelectors)(ptr) = DeployEnvironmentSpecComputeInstanceGroupSelectors{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployEnvironmentSpecComputeInstanceGroupSelectors

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployEnvironmentSpecComputeInstanceGroupSelectors{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployEnvironmentSpecComputeInstanceGroupSelectors)(ptr) = obj
		} else {
			*(*DeployEnvironmentSpecComputeInstanceGroupSelectors)(ptr) = DeployEnvironmentSpecComputeInstanceGroupSelectors{}
		}
	default:
		iter.ReportError("decode DeployEnvironmentSpecComputeInstanceGroupSelectors", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployPipelineSpecDeployPipelineArtifactsCodec struct {
}

func (DeployPipelineSpecDeployPipelineArtifactsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployPipelineSpecDeployPipelineArtifacts)(ptr) == nil
}

func (DeployPipelineSpecDeployPipelineArtifactsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployPipelineSpecDeployPipelineArtifacts)(ptr)
	var objs []DeployPipelineSpecDeployPipelineArtifacts
	if obj != nil {
		objs = []DeployPipelineSpecDeployPipelineArtifacts{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifacts{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployPipelineSpecDeployPipelineArtifactsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployPipelineSpecDeployPipelineArtifacts)(ptr) = DeployPipelineSpecDeployPipelineArtifacts{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployPipelineSpecDeployPipelineArtifacts

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifacts{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployPipelineSpecDeployPipelineArtifacts)(ptr) = objs[0]
			} else {
				*(*DeployPipelineSpecDeployPipelineArtifacts)(ptr) = DeployPipelineSpecDeployPipelineArtifacts{}
			}
		} else {
			*(*DeployPipelineSpecDeployPipelineArtifacts)(ptr) = DeployPipelineSpecDeployPipelineArtifacts{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployPipelineSpecDeployPipelineArtifacts

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifacts{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployPipelineSpecDeployPipelineArtifacts)(ptr) = obj
		} else {
			*(*DeployPipelineSpecDeployPipelineArtifacts)(ptr) = DeployPipelineSpecDeployPipelineArtifacts{}
		}
	default:
		iter.ReportError("decode DeployPipelineSpecDeployPipelineArtifacts", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec struct {
}

func (DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) == nil
}

func (DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr)
	var objs []DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages
	if obj != nil {
		objs = []DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = objs[0]
			} else {
				*(*DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}
			}
		} else {
			*(*DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = obj
		} else {
			*(*DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages{}
		}
	default:
		iter.ReportError("decode DeployPipelineSpecDeployPipelineArtifactsItemsDeployPipelineStages", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployPipelineSpecDeployPipelineEnvironmentsCodec struct {
}

func (DeployPipelineSpecDeployPipelineEnvironmentsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployPipelineSpecDeployPipelineEnvironments)(ptr) == nil
}

func (DeployPipelineSpecDeployPipelineEnvironmentsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployPipelineSpecDeployPipelineEnvironments)(ptr)
	var objs []DeployPipelineSpecDeployPipelineEnvironments
	if obj != nil {
		objs = []DeployPipelineSpecDeployPipelineEnvironments{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironments{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployPipelineSpecDeployPipelineEnvironmentsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployPipelineSpecDeployPipelineEnvironments)(ptr) = DeployPipelineSpecDeployPipelineEnvironments{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployPipelineSpecDeployPipelineEnvironments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployPipelineSpecDeployPipelineEnvironments)(ptr) = objs[0]
			} else {
				*(*DeployPipelineSpecDeployPipelineEnvironments)(ptr) = DeployPipelineSpecDeployPipelineEnvironments{}
			}
		} else {
			*(*DeployPipelineSpecDeployPipelineEnvironments)(ptr) = DeployPipelineSpecDeployPipelineEnvironments{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployPipelineSpecDeployPipelineEnvironments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployPipelineSpecDeployPipelineEnvironments)(ptr) = obj
		} else {
			*(*DeployPipelineSpecDeployPipelineEnvironments)(ptr) = DeployPipelineSpecDeployPipelineEnvironments{}
		}
	default:
		iter.ReportError("decode DeployPipelineSpecDeployPipelineEnvironments", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec struct {
}

func (DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) == nil
}

func (DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr)
	var objs []DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages
	if obj != nil {
		objs = []DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = objs[0]
			} else {
				*(*DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}
			}
		} else {
			*(*DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = obj
		} else {
			*(*DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}
		}
	default:
		iter.ReportError("decode DeployPipelineSpecDeployPipelineEnvironmentsItemsDeployPipelineStages", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployPipelineSpecDeployPipelineParametersCodec struct {
}

func (DeployPipelineSpecDeployPipelineParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployPipelineSpecDeployPipelineParameters)(ptr) == nil
}

func (DeployPipelineSpecDeployPipelineParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployPipelineSpecDeployPipelineParameters)(ptr)
	var objs []DeployPipelineSpecDeployPipelineParameters
	if obj != nil {
		objs = []DeployPipelineSpecDeployPipelineParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployPipelineSpecDeployPipelineParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployPipelineSpecDeployPipelineParameters)(ptr) = DeployPipelineSpecDeployPipelineParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployPipelineSpecDeployPipelineParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployPipelineSpecDeployPipelineParameters)(ptr) = objs[0]
			} else {
				*(*DeployPipelineSpecDeployPipelineParameters)(ptr) = DeployPipelineSpecDeployPipelineParameters{}
			}
		} else {
			*(*DeployPipelineSpecDeployPipelineParameters)(ptr) = DeployPipelineSpecDeployPipelineParameters{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployPipelineSpecDeployPipelineParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployPipelineSpecDeployPipelineParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployPipelineSpecDeployPipelineParameters)(ptr) = obj
		} else {
			*(*DeployPipelineSpecDeployPipelineParameters)(ptr) = DeployPipelineSpecDeployPipelineParameters{}
		}
	default:
		iter.ReportError("decode DeployPipelineSpecDeployPipelineParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecApprovalPolicyCodec struct {
}

func (DeployStageSpecApprovalPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecApprovalPolicy)(ptr) == nil
}

func (DeployStageSpecApprovalPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecApprovalPolicy)(ptr)
	var objs []DeployStageSpecApprovalPolicy
	if obj != nil {
		objs = []DeployStageSpecApprovalPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecApprovalPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecApprovalPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecApprovalPolicy)(ptr) = DeployStageSpecApprovalPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecApprovalPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecApprovalPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecApprovalPolicy)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecApprovalPolicy)(ptr) = DeployStageSpecApprovalPolicy{}
			}
		} else {
			*(*DeployStageSpecApprovalPolicy)(ptr) = DeployStageSpecApprovalPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecApprovalPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecApprovalPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecApprovalPolicy)(ptr) = obj
		} else {
			*(*DeployStageSpecApprovalPolicy)(ptr) = DeployStageSpecApprovalPolicy{}
		}
	default:
		iter.ReportError("decode DeployStageSpecApprovalPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecBlueBackendIPSCodec struct {
}

func (DeployStageSpecBlueBackendIPSCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecBlueBackendIPS)(ptr) == nil
}

func (DeployStageSpecBlueBackendIPSCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecBlueBackendIPS)(ptr)
	var objs []DeployStageSpecBlueBackendIPS
	if obj != nil {
		objs = []DeployStageSpecBlueBackendIPS{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecBlueBackendIPS{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecBlueBackendIPSCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecBlueBackendIPS)(ptr) = DeployStageSpecBlueBackendIPS{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecBlueBackendIPS

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecBlueBackendIPS{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecBlueBackendIPS)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecBlueBackendIPS)(ptr) = DeployStageSpecBlueBackendIPS{}
			}
		} else {
			*(*DeployStageSpecBlueBackendIPS)(ptr) = DeployStageSpecBlueBackendIPS{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecBlueBackendIPS

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecBlueBackendIPS{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecBlueBackendIPS)(ptr) = obj
		} else {
			*(*DeployStageSpecBlueBackendIPS)(ptr) = DeployStageSpecBlueBackendIPS{}
		}
	default:
		iter.ReportError("decode DeployStageSpecBlueBackendIPS", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecDeployStagePredecessorCollectionCodec struct {
}

func (DeployStageSpecDeployStagePredecessorCollectionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecDeployStagePredecessorCollection)(ptr) == nil
}

func (DeployStageSpecDeployStagePredecessorCollectionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecDeployStagePredecessorCollection)(ptr)
	var objs []DeployStageSpecDeployStagePredecessorCollection
	if obj != nil {
		objs = []DeployStageSpecDeployStagePredecessorCollection{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecDeployStagePredecessorCollection{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecDeployStagePredecessorCollectionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecDeployStagePredecessorCollection)(ptr) = DeployStageSpecDeployStagePredecessorCollection{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecDeployStagePredecessorCollection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecDeployStagePredecessorCollection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecDeployStagePredecessorCollection)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecDeployStagePredecessorCollection)(ptr) = DeployStageSpecDeployStagePredecessorCollection{}
			}
		} else {
			*(*DeployStageSpecDeployStagePredecessorCollection)(ptr) = DeployStageSpecDeployStagePredecessorCollection{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecDeployStagePredecessorCollection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecDeployStagePredecessorCollection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecDeployStagePredecessorCollection)(ptr) = obj
		} else {
			*(*DeployStageSpecDeployStagePredecessorCollection)(ptr) = DeployStageSpecDeployStagePredecessorCollection{}
		}
	default:
		iter.ReportError("decode DeployStageSpecDeployStagePredecessorCollection", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecFailurePolicyCodec struct {
}

func (DeployStageSpecFailurePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecFailurePolicy)(ptr) == nil
}

func (DeployStageSpecFailurePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecFailurePolicy)(ptr)
	var objs []DeployStageSpecFailurePolicy
	if obj != nil {
		objs = []DeployStageSpecFailurePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecFailurePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecFailurePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecFailurePolicy)(ptr) = DeployStageSpecFailurePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecFailurePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecFailurePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecFailurePolicy)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecFailurePolicy)(ptr) = DeployStageSpecFailurePolicy{}
			}
		} else {
			*(*DeployStageSpecFailurePolicy)(ptr) = DeployStageSpecFailurePolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecFailurePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecFailurePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecFailurePolicy)(ptr) = obj
		} else {
			*(*DeployStageSpecFailurePolicy)(ptr) = DeployStageSpecFailurePolicy{}
		}
	default:
		iter.ReportError("decode DeployStageSpecFailurePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecGreenBackendIPSCodec struct {
}

func (DeployStageSpecGreenBackendIPSCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecGreenBackendIPS)(ptr) == nil
}

func (DeployStageSpecGreenBackendIPSCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecGreenBackendIPS)(ptr)
	var objs []DeployStageSpecGreenBackendIPS
	if obj != nil {
		objs = []DeployStageSpecGreenBackendIPS{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecGreenBackendIPS{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecGreenBackendIPSCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecGreenBackendIPS)(ptr) = DeployStageSpecGreenBackendIPS{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecGreenBackendIPS

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecGreenBackendIPS{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecGreenBackendIPS)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecGreenBackendIPS)(ptr) = DeployStageSpecGreenBackendIPS{}
			}
		} else {
			*(*DeployStageSpecGreenBackendIPS)(ptr) = DeployStageSpecGreenBackendIPS{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecGreenBackendIPS

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecGreenBackendIPS{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecGreenBackendIPS)(ptr) = obj
		} else {
			*(*DeployStageSpecGreenBackendIPS)(ptr) = DeployStageSpecGreenBackendIPS{}
		}
	default:
		iter.ReportError("decode DeployStageSpecGreenBackendIPS", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecLoadBalancerConfigCodec struct {
}

func (DeployStageSpecLoadBalancerConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecLoadBalancerConfig)(ptr) == nil
}

func (DeployStageSpecLoadBalancerConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecLoadBalancerConfig)(ptr)
	var objs []DeployStageSpecLoadBalancerConfig
	if obj != nil {
		objs = []DeployStageSpecLoadBalancerConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecLoadBalancerConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecLoadBalancerConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecLoadBalancerConfig)(ptr) = DeployStageSpecLoadBalancerConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecLoadBalancerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecLoadBalancerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecLoadBalancerConfig)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecLoadBalancerConfig)(ptr) = DeployStageSpecLoadBalancerConfig{}
			}
		} else {
			*(*DeployStageSpecLoadBalancerConfig)(ptr) = DeployStageSpecLoadBalancerConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecLoadBalancerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecLoadBalancerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecLoadBalancerConfig)(ptr) = obj
		} else {
			*(*DeployStageSpecLoadBalancerConfig)(ptr) = DeployStageSpecLoadBalancerConfig{}
		}
	default:
		iter.ReportError("decode DeployStageSpecLoadBalancerConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecRollbackPolicyCodec struct {
}

func (DeployStageSpecRollbackPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecRollbackPolicy)(ptr) == nil
}

func (DeployStageSpecRollbackPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecRollbackPolicy)(ptr)
	var objs []DeployStageSpecRollbackPolicy
	if obj != nil {
		objs = []DeployStageSpecRollbackPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRollbackPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecRollbackPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecRollbackPolicy)(ptr) = DeployStageSpecRollbackPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecRollbackPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRollbackPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecRollbackPolicy)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecRollbackPolicy)(ptr) = DeployStageSpecRollbackPolicy{}
			}
		} else {
			*(*DeployStageSpecRollbackPolicy)(ptr) = DeployStageSpecRollbackPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecRollbackPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRollbackPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecRollbackPolicy)(ptr) = obj
		} else {
			*(*DeployStageSpecRollbackPolicy)(ptr) = DeployStageSpecRollbackPolicy{}
		}
	default:
		iter.ReportError("decode DeployStageSpecRollbackPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecRolloutPolicyCodec struct {
}

func (DeployStageSpecRolloutPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecRolloutPolicy)(ptr) == nil
}

func (DeployStageSpecRolloutPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecRolloutPolicy)(ptr)
	var objs []DeployStageSpecRolloutPolicy
	if obj != nil {
		objs = []DeployStageSpecRolloutPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRolloutPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecRolloutPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecRolloutPolicy)(ptr) = DeployStageSpecRolloutPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecRolloutPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRolloutPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecRolloutPolicy)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecRolloutPolicy)(ptr) = DeployStageSpecRolloutPolicy{}
			}
		} else {
			*(*DeployStageSpecRolloutPolicy)(ptr) = DeployStageSpecRolloutPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecRolloutPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecRolloutPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecRolloutPolicy)(ptr) = obj
		} else {
			*(*DeployStageSpecRolloutPolicy)(ptr) = DeployStageSpecRolloutPolicy{}
		}
	default:
		iter.ReportError("decode DeployStageSpecRolloutPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeployStageSpecWaitCriteriaCodec struct {
}

func (DeployStageSpecWaitCriteriaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeployStageSpecWaitCriteria)(ptr) == nil
}

func (DeployStageSpecWaitCriteriaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeployStageSpecWaitCriteria)(ptr)
	var objs []DeployStageSpecWaitCriteria
	if obj != nil {
		objs = []DeployStageSpecWaitCriteria{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecWaitCriteria{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeployStageSpecWaitCriteriaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeployStageSpecWaitCriteria)(ptr) = DeployStageSpecWaitCriteria{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeployStageSpecWaitCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecWaitCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeployStageSpecWaitCriteria)(ptr) = objs[0]
			} else {
				*(*DeployStageSpecWaitCriteria)(ptr) = DeployStageSpecWaitCriteria{}
			}
		} else {
			*(*DeployStageSpecWaitCriteria)(ptr) = DeployStageSpecWaitCriteria{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeployStageSpecWaitCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeployStageSpecWaitCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeployStageSpecWaitCriteria)(ptr) = obj
		} else {
			*(*DeployStageSpecWaitCriteria)(ptr) = DeployStageSpecWaitCriteria{}
		}
	default:
		iter.ReportError("decode DeployStageSpecWaitCriteria", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecDeployArtifactOverrideArgumentsCodec struct {
}

func (DeploymentSpecDeployArtifactOverrideArgumentsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecDeployArtifactOverrideArguments)(ptr) == nil
}

func (DeploymentSpecDeployArtifactOverrideArgumentsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecDeployArtifactOverrideArguments)(ptr)
	var objs []DeploymentSpecDeployArtifactOverrideArguments
	if obj != nil {
		objs = []DeploymentSpecDeployArtifactOverrideArguments{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployArtifactOverrideArguments{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecDeployArtifactOverrideArgumentsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecDeployArtifactOverrideArguments)(ptr) = DeploymentSpecDeployArtifactOverrideArguments{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecDeployArtifactOverrideArguments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployArtifactOverrideArguments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecDeployArtifactOverrideArguments)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecDeployArtifactOverrideArguments)(ptr) = DeploymentSpecDeployArtifactOverrideArguments{}
			}
		} else {
			*(*DeploymentSpecDeployArtifactOverrideArguments)(ptr) = DeploymentSpecDeployArtifactOverrideArguments{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecDeployArtifactOverrideArguments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployArtifactOverrideArguments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecDeployArtifactOverrideArguments)(ptr) = obj
		} else {
			*(*DeploymentSpecDeployArtifactOverrideArguments)(ptr) = DeploymentSpecDeployArtifactOverrideArguments{}
		}
	default:
		iter.ReportError("decode DeploymentSpecDeployArtifactOverrideArguments", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecDeployPipelineArtifactsCodec struct {
}

func (DeploymentSpecDeployPipelineArtifactsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecDeployPipelineArtifacts)(ptr) == nil
}

func (DeploymentSpecDeployPipelineArtifactsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecDeployPipelineArtifacts)(ptr)
	var objs []DeploymentSpecDeployPipelineArtifacts
	if obj != nil {
		objs = []DeploymentSpecDeployPipelineArtifacts{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifacts{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecDeployPipelineArtifactsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecDeployPipelineArtifacts)(ptr) = DeploymentSpecDeployPipelineArtifacts{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecDeployPipelineArtifacts

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifacts{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecDeployPipelineArtifacts)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecDeployPipelineArtifacts)(ptr) = DeploymentSpecDeployPipelineArtifacts{}
			}
		} else {
			*(*DeploymentSpecDeployPipelineArtifacts)(ptr) = DeploymentSpecDeployPipelineArtifacts{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecDeployPipelineArtifacts

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifacts{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecDeployPipelineArtifacts)(ptr) = obj
		} else {
			*(*DeploymentSpecDeployPipelineArtifacts)(ptr) = DeploymentSpecDeployPipelineArtifacts{}
		}
	default:
		iter.ReportError("decode DeploymentSpecDeployPipelineArtifacts", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec struct {
}

func (DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) == nil
}

func (DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr)
	var objs []DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages
	if obj != nil {
		objs = []DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStagesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}
			}
		} else {
			*(*DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = obj
		} else {
			*(*DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages)(ptr) = DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages{}
		}
	default:
		iter.ReportError("decode DeploymentSpecDeployPipelineArtifactsItemsDeployPipelineStages", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecDeployPipelineEnvironmentsCodec struct {
}

func (DeploymentSpecDeployPipelineEnvironmentsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecDeployPipelineEnvironments)(ptr) == nil
}

func (DeploymentSpecDeployPipelineEnvironmentsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecDeployPipelineEnvironments)(ptr)
	var objs []DeploymentSpecDeployPipelineEnvironments
	if obj != nil {
		objs = []DeploymentSpecDeployPipelineEnvironments{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironments{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecDeployPipelineEnvironmentsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecDeployPipelineEnvironments)(ptr) = DeploymentSpecDeployPipelineEnvironments{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecDeployPipelineEnvironments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecDeployPipelineEnvironments)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecDeployPipelineEnvironments)(ptr) = DeploymentSpecDeployPipelineEnvironments{}
			}
		} else {
			*(*DeploymentSpecDeployPipelineEnvironments)(ptr) = DeploymentSpecDeployPipelineEnvironments{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecDeployPipelineEnvironments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecDeployPipelineEnvironments)(ptr) = obj
		} else {
			*(*DeploymentSpecDeployPipelineEnvironments)(ptr) = DeploymentSpecDeployPipelineEnvironments{}
		}
	default:
		iter.ReportError("decode DeploymentSpecDeployPipelineEnvironments", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec struct {
}

func (DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) == nil
}

func (DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr)
	var objs []DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages
	if obj != nil {
		objs = []DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStagesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}
			}
		} else {
			*(*DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = obj
		} else {
			*(*DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages)(ptr) = DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages{}
		}
	default:
		iter.ReportError("decode DeploymentSpecDeployPipelineEnvironmentsItemsDeployPipelineStages", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecDeploymentArgumentsCodec struct {
}

func (DeploymentSpecDeploymentArgumentsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecDeploymentArguments)(ptr) == nil
}

func (DeploymentSpecDeploymentArgumentsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecDeploymentArguments)(ptr)
	var objs []DeploymentSpecDeploymentArguments
	if obj != nil {
		objs = []DeploymentSpecDeploymentArguments{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentArguments{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecDeploymentArgumentsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecDeploymentArguments)(ptr) = DeploymentSpecDeploymentArguments{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecDeploymentArguments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentArguments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecDeploymentArguments)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecDeploymentArguments)(ptr) = DeploymentSpecDeploymentArguments{}
			}
		} else {
			*(*DeploymentSpecDeploymentArguments)(ptr) = DeploymentSpecDeploymentArguments{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecDeploymentArguments

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentArguments{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecDeploymentArguments)(ptr) = obj
		} else {
			*(*DeploymentSpecDeploymentArguments)(ptr) = DeploymentSpecDeploymentArguments{}
		}
	default:
		iter.ReportError("decode DeploymentSpecDeploymentArguments", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecDeploymentExecutionProgressCodec struct {
}

func (DeploymentSpecDeploymentExecutionProgressCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecDeploymentExecutionProgress)(ptr) == nil
}

func (DeploymentSpecDeploymentExecutionProgressCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecDeploymentExecutionProgress)(ptr)
	var objs []DeploymentSpecDeploymentExecutionProgress
	if obj != nil {
		objs = []DeploymentSpecDeploymentExecutionProgress{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentExecutionProgress{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecDeploymentExecutionProgressCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecDeploymentExecutionProgress)(ptr) = DeploymentSpecDeploymentExecutionProgress{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecDeploymentExecutionProgress

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentExecutionProgress{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecDeploymentExecutionProgress)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecDeploymentExecutionProgress)(ptr) = DeploymentSpecDeploymentExecutionProgress{}
			}
		} else {
			*(*DeploymentSpecDeploymentExecutionProgress)(ptr) = DeploymentSpecDeploymentExecutionProgress{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecDeploymentExecutionProgress

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecDeploymentExecutionProgress{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecDeploymentExecutionProgress)(ptr) = obj
		} else {
			*(*DeploymentSpecDeploymentExecutionProgress)(ptr) = DeploymentSpecDeploymentExecutionProgress{}
		}
	default:
		iter.ReportError("decode DeploymentSpecDeploymentExecutionProgress", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ProjectSpecNotificationConfigCodec struct {
}

func (ProjectSpecNotificationConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ProjectSpecNotificationConfig)(ptr) == nil
}

func (ProjectSpecNotificationConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ProjectSpecNotificationConfig)(ptr)
	var objs []ProjectSpecNotificationConfig
	if obj != nil {
		objs = []ProjectSpecNotificationConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProjectSpecNotificationConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ProjectSpecNotificationConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ProjectSpecNotificationConfig)(ptr) = ProjectSpecNotificationConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ProjectSpecNotificationConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProjectSpecNotificationConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ProjectSpecNotificationConfig)(ptr) = objs[0]
			} else {
				*(*ProjectSpecNotificationConfig)(ptr) = ProjectSpecNotificationConfig{}
			}
		} else {
			*(*ProjectSpecNotificationConfig)(ptr) = ProjectSpecNotificationConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ProjectSpecNotificationConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProjectSpecNotificationConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ProjectSpecNotificationConfig)(ptr) = obj
		} else {
			*(*ProjectSpecNotificationConfig)(ptr) = ProjectSpecNotificationConfig{}
		}
	default:
		iter.ReportError("decode ProjectSpecNotificationConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RepositorySpecMirrorRepositoryConfigCodec struct {
}

func (RepositorySpecMirrorRepositoryConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RepositorySpecMirrorRepositoryConfig)(ptr) == nil
}

func (RepositorySpecMirrorRepositoryConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RepositorySpecMirrorRepositoryConfig)(ptr)
	var objs []RepositorySpecMirrorRepositoryConfig
	if obj != nil {
		objs = []RepositorySpecMirrorRepositoryConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RepositorySpecMirrorRepositoryConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RepositorySpecMirrorRepositoryConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RepositorySpecMirrorRepositoryConfig)(ptr) = RepositorySpecMirrorRepositoryConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RepositorySpecMirrorRepositoryConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RepositorySpecMirrorRepositoryConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RepositorySpecMirrorRepositoryConfig)(ptr) = objs[0]
			} else {
				*(*RepositorySpecMirrorRepositoryConfig)(ptr) = RepositorySpecMirrorRepositoryConfig{}
			}
		} else {
			*(*RepositorySpecMirrorRepositoryConfig)(ptr) = RepositorySpecMirrorRepositoryConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RepositorySpecMirrorRepositoryConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RepositorySpecMirrorRepositoryConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RepositorySpecMirrorRepositoryConfig)(ptr) = obj
		} else {
			*(*RepositorySpecMirrorRepositoryConfig)(ptr) = RepositorySpecMirrorRepositoryConfig{}
		}
	default:
		iter.ReportError("decode RepositorySpecMirrorRepositoryConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RepositorySpecMirrorRepositoryConfigTriggerScheduleCodec struct {
}

func (RepositorySpecMirrorRepositoryConfigTriggerScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RepositorySpecMirrorRepositoryConfigTriggerSchedule)(ptr) == nil
}

func (RepositorySpecMirrorRepositoryConfigTriggerScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RepositorySpecMirrorRepositoryConfigTriggerSchedule)(ptr)
	var objs []RepositorySpecMirrorRepositoryConfigTriggerSchedule
	if obj != nil {
		objs = []RepositorySpecMirrorRepositoryConfigTriggerSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RepositorySpecMirrorRepositoryConfigTriggerSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RepositorySpecMirrorRepositoryConfigTriggerScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RepositorySpecMirrorRepositoryConfigTriggerSchedule)(ptr) = RepositorySpecMirrorRepositoryConfigTriggerSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RepositorySpecMirrorRepositoryConfigTriggerSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RepositorySpecMirrorRepositoryConfigTriggerSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RepositorySpecMirrorRepositoryConfigTriggerSchedule)(ptr) = objs[0]
			} else {
				*(*RepositorySpecMirrorRepositoryConfigTriggerSchedule)(ptr) = RepositorySpecMirrorRepositoryConfigTriggerSchedule{}
			}
		} else {
			*(*RepositorySpecMirrorRepositoryConfigTriggerSchedule)(ptr) = RepositorySpecMirrorRepositoryConfigTriggerSchedule{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RepositorySpecMirrorRepositoryConfigTriggerSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RepositorySpecMirrorRepositoryConfigTriggerSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RepositorySpecMirrorRepositoryConfigTriggerSchedule)(ptr) = obj
		} else {
			*(*RepositorySpecMirrorRepositoryConfigTriggerSchedule)(ptr) = RepositorySpecMirrorRepositoryConfigTriggerSchedule{}
		}
	default:
		iter.ReportError("decode RepositorySpecMirrorRepositoryConfigTriggerSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TriggerSpecActionsFilterCodec struct {
}

func (TriggerSpecActionsFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TriggerSpecActionsFilter)(ptr) == nil
}

func (TriggerSpecActionsFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TriggerSpecActionsFilter)(ptr)
	var objs []TriggerSpecActionsFilter
	if obj != nil {
		objs = []TriggerSpecActionsFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecActionsFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TriggerSpecActionsFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TriggerSpecActionsFilter)(ptr) = TriggerSpecActionsFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TriggerSpecActionsFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecActionsFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TriggerSpecActionsFilter)(ptr) = objs[0]
			} else {
				*(*TriggerSpecActionsFilter)(ptr) = TriggerSpecActionsFilter{}
			}
		} else {
			*(*TriggerSpecActionsFilter)(ptr) = TriggerSpecActionsFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TriggerSpecActionsFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecActionsFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TriggerSpecActionsFilter)(ptr) = obj
		} else {
			*(*TriggerSpecActionsFilter)(ptr) = TriggerSpecActionsFilter{}
		}
	default:
		iter.ReportError("decode TriggerSpecActionsFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TriggerSpecActionsFilterIncludeCodec struct {
}

func (TriggerSpecActionsFilterIncludeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TriggerSpecActionsFilterInclude)(ptr) == nil
}

func (TriggerSpecActionsFilterIncludeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TriggerSpecActionsFilterInclude)(ptr)
	var objs []TriggerSpecActionsFilterInclude
	if obj != nil {
		objs = []TriggerSpecActionsFilterInclude{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecActionsFilterInclude{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TriggerSpecActionsFilterIncludeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TriggerSpecActionsFilterInclude)(ptr) = TriggerSpecActionsFilterInclude{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TriggerSpecActionsFilterInclude

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecActionsFilterInclude{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TriggerSpecActionsFilterInclude)(ptr) = objs[0]
			} else {
				*(*TriggerSpecActionsFilterInclude)(ptr) = TriggerSpecActionsFilterInclude{}
			}
		} else {
			*(*TriggerSpecActionsFilterInclude)(ptr) = TriggerSpecActionsFilterInclude{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TriggerSpecActionsFilterInclude

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecActionsFilterInclude{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TriggerSpecActionsFilterInclude)(ptr) = obj
		} else {
			*(*TriggerSpecActionsFilterInclude)(ptr) = TriggerSpecActionsFilterInclude{}
		}
	default:
		iter.ReportError("decode TriggerSpecActionsFilterInclude", "unexpected JSON type")
	}
}
