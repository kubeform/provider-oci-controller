/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(GeneratedKeySpecKeyShape{}).Type1()):        GeneratedKeySpecKeyShapeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KeySpecKeyShape{}).Type1()):                 KeySpecKeyShapeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KeySpecReplicaDetails{}).Type1()):           KeySpecReplicaDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KeySpecRestoreFromFile{}).Type1()):          KeySpecRestoreFromFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KeySpecRestoreFromObjectStore{}).Type1()):   KeySpecRestoreFromObjectStoreCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KeyVersionSpecReplicaDetails{}).Type1()):    KeyVersionSpecReplicaDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VaultSpecReplicaDetails{}).Type1()):         VaultSpecReplicaDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VaultSpecRestoreFromFile{}).Type1()):        VaultSpecRestoreFromFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VaultSpecRestoreFromObjectStore{}).Type1()): VaultSpecRestoreFromObjectStoreCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(GeneratedKeySpecKeyShape{}).Type1()):        GeneratedKeySpecKeyShapeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KeySpecKeyShape{}).Type1()):                 KeySpecKeyShapeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KeySpecReplicaDetails{}).Type1()):           KeySpecReplicaDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KeySpecRestoreFromFile{}).Type1()):          KeySpecRestoreFromFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KeySpecRestoreFromObjectStore{}).Type1()):   KeySpecRestoreFromObjectStoreCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KeyVersionSpecReplicaDetails{}).Type1()):    KeyVersionSpecReplicaDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VaultSpecReplicaDetails{}).Type1()):         VaultSpecReplicaDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VaultSpecRestoreFromFile{}).Type1()):        VaultSpecRestoreFromFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VaultSpecRestoreFromObjectStore{}).Type1()): VaultSpecRestoreFromObjectStoreCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type GeneratedKeySpecKeyShapeCodec struct {
}

func (GeneratedKeySpecKeyShapeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GeneratedKeySpecKeyShape)(ptr) == nil
}

func (GeneratedKeySpecKeyShapeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GeneratedKeySpecKeyShape)(ptr)
	var objs []GeneratedKeySpecKeyShape
	if obj != nil {
		objs = []GeneratedKeySpecKeyShape{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GeneratedKeySpecKeyShape{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GeneratedKeySpecKeyShapeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GeneratedKeySpecKeyShape)(ptr) = GeneratedKeySpecKeyShape{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GeneratedKeySpecKeyShape

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GeneratedKeySpecKeyShape{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GeneratedKeySpecKeyShape)(ptr) = objs[0]
			} else {
				*(*GeneratedKeySpecKeyShape)(ptr) = GeneratedKeySpecKeyShape{}
			}
		} else {
			*(*GeneratedKeySpecKeyShape)(ptr) = GeneratedKeySpecKeyShape{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GeneratedKeySpecKeyShape

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GeneratedKeySpecKeyShape{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GeneratedKeySpecKeyShape)(ptr) = obj
		} else {
			*(*GeneratedKeySpecKeyShape)(ptr) = GeneratedKeySpecKeyShape{}
		}
	default:
		iter.ReportError("decode GeneratedKeySpecKeyShape", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KeySpecKeyShapeCodec struct {
}

func (KeySpecKeyShapeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KeySpecKeyShape)(ptr) == nil
}

func (KeySpecKeyShapeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KeySpecKeyShape)(ptr)
	var objs []KeySpecKeyShape
	if obj != nil {
		objs = []KeySpecKeyShape{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeySpecKeyShape{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KeySpecKeyShapeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KeySpecKeyShape)(ptr) = KeySpecKeyShape{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KeySpecKeyShape

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeySpecKeyShape{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KeySpecKeyShape)(ptr) = objs[0]
			} else {
				*(*KeySpecKeyShape)(ptr) = KeySpecKeyShape{}
			}
		} else {
			*(*KeySpecKeyShape)(ptr) = KeySpecKeyShape{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KeySpecKeyShape

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeySpecKeyShape{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KeySpecKeyShape)(ptr) = obj
		} else {
			*(*KeySpecKeyShape)(ptr) = KeySpecKeyShape{}
		}
	default:
		iter.ReportError("decode KeySpecKeyShape", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KeySpecReplicaDetailsCodec struct {
}

func (KeySpecReplicaDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KeySpecReplicaDetails)(ptr) == nil
}

func (KeySpecReplicaDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KeySpecReplicaDetails)(ptr)
	var objs []KeySpecReplicaDetails
	if obj != nil {
		objs = []KeySpecReplicaDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeySpecReplicaDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KeySpecReplicaDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KeySpecReplicaDetails)(ptr) = KeySpecReplicaDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KeySpecReplicaDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeySpecReplicaDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KeySpecReplicaDetails)(ptr) = objs[0]
			} else {
				*(*KeySpecReplicaDetails)(ptr) = KeySpecReplicaDetails{}
			}
		} else {
			*(*KeySpecReplicaDetails)(ptr) = KeySpecReplicaDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KeySpecReplicaDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeySpecReplicaDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KeySpecReplicaDetails)(ptr) = obj
		} else {
			*(*KeySpecReplicaDetails)(ptr) = KeySpecReplicaDetails{}
		}
	default:
		iter.ReportError("decode KeySpecReplicaDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KeySpecRestoreFromFileCodec struct {
}

func (KeySpecRestoreFromFileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KeySpecRestoreFromFile)(ptr) == nil
}

func (KeySpecRestoreFromFileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KeySpecRestoreFromFile)(ptr)
	var objs []KeySpecRestoreFromFile
	if obj != nil {
		objs = []KeySpecRestoreFromFile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeySpecRestoreFromFile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KeySpecRestoreFromFileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KeySpecRestoreFromFile)(ptr) = KeySpecRestoreFromFile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KeySpecRestoreFromFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeySpecRestoreFromFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KeySpecRestoreFromFile)(ptr) = objs[0]
			} else {
				*(*KeySpecRestoreFromFile)(ptr) = KeySpecRestoreFromFile{}
			}
		} else {
			*(*KeySpecRestoreFromFile)(ptr) = KeySpecRestoreFromFile{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KeySpecRestoreFromFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeySpecRestoreFromFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KeySpecRestoreFromFile)(ptr) = obj
		} else {
			*(*KeySpecRestoreFromFile)(ptr) = KeySpecRestoreFromFile{}
		}
	default:
		iter.ReportError("decode KeySpecRestoreFromFile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KeySpecRestoreFromObjectStoreCodec struct {
}

func (KeySpecRestoreFromObjectStoreCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KeySpecRestoreFromObjectStore)(ptr) == nil
}

func (KeySpecRestoreFromObjectStoreCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KeySpecRestoreFromObjectStore)(ptr)
	var objs []KeySpecRestoreFromObjectStore
	if obj != nil {
		objs = []KeySpecRestoreFromObjectStore{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeySpecRestoreFromObjectStore{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KeySpecRestoreFromObjectStoreCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KeySpecRestoreFromObjectStore)(ptr) = KeySpecRestoreFromObjectStore{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KeySpecRestoreFromObjectStore

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeySpecRestoreFromObjectStore{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KeySpecRestoreFromObjectStore)(ptr) = objs[0]
			} else {
				*(*KeySpecRestoreFromObjectStore)(ptr) = KeySpecRestoreFromObjectStore{}
			}
		} else {
			*(*KeySpecRestoreFromObjectStore)(ptr) = KeySpecRestoreFromObjectStore{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KeySpecRestoreFromObjectStore

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeySpecRestoreFromObjectStore{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KeySpecRestoreFromObjectStore)(ptr) = obj
		} else {
			*(*KeySpecRestoreFromObjectStore)(ptr) = KeySpecRestoreFromObjectStore{}
		}
	default:
		iter.ReportError("decode KeySpecRestoreFromObjectStore", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KeyVersionSpecReplicaDetailsCodec struct {
}

func (KeyVersionSpecReplicaDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KeyVersionSpecReplicaDetails)(ptr) == nil
}

func (KeyVersionSpecReplicaDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KeyVersionSpecReplicaDetails)(ptr)
	var objs []KeyVersionSpecReplicaDetails
	if obj != nil {
		objs = []KeyVersionSpecReplicaDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeyVersionSpecReplicaDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KeyVersionSpecReplicaDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KeyVersionSpecReplicaDetails)(ptr) = KeyVersionSpecReplicaDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KeyVersionSpecReplicaDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeyVersionSpecReplicaDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KeyVersionSpecReplicaDetails)(ptr) = objs[0]
			} else {
				*(*KeyVersionSpecReplicaDetails)(ptr) = KeyVersionSpecReplicaDetails{}
			}
		} else {
			*(*KeyVersionSpecReplicaDetails)(ptr) = KeyVersionSpecReplicaDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KeyVersionSpecReplicaDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KeyVersionSpecReplicaDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KeyVersionSpecReplicaDetails)(ptr) = obj
		} else {
			*(*KeyVersionSpecReplicaDetails)(ptr) = KeyVersionSpecReplicaDetails{}
		}
	default:
		iter.ReportError("decode KeyVersionSpecReplicaDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VaultSpecReplicaDetailsCodec struct {
}

func (VaultSpecReplicaDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VaultSpecReplicaDetails)(ptr) == nil
}

func (VaultSpecReplicaDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VaultSpecReplicaDetails)(ptr)
	var objs []VaultSpecReplicaDetails
	if obj != nil {
		objs = []VaultSpecReplicaDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VaultSpecReplicaDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VaultSpecReplicaDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VaultSpecReplicaDetails)(ptr) = VaultSpecReplicaDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VaultSpecReplicaDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VaultSpecReplicaDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VaultSpecReplicaDetails)(ptr) = objs[0]
			} else {
				*(*VaultSpecReplicaDetails)(ptr) = VaultSpecReplicaDetails{}
			}
		} else {
			*(*VaultSpecReplicaDetails)(ptr) = VaultSpecReplicaDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj VaultSpecReplicaDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VaultSpecReplicaDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*VaultSpecReplicaDetails)(ptr) = obj
		} else {
			*(*VaultSpecReplicaDetails)(ptr) = VaultSpecReplicaDetails{}
		}
	default:
		iter.ReportError("decode VaultSpecReplicaDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VaultSpecRestoreFromFileCodec struct {
}

func (VaultSpecRestoreFromFileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VaultSpecRestoreFromFile)(ptr) == nil
}

func (VaultSpecRestoreFromFileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VaultSpecRestoreFromFile)(ptr)
	var objs []VaultSpecRestoreFromFile
	if obj != nil {
		objs = []VaultSpecRestoreFromFile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VaultSpecRestoreFromFile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VaultSpecRestoreFromFileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VaultSpecRestoreFromFile)(ptr) = VaultSpecRestoreFromFile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VaultSpecRestoreFromFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VaultSpecRestoreFromFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VaultSpecRestoreFromFile)(ptr) = objs[0]
			} else {
				*(*VaultSpecRestoreFromFile)(ptr) = VaultSpecRestoreFromFile{}
			}
		} else {
			*(*VaultSpecRestoreFromFile)(ptr) = VaultSpecRestoreFromFile{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj VaultSpecRestoreFromFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VaultSpecRestoreFromFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*VaultSpecRestoreFromFile)(ptr) = obj
		} else {
			*(*VaultSpecRestoreFromFile)(ptr) = VaultSpecRestoreFromFile{}
		}
	default:
		iter.ReportError("decode VaultSpecRestoreFromFile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VaultSpecRestoreFromObjectStoreCodec struct {
}

func (VaultSpecRestoreFromObjectStoreCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VaultSpecRestoreFromObjectStore)(ptr) == nil
}

func (VaultSpecRestoreFromObjectStoreCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VaultSpecRestoreFromObjectStore)(ptr)
	var objs []VaultSpecRestoreFromObjectStore
	if obj != nil {
		objs = []VaultSpecRestoreFromObjectStore{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VaultSpecRestoreFromObjectStore{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VaultSpecRestoreFromObjectStoreCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VaultSpecRestoreFromObjectStore)(ptr) = VaultSpecRestoreFromObjectStore{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VaultSpecRestoreFromObjectStore

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VaultSpecRestoreFromObjectStore{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VaultSpecRestoreFromObjectStore)(ptr) = objs[0]
			} else {
				*(*VaultSpecRestoreFromObjectStore)(ptr) = VaultSpecRestoreFromObjectStore{}
			}
		} else {
			*(*VaultSpecRestoreFromObjectStore)(ptr) = VaultSpecRestoreFromObjectStore{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj VaultSpecRestoreFromObjectStore

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VaultSpecRestoreFromObjectStore{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*VaultSpecRestoreFromObjectStore)(ptr) = obj
		} else {
			*(*VaultSpecRestoreFromObjectStore)(ptr) = VaultSpecRestoreFromObjectStore{}
		}
	default:
		iter.ReportError("decode VaultSpecRestoreFromObjectStore", "unexpected JSON type")
	}
}
