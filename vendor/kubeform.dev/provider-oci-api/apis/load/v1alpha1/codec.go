/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerSpecIpAddressDetailsReservedIP{}).Type1()):                        BalancerSpecIpAddressDetailsReservedIPCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerSpecShapeDetails{}).Type1()):                                      BalancerSpecShapeDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecHealthChecker{}).Type1()):                           BalancerBackendSetSpecHealthCheckerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration{}).Type1()): BalancerBackendSetSpecLbCookieSessionPersistenceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecSessionPersistenceConfiguration{}).Type1()):         BalancerBackendSetSpecSessionPersistenceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecSslConfiguration{}).Type1()):                        BalancerBackendSetSpecSslConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecHealthChecker{}).Type1()):                           BalancerBackendsetSpecHealthCheckerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration{}).Type1()): BalancerBackendsetSpecLbCookieSessionPersistenceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecSessionPersistenceConfiguration{}).Type1()):         BalancerBackendsetSpecSessionPersistenceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecSslConfiguration{}).Type1()):                        BalancerBackendsetSpecSslConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerListenerSpecConnectionConfiguration{}).Type1()):                   BalancerListenerSpecConnectionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerListenerSpecSslConfiguration{}).Type1()):                          BalancerListenerSpecSslConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerLoadBalancerSpecIpAddressDetailsReservedIP{}).Type1()):            BalancerLoadBalancerSpecIpAddressDetailsReservedIPCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerLoadBalancerSpecShapeDetails{}).Type1()):                          BalancerLoadBalancerSpecShapeDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerPathRouteSetSpecPathRoutesPathMatchType{}).Type1()):               BalancerPathRouteSetSpecPathRoutesPathMatchTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerRuleSetSpecItemsRedirectURI{}).Type1()):                           BalancerRuleSetSpecItemsRedirectURICodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerSpecIpAddressDetailsReservedIP{}).Type1()):                        BalancerSpecIpAddressDetailsReservedIPCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerSpecShapeDetails{}).Type1()):                                      BalancerSpecShapeDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecHealthChecker{}).Type1()):                           BalancerBackendSetSpecHealthCheckerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration{}).Type1()): BalancerBackendSetSpecLbCookieSessionPersistenceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecSessionPersistenceConfiguration{}).Type1()):         BalancerBackendSetSpecSessionPersistenceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecSslConfiguration{}).Type1()):                        BalancerBackendSetSpecSslConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecHealthChecker{}).Type1()):                           BalancerBackendsetSpecHealthCheckerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration{}).Type1()): BalancerBackendsetSpecLbCookieSessionPersistenceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecSessionPersistenceConfiguration{}).Type1()):         BalancerBackendsetSpecSessionPersistenceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecSslConfiguration{}).Type1()):                        BalancerBackendsetSpecSslConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerListenerSpecConnectionConfiguration{}).Type1()):                   BalancerListenerSpecConnectionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerListenerSpecSslConfiguration{}).Type1()):                          BalancerListenerSpecSslConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerLoadBalancerSpecIpAddressDetailsReservedIP{}).Type1()):            BalancerLoadBalancerSpecIpAddressDetailsReservedIPCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerLoadBalancerSpecShapeDetails{}).Type1()):                          BalancerLoadBalancerSpecShapeDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerPathRouteSetSpecPathRoutesPathMatchType{}).Type1()):               BalancerPathRouteSetSpecPathRoutesPathMatchTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BalancerRuleSetSpecItemsRedirectURI{}).Type1()):                           BalancerRuleSetSpecItemsRedirectURICodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type BalancerSpecIpAddressDetailsReservedIPCodec struct {
}

func (BalancerSpecIpAddressDetailsReservedIPCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BalancerSpecIpAddressDetailsReservedIP)(ptr) == nil
}

func (BalancerSpecIpAddressDetailsReservedIPCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BalancerSpecIpAddressDetailsReservedIP)(ptr)
	var objs []BalancerSpecIpAddressDetailsReservedIP
	if obj != nil {
		objs = []BalancerSpecIpAddressDetailsReservedIP{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerSpecIpAddressDetailsReservedIP{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BalancerSpecIpAddressDetailsReservedIPCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BalancerSpecIpAddressDetailsReservedIP)(ptr) = BalancerSpecIpAddressDetailsReservedIP{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BalancerSpecIpAddressDetailsReservedIP

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerSpecIpAddressDetailsReservedIP{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BalancerSpecIpAddressDetailsReservedIP)(ptr) = objs[0]
			} else {
				*(*BalancerSpecIpAddressDetailsReservedIP)(ptr) = BalancerSpecIpAddressDetailsReservedIP{}
			}
		} else {
			*(*BalancerSpecIpAddressDetailsReservedIP)(ptr) = BalancerSpecIpAddressDetailsReservedIP{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BalancerSpecIpAddressDetailsReservedIP

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerSpecIpAddressDetailsReservedIP{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BalancerSpecIpAddressDetailsReservedIP)(ptr) = obj
		} else {
			*(*BalancerSpecIpAddressDetailsReservedIP)(ptr) = BalancerSpecIpAddressDetailsReservedIP{}
		}
	default:
		iter.ReportError("decode BalancerSpecIpAddressDetailsReservedIP", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BalancerSpecShapeDetailsCodec struct {
}

func (BalancerSpecShapeDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BalancerSpecShapeDetails)(ptr) == nil
}

func (BalancerSpecShapeDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BalancerSpecShapeDetails)(ptr)
	var objs []BalancerSpecShapeDetails
	if obj != nil {
		objs = []BalancerSpecShapeDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerSpecShapeDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BalancerSpecShapeDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BalancerSpecShapeDetails)(ptr) = BalancerSpecShapeDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BalancerSpecShapeDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerSpecShapeDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BalancerSpecShapeDetails)(ptr) = objs[0]
			} else {
				*(*BalancerSpecShapeDetails)(ptr) = BalancerSpecShapeDetails{}
			}
		} else {
			*(*BalancerSpecShapeDetails)(ptr) = BalancerSpecShapeDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BalancerSpecShapeDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerSpecShapeDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BalancerSpecShapeDetails)(ptr) = obj
		} else {
			*(*BalancerSpecShapeDetails)(ptr) = BalancerSpecShapeDetails{}
		}
	default:
		iter.ReportError("decode BalancerSpecShapeDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BalancerBackendSetSpecHealthCheckerCodec struct {
}

func (BalancerBackendSetSpecHealthCheckerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BalancerBackendSetSpecHealthChecker)(ptr) == nil
}

func (BalancerBackendSetSpecHealthCheckerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BalancerBackendSetSpecHealthChecker)(ptr)
	var objs []BalancerBackendSetSpecHealthChecker
	if obj != nil {
		objs = []BalancerBackendSetSpecHealthChecker{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecHealthChecker{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BalancerBackendSetSpecHealthCheckerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BalancerBackendSetSpecHealthChecker)(ptr) = BalancerBackendSetSpecHealthChecker{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BalancerBackendSetSpecHealthChecker

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecHealthChecker{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BalancerBackendSetSpecHealthChecker)(ptr) = objs[0]
			} else {
				*(*BalancerBackendSetSpecHealthChecker)(ptr) = BalancerBackendSetSpecHealthChecker{}
			}
		} else {
			*(*BalancerBackendSetSpecHealthChecker)(ptr) = BalancerBackendSetSpecHealthChecker{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BalancerBackendSetSpecHealthChecker

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecHealthChecker{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BalancerBackendSetSpecHealthChecker)(ptr) = obj
		} else {
			*(*BalancerBackendSetSpecHealthChecker)(ptr) = BalancerBackendSetSpecHealthChecker{}
		}
	default:
		iter.ReportError("decode BalancerBackendSetSpecHealthChecker", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BalancerBackendSetSpecLbCookieSessionPersistenceConfigurationCodec struct {
}

func (BalancerBackendSetSpecLbCookieSessionPersistenceConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration)(ptr) == nil
}

func (BalancerBackendSetSpecLbCookieSessionPersistenceConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration)(ptr)
	var objs []BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration
	if obj != nil {
		objs = []BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BalancerBackendSetSpecLbCookieSessionPersistenceConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration)(ptr) = BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration)(ptr) = objs[0]
			} else {
				*(*BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration)(ptr) = BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration{}
			}
		} else {
			*(*BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration)(ptr) = BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration)(ptr) = obj
		} else {
			*(*BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration)(ptr) = BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration{}
		}
	default:
		iter.ReportError("decode BalancerBackendSetSpecLbCookieSessionPersistenceConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BalancerBackendSetSpecSessionPersistenceConfigurationCodec struct {
}

func (BalancerBackendSetSpecSessionPersistenceConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BalancerBackendSetSpecSessionPersistenceConfiguration)(ptr) == nil
}

func (BalancerBackendSetSpecSessionPersistenceConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BalancerBackendSetSpecSessionPersistenceConfiguration)(ptr)
	var objs []BalancerBackendSetSpecSessionPersistenceConfiguration
	if obj != nil {
		objs = []BalancerBackendSetSpecSessionPersistenceConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecSessionPersistenceConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BalancerBackendSetSpecSessionPersistenceConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BalancerBackendSetSpecSessionPersistenceConfiguration)(ptr) = BalancerBackendSetSpecSessionPersistenceConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BalancerBackendSetSpecSessionPersistenceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecSessionPersistenceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BalancerBackendSetSpecSessionPersistenceConfiguration)(ptr) = objs[0]
			} else {
				*(*BalancerBackendSetSpecSessionPersistenceConfiguration)(ptr) = BalancerBackendSetSpecSessionPersistenceConfiguration{}
			}
		} else {
			*(*BalancerBackendSetSpecSessionPersistenceConfiguration)(ptr) = BalancerBackendSetSpecSessionPersistenceConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BalancerBackendSetSpecSessionPersistenceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecSessionPersistenceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BalancerBackendSetSpecSessionPersistenceConfiguration)(ptr) = obj
		} else {
			*(*BalancerBackendSetSpecSessionPersistenceConfiguration)(ptr) = BalancerBackendSetSpecSessionPersistenceConfiguration{}
		}
	default:
		iter.ReportError("decode BalancerBackendSetSpecSessionPersistenceConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BalancerBackendSetSpecSslConfigurationCodec struct {
}

func (BalancerBackendSetSpecSslConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BalancerBackendSetSpecSslConfiguration)(ptr) == nil
}

func (BalancerBackendSetSpecSslConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BalancerBackendSetSpecSslConfiguration)(ptr)
	var objs []BalancerBackendSetSpecSslConfiguration
	if obj != nil {
		objs = []BalancerBackendSetSpecSslConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecSslConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BalancerBackendSetSpecSslConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BalancerBackendSetSpecSslConfiguration)(ptr) = BalancerBackendSetSpecSslConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BalancerBackendSetSpecSslConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecSslConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BalancerBackendSetSpecSslConfiguration)(ptr) = objs[0]
			} else {
				*(*BalancerBackendSetSpecSslConfiguration)(ptr) = BalancerBackendSetSpecSslConfiguration{}
			}
		} else {
			*(*BalancerBackendSetSpecSslConfiguration)(ptr) = BalancerBackendSetSpecSslConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BalancerBackendSetSpecSslConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendSetSpecSslConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BalancerBackendSetSpecSslConfiguration)(ptr) = obj
		} else {
			*(*BalancerBackendSetSpecSslConfiguration)(ptr) = BalancerBackendSetSpecSslConfiguration{}
		}
	default:
		iter.ReportError("decode BalancerBackendSetSpecSslConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BalancerBackendsetSpecHealthCheckerCodec struct {
}

func (BalancerBackendsetSpecHealthCheckerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BalancerBackendsetSpecHealthChecker)(ptr) == nil
}

func (BalancerBackendsetSpecHealthCheckerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BalancerBackendsetSpecHealthChecker)(ptr)
	var objs []BalancerBackendsetSpecHealthChecker
	if obj != nil {
		objs = []BalancerBackendsetSpecHealthChecker{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecHealthChecker{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BalancerBackendsetSpecHealthCheckerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BalancerBackendsetSpecHealthChecker)(ptr) = BalancerBackendsetSpecHealthChecker{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BalancerBackendsetSpecHealthChecker

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecHealthChecker{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BalancerBackendsetSpecHealthChecker)(ptr) = objs[0]
			} else {
				*(*BalancerBackendsetSpecHealthChecker)(ptr) = BalancerBackendsetSpecHealthChecker{}
			}
		} else {
			*(*BalancerBackendsetSpecHealthChecker)(ptr) = BalancerBackendsetSpecHealthChecker{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BalancerBackendsetSpecHealthChecker

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecHealthChecker{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BalancerBackendsetSpecHealthChecker)(ptr) = obj
		} else {
			*(*BalancerBackendsetSpecHealthChecker)(ptr) = BalancerBackendsetSpecHealthChecker{}
		}
	default:
		iter.ReportError("decode BalancerBackendsetSpecHealthChecker", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BalancerBackendsetSpecLbCookieSessionPersistenceConfigurationCodec struct {
}

func (BalancerBackendsetSpecLbCookieSessionPersistenceConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration)(ptr) == nil
}

func (BalancerBackendsetSpecLbCookieSessionPersistenceConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration)(ptr)
	var objs []BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration
	if obj != nil {
		objs = []BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BalancerBackendsetSpecLbCookieSessionPersistenceConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration)(ptr) = BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration)(ptr) = objs[0]
			} else {
				*(*BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration)(ptr) = BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration{}
			}
		} else {
			*(*BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration)(ptr) = BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration)(ptr) = obj
		} else {
			*(*BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration)(ptr) = BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration{}
		}
	default:
		iter.ReportError("decode BalancerBackendsetSpecLbCookieSessionPersistenceConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BalancerBackendsetSpecSessionPersistenceConfigurationCodec struct {
}

func (BalancerBackendsetSpecSessionPersistenceConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BalancerBackendsetSpecSessionPersistenceConfiguration)(ptr) == nil
}

func (BalancerBackendsetSpecSessionPersistenceConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BalancerBackendsetSpecSessionPersistenceConfiguration)(ptr)
	var objs []BalancerBackendsetSpecSessionPersistenceConfiguration
	if obj != nil {
		objs = []BalancerBackendsetSpecSessionPersistenceConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecSessionPersistenceConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BalancerBackendsetSpecSessionPersistenceConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BalancerBackendsetSpecSessionPersistenceConfiguration)(ptr) = BalancerBackendsetSpecSessionPersistenceConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BalancerBackendsetSpecSessionPersistenceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecSessionPersistenceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BalancerBackendsetSpecSessionPersistenceConfiguration)(ptr) = objs[0]
			} else {
				*(*BalancerBackendsetSpecSessionPersistenceConfiguration)(ptr) = BalancerBackendsetSpecSessionPersistenceConfiguration{}
			}
		} else {
			*(*BalancerBackendsetSpecSessionPersistenceConfiguration)(ptr) = BalancerBackendsetSpecSessionPersistenceConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BalancerBackendsetSpecSessionPersistenceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecSessionPersistenceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BalancerBackendsetSpecSessionPersistenceConfiguration)(ptr) = obj
		} else {
			*(*BalancerBackendsetSpecSessionPersistenceConfiguration)(ptr) = BalancerBackendsetSpecSessionPersistenceConfiguration{}
		}
	default:
		iter.ReportError("decode BalancerBackendsetSpecSessionPersistenceConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BalancerBackendsetSpecSslConfigurationCodec struct {
}

func (BalancerBackendsetSpecSslConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BalancerBackendsetSpecSslConfiguration)(ptr) == nil
}

func (BalancerBackendsetSpecSslConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BalancerBackendsetSpecSslConfiguration)(ptr)
	var objs []BalancerBackendsetSpecSslConfiguration
	if obj != nil {
		objs = []BalancerBackendsetSpecSslConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecSslConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BalancerBackendsetSpecSslConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BalancerBackendsetSpecSslConfiguration)(ptr) = BalancerBackendsetSpecSslConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BalancerBackendsetSpecSslConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecSslConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BalancerBackendsetSpecSslConfiguration)(ptr) = objs[0]
			} else {
				*(*BalancerBackendsetSpecSslConfiguration)(ptr) = BalancerBackendsetSpecSslConfiguration{}
			}
		} else {
			*(*BalancerBackendsetSpecSslConfiguration)(ptr) = BalancerBackendsetSpecSslConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BalancerBackendsetSpecSslConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerBackendsetSpecSslConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BalancerBackendsetSpecSslConfiguration)(ptr) = obj
		} else {
			*(*BalancerBackendsetSpecSslConfiguration)(ptr) = BalancerBackendsetSpecSslConfiguration{}
		}
	default:
		iter.ReportError("decode BalancerBackendsetSpecSslConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BalancerListenerSpecConnectionConfigurationCodec struct {
}

func (BalancerListenerSpecConnectionConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BalancerListenerSpecConnectionConfiguration)(ptr) == nil
}

func (BalancerListenerSpecConnectionConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BalancerListenerSpecConnectionConfiguration)(ptr)
	var objs []BalancerListenerSpecConnectionConfiguration
	if obj != nil {
		objs = []BalancerListenerSpecConnectionConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerListenerSpecConnectionConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BalancerListenerSpecConnectionConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BalancerListenerSpecConnectionConfiguration)(ptr) = BalancerListenerSpecConnectionConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BalancerListenerSpecConnectionConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerListenerSpecConnectionConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BalancerListenerSpecConnectionConfiguration)(ptr) = objs[0]
			} else {
				*(*BalancerListenerSpecConnectionConfiguration)(ptr) = BalancerListenerSpecConnectionConfiguration{}
			}
		} else {
			*(*BalancerListenerSpecConnectionConfiguration)(ptr) = BalancerListenerSpecConnectionConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BalancerListenerSpecConnectionConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerListenerSpecConnectionConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BalancerListenerSpecConnectionConfiguration)(ptr) = obj
		} else {
			*(*BalancerListenerSpecConnectionConfiguration)(ptr) = BalancerListenerSpecConnectionConfiguration{}
		}
	default:
		iter.ReportError("decode BalancerListenerSpecConnectionConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BalancerListenerSpecSslConfigurationCodec struct {
}

func (BalancerListenerSpecSslConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BalancerListenerSpecSslConfiguration)(ptr) == nil
}

func (BalancerListenerSpecSslConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BalancerListenerSpecSslConfiguration)(ptr)
	var objs []BalancerListenerSpecSslConfiguration
	if obj != nil {
		objs = []BalancerListenerSpecSslConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerListenerSpecSslConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BalancerListenerSpecSslConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BalancerListenerSpecSslConfiguration)(ptr) = BalancerListenerSpecSslConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BalancerListenerSpecSslConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerListenerSpecSslConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BalancerListenerSpecSslConfiguration)(ptr) = objs[0]
			} else {
				*(*BalancerListenerSpecSslConfiguration)(ptr) = BalancerListenerSpecSslConfiguration{}
			}
		} else {
			*(*BalancerListenerSpecSslConfiguration)(ptr) = BalancerListenerSpecSslConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BalancerListenerSpecSslConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerListenerSpecSslConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BalancerListenerSpecSslConfiguration)(ptr) = obj
		} else {
			*(*BalancerListenerSpecSslConfiguration)(ptr) = BalancerListenerSpecSslConfiguration{}
		}
	default:
		iter.ReportError("decode BalancerListenerSpecSslConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BalancerLoadBalancerSpecIpAddressDetailsReservedIPCodec struct {
}

func (BalancerLoadBalancerSpecIpAddressDetailsReservedIPCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BalancerLoadBalancerSpecIpAddressDetailsReservedIP)(ptr) == nil
}

func (BalancerLoadBalancerSpecIpAddressDetailsReservedIPCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BalancerLoadBalancerSpecIpAddressDetailsReservedIP)(ptr)
	var objs []BalancerLoadBalancerSpecIpAddressDetailsReservedIP
	if obj != nil {
		objs = []BalancerLoadBalancerSpecIpAddressDetailsReservedIP{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerLoadBalancerSpecIpAddressDetailsReservedIP{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BalancerLoadBalancerSpecIpAddressDetailsReservedIPCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BalancerLoadBalancerSpecIpAddressDetailsReservedIP)(ptr) = BalancerLoadBalancerSpecIpAddressDetailsReservedIP{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BalancerLoadBalancerSpecIpAddressDetailsReservedIP

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerLoadBalancerSpecIpAddressDetailsReservedIP{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BalancerLoadBalancerSpecIpAddressDetailsReservedIP)(ptr) = objs[0]
			} else {
				*(*BalancerLoadBalancerSpecIpAddressDetailsReservedIP)(ptr) = BalancerLoadBalancerSpecIpAddressDetailsReservedIP{}
			}
		} else {
			*(*BalancerLoadBalancerSpecIpAddressDetailsReservedIP)(ptr) = BalancerLoadBalancerSpecIpAddressDetailsReservedIP{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BalancerLoadBalancerSpecIpAddressDetailsReservedIP

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerLoadBalancerSpecIpAddressDetailsReservedIP{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BalancerLoadBalancerSpecIpAddressDetailsReservedIP)(ptr) = obj
		} else {
			*(*BalancerLoadBalancerSpecIpAddressDetailsReservedIP)(ptr) = BalancerLoadBalancerSpecIpAddressDetailsReservedIP{}
		}
	default:
		iter.ReportError("decode BalancerLoadBalancerSpecIpAddressDetailsReservedIP", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BalancerLoadBalancerSpecShapeDetailsCodec struct {
}

func (BalancerLoadBalancerSpecShapeDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BalancerLoadBalancerSpecShapeDetails)(ptr) == nil
}

func (BalancerLoadBalancerSpecShapeDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BalancerLoadBalancerSpecShapeDetails)(ptr)
	var objs []BalancerLoadBalancerSpecShapeDetails
	if obj != nil {
		objs = []BalancerLoadBalancerSpecShapeDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerLoadBalancerSpecShapeDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BalancerLoadBalancerSpecShapeDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BalancerLoadBalancerSpecShapeDetails)(ptr) = BalancerLoadBalancerSpecShapeDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BalancerLoadBalancerSpecShapeDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerLoadBalancerSpecShapeDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BalancerLoadBalancerSpecShapeDetails)(ptr) = objs[0]
			} else {
				*(*BalancerLoadBalancerSpecShapeDetails)(ptr) = BalancerLoadBalancerSpecShapeDetails{}
			}
		} else {
			*(*BalancerLoadBalancerSpecShapeDetails)(ptr) = BalancerLoadBalancerSpecShapeDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BalancerLoadBalancerSpecShapeDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerLoadBalancerSpecShapeDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BalancerLoadBalancerSpecShapeDetails)(ptr) = obj
		} else {
			*(*BalancerLoadBalancerSpecShapeDetails)(ptr) = BalancerLoadBalancerSpecShapeDetails{}
		}
	default:
		iter.ReportError("decode BalancerLoadBalancerSpecShapeDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BalancerPathRouteSetSpecPathRoutesPathMatchTypeCodec struct {
}

func (BalancerPathRouteSetSpecPathRoutesPathMatchTypeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BalancerPathRouteSetSpecPathRoutesPathMatchType)(ptr) == nil
}

func (BalancerPathRouteSetSpecPathRoutesPathMatchTypeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BalancerPathRouteSetSpecPathRoutesPathMatchType)(ptr)
	var objs []BalancerPathRouteSetSpecPathRoutesPathMatchType
	if obj != nil {
		objs = []BalancerPathRouteSetSpecPathRoutesPathMatchType{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerPathRouteSetSpecPathRoutesPathMatchType{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BalancerPathRouteSetSpecPathRoutesPathMatchTypeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BalancerPathRouteSetSpecPathRoutesPathMatchType)(ptr) = BalancerPathRouteSetSpecPathRoutesPathMatchType{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BalancerPathRouteSetSpecPathRoutesPathMatchType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerPathRouteSetSpecPathRoutesPathMatchType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BalancerPathRouteSetSpecPathRoutesPathMatchType)(ptr) = objs[0]
			} else {
				*(*BalancerPathRouteSetSpecPathRoutesPathMatchType)(ptr) = BalancerPathRouteSetSpecPathRoutesPathMatchType{}
			}
		} else {
			*(*BalancerPathRouteSetSpecPathRoutesPathMatchType)(ptr) = BalancerPathRouteSetSpecPathRoutesPathMatchType{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BalancerPathRouteSetSpecPathRoutesPathMatchType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerPathRouteSetSpecPathRoutesPathMatchType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BalancerPathRouteSetSpecPathRoutesPathMatchType)(ptr) = obj
		} else {
			*(*BalancerPathRouteSetSpecPathRoutesPathMatchType)(ptr) = BalancerPathRouteSetSpecPathRoutesPathMatchType{}
		}
	default:
		iter.ReportError("decode BalancerPathRouteSetSpecPathRoutesPathMatchType", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BalancerRuleSetSpecItemsRedirectURICodec struct {
}

func (BalancerRuleSetSpecItemsRedirectURICodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BalancerRuleSetSpecItemsRedirectURI)(ptr) == nil
}

func (BalancerRuleSetSpecItemsRedirectURICodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BalancerRuleSetSpecItemsRedirectURI)(ptr)
	var objs []BalancerRuleSetSpecItemsRedirectURI
	if obj != nil {
		objs = []BalancerRuleSetSpecItemsRedirectURI{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerRuleSetSpecItemsRedirectURI{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BalancerRuleSetSpecItemsRedirectURICodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BalancerRuleSetSpecItemsRedirectURI)(ptr) = BalancerRuleSetSpecItemsRedirectURI{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BalancerRuleSetSpecItemsRedirectURI

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerRuleSetSpecItemsRedirectURI{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BalancerRuleSetSpecItemsRedirectURI)(ptr) = objs[0]
			} else {
				*(*BalancerRuleSetSpecItemsRedirectURI)(ptr) = BalancerRuleSetSpecItemsRedirectURI{}
			}
		} else {
			*(*BalancerRuleSetSpecItemsRedirectURI)(ptr) = BalancerRuleSetSpecItemsRedirectURI{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BalancerRuleSetSpecItemsRedirectURI

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BalancerRuleSetSpecItemsRedirectURI{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BalancerRuleSetSpecItemsRedirectURI)(ptr) = obj
		} else {
			*(*BalancerRuleSetSpecItemsRedirectURI)(ptr) = BalancerRuleSetSpecItemsRedirectURI{}
		}
	default:
		iter.ReportError("decode BalancerRuleSetSpecItemsRedirectURI", "unexpected JSON type")
	}
}
