/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecHealthChecker{}).Type1()):                           BackendSetSpecHealthCheckerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecLbCookieSessionPersistenceConfiguration{}).Type1()): BackendSetSpecLbCookieSessionPersistenceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecSessionPersistenceConfiguration{}).Type1()):         BackendSetSpecSessionPersistenceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecSslConfiguration{}).Type1()):                        BackendSetSpecSslConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecConnectionConfiguration{}).Type1()):                   ListenerSpecConnectionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecSslConfiguration{}).Type1()):                          ListenerSpecSslConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecIpAddressDetailsReservedIP{}).Type1()):            LoadBalancerSpecIpAddressDetailsReservedIPCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecShapeDetails{}).Type1()):                          LoadBalancerSpecShapeDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PathRouteSetSpecPathRoutesPathMatchType{}).Type1()):               PathRouteSetSpecPathRoutesPathMatchTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSetSpecItemsRedirectURI{}).Type1()):                           RuleSetSpecItemsRedirectURICodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecHealthChecker{}).Type1()):                           BackendSetSpecHealthCheckerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecLbCookieSessionPersistenceConfiguration{}).Type1()): BackendSetSpecLbCookieSessionPersistenceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecSessionPersistenceConfiguration{}).Type1()):         BackendSetSpecSessionPersistenceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecSslConfiguration{}).Type1()):                        BackendSetSpecSslConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecConnectionConfiguration{}).Type1()):                   ListenerSpecConnectionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecSslConfiguration{}).Type1()):                          ListenerSpecSslConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecIpAddressDetailsReservedIP{}).Type1()):            LoadBalancerSpecIpAddressDetailsReservedIPCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecShapeDetails{}).Type1()):                          LoadBalancerSpecShapeDetailsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PathRouteSetSpecPathRoutesPathMatchType{}).Type1()):               PathRouteSetSpecPathRoutesPathMatchTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSetSpecItemsRedirectURI{}).Type1()):                           RuleSetSpecItemsRedirectURICodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type BackendSetSpecHealthCheckerCodec struct {
}

func (BackendSetSpecHealthCheckerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendSetSpecHealthChecker)(ptr) == nil
}

func (BackendSetSpecHealthCheckerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendSetSpecHealthChecker)(ptr)
	var objs []BackendSetSpecHealthChecker
	if obj != nil {
		objs = []BackendSetSpecHealthChecker{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecHealthChecker{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendSetSpecHealthCheckerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendSetSpecHealthChecker)(ptr) = BackendSetSpecHealthChecker{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendSetSpecHealthChecker

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecHealthChecker{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendSetSpecHealthChecker)(ptr) = objs[0]
			} else {
				*(*BackendSetSpecHealthChecker)(ptr) = BackendSetSpecHealthChecker{}
			}
		} else {
			*(*BackendSetSpecHealthChecker)(ptr) = BackendSetSpecHealthChecker{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendSetSpecHealthChecker

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecHealthChecker{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendSetSpecHealthChecker)(ptr) = obj
		} else {
			*(*BackendSetSpecHealthChecker)(ptr) = BackendSetSpecHealthChecker{}
		}
	default:
		iter.ReportError("decode BackendSetSpecHealthChecker", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendSetSpecLbCookieSessionPersistenceConfigurationCodec struct {
}

func (BackendSetSpecLbCookieSessionPersistenceConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendSetSpecLbCookieSessionPersistenceConfiguration)(ptr) == nil
}

func (BackendSetSpecLbCookieSessionPersistenceConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendSetSpecLbCookieSessionPersistenceConfiguration)(ptr)
	var objs []BackendSetSpecLbCookieSessionPersistenceConfiguration
	if obj != nil {
		objs = []BackendSetSpecLbCookieSessionPersistenceConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecLbCookieSessionPersistenceConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendSetSpecLbCookieSessionPersistenceConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendSetSpecLbCookieSessionPersistenceConfiguration)(ptr) = BackendSetSpecLbCookieSessionPersistenceConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendSetSpecLbCookieSessionPersistenceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecLbCookieSessionPersistenceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendSetSpecLbCookieSessionPersistenceConfiguration)(ptr) = objs[0]
			} else {
				*(*BackendSetSpecLbCookieSessionPersistenceConfiguration)(ptr) = BackendSetSpecLbCookieSessionPersistenceConfiguration{}
			}
		} else {
			*(*BackendSetSpecLbCookieSessionPersistenceConfiguration)(ptr) = BackendSetSpecLbCookieSessionPersistenceConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendSetSpecLbCookieSessionPersistenceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecLbCookieSessionPersistenceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendSetSpecLbCookieSessionPersistenceConfiguration)(ptr) = obj
		} else {
			*(*BackendSetSpecLbCookieSessionPersistenceConfiguration)(ptr) = BackendSetSpecLbCookieSessionPersistenceConfiguration{}
		}
	default:
		iter.ReportError("decode BackendSetSpecLbCookieSessionPersistenceConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendSetSpecSessionPersistenceConfigurationCodec struct {
}

func (BackendSetSpecSessionPersistenceConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendSetSpecSessionPersistenceConfiguration)(ptr) == nil
}

func (BackendSetSpecSessionPersistenceConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendSetSpecSessionPersistenceConfiguration)(ptr)
	var objs []BackendSetSpecSessionPersistenceConfiguration
	if obj != nil {
		objs = []BackendSetSpecSessionPersistenceConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecSessionPersistenceConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendSetSpecSessionPersistenceConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendSetSpecSessionPersistenceConfiguration)(ptr) = BackendSetSpecSessionPersistenceConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendSetSpecSessionPersistenceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecSessionPersistenceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendSetSpecSessionPersistenceConfiguration)(ptr) = objs[0]
			} else {
				*(*BackendSetSpecSessionPersistenceConfiguration)(ptr) = BackendSetSpecSessionPersistenceConfiguration{}
			}
		} else {
			*(*BackendSetSpecSessionPersistenceConfiguration)(ptr) = BackendSetSpecSessionPersistenceConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendSetSpecSessionPersistenceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecSessionPersistenceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendSetSpecSessionPersistenceConfiguration)(ptr) = obj
		} else {
			*(*BackendSetSpecSessionPersistenceConfiguration)(ptr) = BackendSetSpecSessionPersistenceConfiguration{}
		}
	default:
		iter.ReportError("decode BackendSetSpecSessionPersistenceConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendSetSpecSslConfigurationCodec struct {
}

func (BackendSetSpecSslConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendSetSpecSslConfiguration)(ptr) == nil
}

func (BackendSetSpecSslConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendSetSpecSslConfiguration)(ptr)
	var objs []BackendSetSpecSslConfiguration
	if obj != nil {
		objs = []BackendSetSpecSslConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecSslConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendSetSpecSslConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendSetSpecSslConfiguration)(ptr) = BackendSetSpecSslConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendSetSpecSslConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecSslConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendSetSpecSslConfiguration)(ptr) = objs[0]
			} else {
				*(*BackendSetSpecSslConfiguration)(ptr) = BackendSetSpecSslConfiguration{}
			}
		} else {
			*(*BackendSetSpecSslConfiguration)(ptr) = BackendSetSpecSslConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendSetSpecSslConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSetSpecSslConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendSetSpecSslConfiguration)(ptr) = obj
		} else {
			*(*BackendSetSpecSslConfiguration)(ptr) = BackendSetSpecSslConfiguration{}
		}
	default:
		iter.ReportError("decode BackendSetSpecSslConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerSpecConnectionConfigurationCodec struct {
}

func (ListenerSpecConnectionConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerSpecConnectionConfiguration)(ptr) == nil
}

func (ListenerSpecConnectionConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerSpecConnectionConfiguration)(ptr)
	var objs []ListenerSpecConnectionConfiguration
	if obj != nil {
		objs = []ListenerSpecConnectionConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecConnectionConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerSpecConnectionConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerSpecConnectionConfiguration)(ptr) = ListenerSpecConnectionConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerSpecConnectionConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecConnectionConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerSpecConnectionConfiguration)(ptr) = objs[0]
			} else {
				*(*ListenerSpecConnectionConfiguration)(ptr) = ListenerSpecConnectionConfiguration{}
			}
		} else {
			*(*ListenerSpecConnectionConfiguration)(ptr) = ListenerSpecConnectionConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ListenerSpecConnectionConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecConnectionConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ListenerSpecConnectionConfiguration)(ptr) = obj
		} else {
			*(*ListenerSpecConnectionConfiguration)(ptr) = ListenerSpecConnectionConfiguration{}
		}
	default:
		iter.ReportError("decode ListenerSpecConnectionConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerSpecSslConfigurationCodec struct {
}

func (ListenerSpecSslConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerSpecSslConfiguration)(ptr) == nil
}

func (ListenerSpecSslConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerSpecSslConfiguration)(ptr)
	var objs []ListenerSpecSslConfiguration
	if obj != nil {
		objs = []ListenerSpecSslConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecSslConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerSpecSslConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerSpecSslConfiguration)(ptr) = ListenerSpecSslConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerSpecSslConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecSslConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerSpecSslConfiguration)(ptr) = objs[0]
			} else {
				*(*ListenerSpecSslConfiguration)(ptr) = ListenerSpecSslConfiguration{}
			}
		} else {
			*(*ListenerSpecSslConfiguration)(ptr) = ListenerSpecSslConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ListenerSpecSslConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecSslConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ListenerSpecSslConfiguration)(ptr) = obj
		} else {
			*(*ListenerSpecSslConfiguration)(ptr) = ListenerSpecSslConfiguration{}
		}
	default:
		iter.ReportError("decode ListenerSpecSslConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LoadBalancerSpecIpAddressDetailsReservedIPCodec struct {
}

func (LoadBalancerSpecIpAddressDetailsReservedIPCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LoadBalancerSpecIpAddressDetailsReservedIP)(ptr) == nil
}

func (LoadBalancerSpecIpAddressDetailsReservedIPCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LoadBalancerSpecIpAddressDetailsReservedIP)(ptr)
	var objs []LoadBalancerSpecIpAddressDetailsReservedIP
	if obj != nil {
		objs = []LoadBalancerSpecIpAddressDetailsReservedIP{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecIpAddressDetailsReservedIP{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LoadBalancerSpecIpAddressDetailsReservedIPCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LoadBalancerSpecIpAddressDetailsReservedIP)(ptr) = LoadBalancerSpecIpAddressDetailsReservedIP{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LoadBalancerSpecIpAddressDetailsReservedIP

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecIpAddressDetailsReservedIP{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LoadBalancerSpecIpAddressDetailsReservedIP)(ptr) = objs[0]
			} else {
				*(*LoadBalancerSpecIpAddressDetailsReservedIP)(ptr) = LoadBalancerSpecIpAddressDetailsReservedIP{}
			}
		} else {
			*(*LoadBalancerSpecIpAddressDetailsReservedIP)(ptr) = LoadBalancerSpecIpAddressDetailsReservedIP{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj LoadBalancerSpecIpAddressDetailsReservedIP

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecIpAddressDetailsReservedIP{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*LoadBalancerSpecIpAddressDetailsReservedIP)(ptr) = obj
		} else {
			*(*LoadBalancerSpecIpAddressDetailsReservedIP)(ptr) = LoadBalancerSpecIpAddressDetailsReservedIP{}
		}
	default:
		iter.ReportError("decode LoadBalancerSpecIpAddressDetailsReservedIP", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LoadBalancerSpecShapeDetailsCodec struct {
}

func (LoadBalancerSpecShapeDetailsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LoadBalancerSpecShapeDetails)(ptr) == nil
}

func (LoadBalancerSpecShapeDetailsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LoadBalancerSpecShapeDetails)(ptr)
	var objs []LoadBalancerSpecShapeDetails
	if obj != nil {
		objs = []LoadBalancerSpecShapeDetails{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecShapeDetails{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LoadBalancerSpecShapeDetailsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LoadBalancerSpecShapeDetails)(ptr) = LoadBalancerSpecShapeDetails{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LoadBalancerSpecShapeDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecShapeDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LoadBalancerSpecShapeDetails)(ptr) = objs[0]
			} else {
				*(*LoadBalancerSpecShapeDetails)(ptr) = LoadBalancerSpecShapeDetails{}
			}
		} else {
			*(*LoadBalancerSpecShapeDetails)(ptr) = LoadBalancerSpecShapeDetails{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj LoadBalancerSpecShapeDetails

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecShapeDetails{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*LoadBalancerSpecShapeDetails)(ptr) = obj
		} else {
			*(*LoadBalancerSpecShapeDetails)(ptr) = LoadBalancerSpecShapeDetails{}
		}
	default:
		iter.ReportError("decode LoadBalancerSpecShapeDetails", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PathRouteSetSpecPathRoutesPathMatchTypeCodec struct {
}

func (PathRouteSetSpecPathRoutesPathMatchTypeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PathRouteSetSpecPathRoutesPathMatchType)(ptr) == nil
}

func (PathRouteSetSpecPathRoutesPathMatchTypeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PathRouteSetSpecPathRoutesPathMatchType)(ptr)
	var objs []PathRouteSetSpecPathRoutesPathMatchType
	if obj != nil {
		objs = []PathRouteSetSpecPathRoutesPathMatchType{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PathRouteSetSpecPathRoutesPathMatchType{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PathRouteSetSpecPathRoutesPathMatchTypeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PathRouteSetSpecPathRoutesPathMatchType)(ptr) = PathRouteSetSpecPathRoutesPathMatchType{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PathRouteSetSpecPathRoutesPathMatchType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PathRouteSetSpecPathRoutesPathMatchType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PathRouteSetSpecPathRoutesPathMatchType)(ptr) = objs[0]
			} else {
				*(*PathRouteSetSpecPathRoutesPathMatchType)(ptr) = PathRouteSetSpecPathRoutesPathMatchType{}
			}
		} else {
			*(*PathRouteSetSpecPathRoutesPathMatchType)(ptr) = PathRouteSetSpecPathRoutesPathMatchType{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj PathRouteSetSpecPathRoutesPathMatchType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PathRouteSetSpecPathRoutesPathMatchType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*PathRouteSetSpecPathRoutesPathMatchType)(ptr) = obj
		} else {
			*(*PathRouteSetSpecPathRoutesPathMatchType)(ptr) = PathRouteSetSpecPathRoutesPathMatchType{}
		}
	default:
		iter.ReportError("decode PathRouteSetSpecPathRoutesPathMatchType", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleSetSpecItemsRedirectURICodec struct {
}

func (RuleSetSpecItemsRedirectURICodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleSetSpecItemsRedirectURI)(ptr) == nil
}

func (RuleSetSpecItemsRedirectURICodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleSetSpecItemsRedirectURI)(ptr)
	var objs []RuleSetSpecItemsRedirectURI
	if obj != nil {
		objs = []RuleSetSpecItemsRedirectURI{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSetSpecItemsRedirectURI{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleSetSpecItemsRedirectURICodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleSetSpecItemsRedirectURI)(ptr) = RuleSetSpecItemsRedirectURI{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleSetSpecItemsRedirectURI

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSetSpecItemsRedirectURI{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleSetSpecItemsRedirectURI)(ptr) = objs[0]
			} else {
				*(*RuleSetSpecItemsRedirectURI)(ptr) = RuleSetSpecItemsRedirectURI{}
			}
		} else {
			*(*RuleSetSpecItemsRedirectURI)(ptr) = RuleSetSpecItemsRedirectURI{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RuleSetSpecItemsRedirectURI

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSetSpecItemsRedirectURI{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RuleSetSpecItemsRedirectURI)(ptr) = obj
		} else {
			*(*RuleSetSpecItemsRedirectURI)(ptr) = RuleSetSpecItemsRedirectURI{}
		}
	default:
		iter.ReportError("decode RuleSetSpecItemsRedirectURI", "unexpected JSON type")
	}
}
