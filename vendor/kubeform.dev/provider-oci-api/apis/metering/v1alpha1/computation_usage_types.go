/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type ComputationUsage struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ComputationUsageSpec   `json:"spec,omitempty"`
	Status            ComputationUsageStatus `json:"status,omitempty"`
}

type ComputationUsageSpecForecast struct {
	// +optional
	ForecastType      *string `json:"forecastType,omitempty" tf:"forecast_type"`
	TimeForecastEnded *string `json:"timeForecastEnded" tf:"time_forecast_ended"`
	// +optional
	TimeForecastStarted *string `json:"timeForecastStarted,omitempty" tf:"time_forecast_started"`
}

type ComputationUsageSpecGroupByTag struct {
	// +optional
	Key *string `json:"key,omitempty" tf:"key"`
	// +optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace"`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ComputationUsageSpecItemsTags struct {
	// +optional
	Key *string `json:"key,omitempty" tf:"key"`
	// +optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace"`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ComputationUsageSpecItems struct {
	// +optional
	Ad *string `json:"ad,omitempty" tf:"ad"`
	// +optional
	CompartmentID *string `json:"compartmentID,omitempty" tf:"compartment_id"`
	// +optional
	CompartmentName *string `json:"compartmentName,omitempty" tf:"compartment_name"`
	// +optional
	CompartmentPath *string `json:"compartmentPath,omitempty" tf:"compartment_path"`
	// +optional
	ComputedAmount *float64 `json:"computedAmount,omitempty" tf:"computed_amount"`
	// +optional
	ComputedQuantity *float64 `json:"computedQuantity,omitempty" tf:"computed_quantity"`
	// +optional
	Currency *string `json:"currency,omitempty" tf:"currency"`
	// +optional
	Discount *float64 `json:"discount,omitempty" tf:"discount"`
	// +optional
	IsForecast *bool `json:"isForecast,omitempty" tf:"is_forecast"`
	// +optional
	ListRate *float64 `json:"listRate,omitempty" tf:"list_rate"`
	// +optional
	Overage *string `json:"overage,omitempty" tf:"overage"`
	// +optional
	OveragesFlag *string `json:"overagesFlag,omitempty" tf:"overages_flag"`
	// +optional
	Platform *string `json:"platform,omitempty" tf:"platform"`
	// +optional
	Region *string `json:"region,omitempty" tf:"region"`
	// +optional
	ResourceID *string `json:"resourceID,omitempty" tf:"resource_id"`
	// +optional
	ResourceName *string `json:"resourceName,omitempty" tf:"resource_name"`
	// +optional
	Service *string `json:"service,omitempty" tf:"service"`
	// +optional
	Shape *string `json:"shape,omitempty" tf:"shape"`
	// +optional
	SkuName *string `json:"skuName,omitempty" tf:"sku_name"`
	// +optional
	SkuPartNumber *string `json:"skuPartNumber,omitempty" tf:"sku_part_number"`
	// +optional
	SubscriptionID *string `json:"subscriptionID,omitempty" tf:"subscription_id"`
	// +optional
	Tags []ComputationUsageSpecItemsTags `json:"tags,omitempty" tf:"tags"`
	// +optional
	TenantID *string `json:"tenantID,omitempty" tf:"tenant_id"`
	// +optional
	TenantName *string `json:"tenantName,omitempty" tf:"tenant_name"`
	// +optional
	TimeUsageEnded *string `json:"timeUsageEnded,omitempty" tf:"time_usage_ended"`
	// +optional
	TimeUsageStarted *string `json:"timeUsageStarted,omitempty" tf:"time_usage_started"`
	// +optional
	Unit *string `json:"unit,omitempty" tf:"unit"`
	// +optional
	UnitPrice *float64 `json:"unitPrice,omitempty" tf:"unit_price"`
	// +optional
	Weight *float64 `json:"weight,omitempty" tf:"weight"`
}

type ComputationUsageSpec struct {
	State *ComputationUsageSpecResource `json:"state,omitempty" tf:"-"`

	Resource ComputationUsageSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`
}

type ComputationUsageSpecResource struct {
	Timeouts *base.ResourceTimeout `json:"timeouts,omitempty" tf:"timeouts"`

	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// +optional
	CompartmentDepth *float64 `json:"compartmentDepth,omitempty" tf:"compartment_depth"`
	// +optional
	Filter *string `json:"filter,omitempty" tf:"filter"`
	// +optional
	Forecast    *ComputationUsageSpecForecast `json:"forecast,omitempty" tf:"forecast"`
	Granularity *string                       `json:"granularity" tf:"granularity"`
	// +optional
	GroupBy []string `json:"groupBy,omitempty" tf:"group_by"`
	// +optional
	GroupByTag []ComputationUsageSpecGroupByTag `json:"groupByTag,omitempty" tf:"group_by_tag"`
	// +optional
	IsAggregateByTime *bool `json:"isAggregateByTime,omitempty" tf:"is_aggregate_by_time"`
	// +optional
	Items []ComputationUsageSpecItems `json:"items,omitempty" tf:"items"`
	// +optional
	QueryType        *string `json:"queryType,omitempty" tf:"query_type"`
	TenantID         *string `json:"tenantID" tf:"tenant_id"`
	TimeUsageEnded   *string `json:"timeUsageEnded" tf:"time_usage_ended"`
	TimeUsageStarted *string `json:"timeUsageStarted" tf:"time_usage_started"`
}

type ComputationUsageStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// ComputationUsageList is a list of ComputationUsages
type ComputationUsageList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of ComputationUsage CRD objects
	Items []ComputationUsage `json:"items,omitempty"`
}
