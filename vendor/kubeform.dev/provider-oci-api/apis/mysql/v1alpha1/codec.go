/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ChannelSpecSource{}).Type1()):                               ChannelSpecSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ChannelSpecSourceSslCaCertificate{}).Type1()):               ChannelSpecSourceSslCaCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ChannelSpecTarget{}).Type1()):                               ChannelSpecTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlBackupSpecDbSystemSnapshot{}).Type1()):                 MysqlBackupSpecDbSystemSnapshotCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlBackupSpecDbSystemSnapshotBackupPolicy{}).Type1()):     MysqlBackupSpecDbSystemSnapshotBackupPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlBackupSpecDbSystemSnapshotMaintenance{}).Type1()):      MysqlBackupSpecDbSystemSnapshotMaintenanceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecAnalyticsCluster{}).Type1()):               MysqlDbSystemSpecAnalyticsClusterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecBackupPolicy{}).Type1()):                   MysqlDbSystemSpecBackupPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecChannelsSource{}).Type1()):                 MysqlDbSystemSpecChannelsSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecChannelsSourceSslCaCertificate{}).Type1()): MysqlDbSystemSpecChannelsSourceSslCaCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecChannelsTarget{}).Type1()):                 MysqlDbSystemSpecChannelsTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecCurrentPlacement{}).Type1()):               MysqlDbSystemSpecCurrentPlacementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecHeatWaveCluster{}).Type1()):                MysqlDbSystemSpecHeatWaveClusterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecMaintenance{}).Type1()):                    MysqlDbSystemSpecMaintenanceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecSource{}).Type1()):                         MysqlDbSystemSpecSourceCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ChannelSpecSource{}).Type1()):                               ChannelSpecSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ChannelSpecSourceSslCaCertificate{}).Type1()):               ChannelSpecSourceSslCaCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ChannelSpecTarget{}).Type1()):                               ChannelSpecTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlBackupSpecDbSystemSnapshot{}).Type1()):                 MysqlBackupSpecDbSystemSnapshotCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlBackupSpecDbSystemSnapshotBackupPolicy{}).Type1()):     MysqlBackupSpecDbSystemSnapshotBackupPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlBackupSpecDbSystemSnapshotMaintenance{}).Type1()):      MysqlBackupSpecDbSystemSnapshotMaintenanceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecAnalyticsCluster{}).Type1()):               MysqlDbSystemSpecAnalyticsClusterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecBackupPolicy{}).Type1()):                   MysqlDbSystemSpecBackupPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecChannelsSource{}).Type1()):                 MysqlDbSystemSpecChannelsSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecChannelsSourceSslCaCertificate{}).Type1()): MysqlDbSystemSpecChannelsSourceSslCaCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecChannelsTarget{}).Type1()):                 MysqlDbSystemSpecChannelsTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecCurrentPlacement{}).Type1()):               MysqlDbSystemSpecCurrentPlacementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecHeatWaveCluster{}).Type1()):                MysqlDbSystemSpecHeatWaveClusterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecMaintenance{}).Type1()):                    MysqlDbSystemSpecMaintenanceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecSource{}).Type1()):                         MysqlDbSystemSpecSourceCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ChannelSpecSourceCodec struct {
}

func (ChannelSpecSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ChannelSpecSource)(ptr) == nil
}

func (ChannelSpecSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ChannelSpecSource)(ptr)
	var objs []ChannelSpecSource
	if obj != nil {
		objs = []ChannelSpecSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ChannelSpecSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ChannelSpecSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ChannelSpecSource)(ptr) = ChannelSpecSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ChannelSpecSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ChannelSpecSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ChannelSpecSource)(ptr) = objs[0]
			} else {
				*(*ChannelSpecSource)(ptr) = ChannelSpecSource{}
			}
		} else {
			*(*ChannelSpecSource)(ptr) = ChannelSpecSource{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ChannelSpecSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ChannelSpecSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ChannelSpecSource)(ptr) = obj
		} else {
			*(*ChannelSpecSource)(ptr) = ChannelSpecSource{}
		}
	default:
		iter.ReportError("decode ChannelSpecSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ChannelSpecSourceSslCaCertificateCodec struct {
}

func (ChannelSpecSourceSslCaCertificateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ChannelSpecSourceSslCaCertificate)(ptr) == nil
}

func (ChannelSpecSourceSslCaCertificateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ChannelSpecSourceSslCaCertificate)(ptr)
	var objs []ChannelSpecSourceSslCaCertificate
	if obj != nil {
		objs = []ChannelSpecSourceSslCaCertificate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ChannelSpecSourceSslCaCertificate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ChannelSpecSourceSslCaCertificateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ChannelSpecSourceSslCaCertificate)(ptr) = ChannelSpecSourceSslCaCertificate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ChannelSpecSourceSslCaCertificate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ChannelSpecSourceSslCaCertificate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ChannelSpecSourceSslCaCertificate)(ptr) = objs[0]
			} else {
				*(*ChannelSpecSourceSslCaCertificate)(ptr) = ChannelSpecSourceSslCaCertificate{}
			}
		} else {
			*(*ChannelSpecSourceSslCaCertificate)(ptr) = ChannelSpecSourceSslCaCertificate{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ChannelSpecSourceSslCaCertificate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ChannelSpecSourceSslCaCertificate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ChannelSpecSourceSslCaCertificate)(ptr) = obj
		} else {
			*(*ChannelSpecSourceSslCaCertificate)(ptr) = ChannelSpecSourceSslCaCertificate{}
		}
	default:
		iter.ReportError("decode ChannelSpecSourceSslCaCertificate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ChannelSpecTargetCodec struct {
}

func (ChannelSpecTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ChannelSpecTarget)(ptr) == nil
}

func (ChannelSpecTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ChannelSpecTarget)(ptr)
	var objs []ChannelSpecTarget
	if obj != nil {
		objs = []ChannelSpecTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ChannelSpecTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ChannelSpecTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ChannelSpecTarget)(ptr) = ChannelSpecTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ChannelSpecTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ChannelSpecTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ChannelSpecTarget)(ptr) = objs[0]
			} else {
				*(*ChannelSpecTarget)(ptr) = ChannelSpecTarget{}
			}
		} else {
			*(*ChannelSpecTarget)(ptr) = ChannelSpecTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ChannelSpecTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ChannelSpecTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ChannelSpecTarget)(ptr) = obj
		} else {
			*(*ChannelSpecTarget)(ptr) = ChannelSpecTarget{}
		}
	default:
		iter.ReportError("decode ChannelSpecTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MysqlBackupSpecDbSystemSnapshotCodec struct {
}

func (MysqlBackupSpecDbSystemSnapshotCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MysqlBackupSpecDbSystemSnapshot)(ptr) == nil
}

func (MysqlBackupSpecDbSystemSnapshotCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MysqlBackupSpecDbSystemSnapshot)(ptr)
	var objs []MysqlBackupSpecDbSystemSnapshot
	if obj != nil {
		objs = []MysqlBackupSpecDbSystemSnapshot{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlBackupSpecDbSystemSnapshot{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MysqlBackupSpecDbSystemSnapshotCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MysqlBackupSpecDbSystemSnapshot)(ptr) = MysqlBackupSpecDbSystemSnapshot{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MysqlBackupSpecDbSystemSnapshot

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlBackupSpecDbSystemSnapshot{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MysqlBackupSpecDbSystemSnapshot)(ptr) = objs[0]
			} else {
				*(*MysqlBackupSpecDbSystemSnapshot)(ptr) = MysqlBackupSpecDbSystemSnapshot{}
			}
		} else {
			*(*MysqlBackupSpecDbSystemSnapshot)(ptr) = MysqlBackupSpecDbSystemSnapshot{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MysqlBackupSpecDbSystemSnapshot

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlBackupSpecDbSystemSnapshot{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MysqlBackupSpecDbSystemSnapshot)(ptr) = obj
		} else {
			*(*MysqlBackupSpecDbSystemSnapshot)(ptr) = MysqlBackupSpecDbSystemSnapshot{}
		}
	default:
		iter.ReportError("decode MysqlBackupSpecDbSystemSnapshot", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MysqlBackupSpecDbSystemSnapshotBackupPolicyCodec struct {
}

func (MysqlBackupSpecDbSystemSnapshotBackupPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MysqlBackupSpecDbSystemSnapshotBackupPolicy)(ptr) == nil
}

func (MysqlBackupSpecDbSystemSnapshotBackupPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MysqlBackupSpecDbSystemSnapshotBackupPolicy)(ptr)
	var objs []MysqlBackupSpecDbSystemSnapshotBackupPolicy
	if obj != nil {
		objs = []MysqlBackupSpecDbSystemSnapshotBackupPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlBackupSpecDbSystemSnapshotBackupPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MysqlBackupSpecDbSystemSnapshotBackupPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MysqlBackupSpecDbSystemSnapshotBackupPolicy)(ptr) = MysqlBackupSpecDbSystemSnapshotBackupPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MysqlBackupSpecDbSystemSnapshotBackupPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlBackupSpecDbSystemSnapshotBackupPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MysqlBackupSpecDbSystemSnapshotBackupPolicy)(ptr) = objs[0]
			} else {
				*(*MysqlBackupSpecDbSystemSnapshotBackupPolicy)(ptr) = MysqlBackupSpecDbSystemSnapshotBackupPolicy{}
			}
		} else {
			*(*MysqlBackupSpecDbSystemSnapshotBackupPolicy)(ptr) = MysqlBackupSpecDbSystemSnapshotBackupPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MysqlBackupSpecDbSystemSnapshotBackupPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlBackupSpecDbSystemSnapshotBackupPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MysqlBackupSpecDbSystemSnapshotBackupPolicy)(ptr) = obj
		} else {
			*(*MysqlBackupSpecDbSystemSnapshotBackupPolicy)(ptr) = MysqlBackupSpecDbSystemSnapshotBackupPolicy{}
		}
	default:
		iter.ReportError("decode MysqlBackupSpecDbSystemSnapshotBackupPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MysqlBackupSpecDbSystemSnapshotMaintenanceCodec struct {
}

func (MysqlBackupSpecDbSystemSnapshotMaintenanceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MysqlBackupSpecDbSystemSnapshotMaintenance)(ptr) == nil
}

func (MysqlBackupSpecDbSystemSnapshotMaintenanceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MysqlBackupSpecDbSystemSnapshotMaintenance)(ptr)
	var objs []MysqlBackupSpecDbSystemSnapshotMaintenance
	if obj != nil {
		objs = []MysqlBackupSpecDbSystemSnapshotMaintenance{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlBackupSpecDbSystemSnapshotMaintenance{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MysqlBackupSpecDbSystemSnapshotMaintenanceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MysqlBackupSpecDbSystemSnapshotMaintenance)(ptr) = MysqlBackupSpecDbSystemSnapshotMaintenance{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MysqlBackupSpecDbSystemSnapshotMaintenance

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlBackupSpecDbSystemSnapshotMaintenance{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MysqlBackupSpecDbSystemSnapshotMaintenance)(ptr) = objs[0]
			} else {
				*(*MysqlBackupSpecDbSystemSnapshotMaintenance)(ptr) = MysqlBackupSpecDbSystemSnapshotMaintenance{}
			}
		} else {
			*(*MysqlBackupSpecDbSystemSnapshotMaintenance)(ptr) = MysqlBackupSpecDbSystemSnapshotMaintenance{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MysqlBackupSpecDbSystemSnapshotMaintenance

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlBackupSpecDbSystemSnapshotMaintenance{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MysqlBackupSpecDbSystemSnapshotMaintenance)(ptr) = obj
		} else {
			*(*MysqlBackupSpecDbSystemSnapshotMaintenance)(ptr) = MysqlBackupSpecDbSystemSnapshotMaintenance{}
		}
	default:
		iter.ReportError("decode MysqlBackupSpecDbSystemSnapshotMaintenance", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MysqlDbSystemSpecAnalyticsClusterCodec struct {
}

func (MysqlDbSystemSpecAnalyticsClusterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MysqlDbSystemSpecAnalyticsCluster)(ptr) == nil
}

func (MysqlDbSystemSpecAnalyticsClusterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MysqlDbSystemSpecAnalyticsCluster)(ptr)
	var objs []MysqlDbSystemSpecAnalyticsCluster
	if obj != nil {
		objs = []MysqlDbSystemSpecAnalyticsCluster{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecAnalyticsCluster{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MysqlDbSystemSpecAnalyticsClusterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MysqlDbSystemSpecAnalyticsCluster)(ptr) = MysqlDbSystemSpecAnalyticsCluster{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MysqlDbSystemSpecAnalyticsCluster

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecAnalyticsCluster{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MysqlDbSystemSpecAnalyticsCluster)(ptr) = objs[0]
			} else {
				*(*MysqlDbSystemSpecAnalyticsCluster)(ptr) = MysqlDbSystemSpecAnalyticsCluster{}
			}
		} else {
			*(*MysqlDbSystemSpecAnalyticsCluster)(ptr) = MysqlDbSystemSpecAnalyticsCluster{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MysqlDbSystemSpecAnalyticsCluster

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecAnalyticsCluster{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MysqlDbSystemSpecAnalyticsCluster)(ptr) = obj
		} else {
			*(*MysqlDbSystemSpecAnalyticsCluster)(ptr) = MysqlDbSystemSpecAnalyticsCluster{}
		}
	default:
		iter.ReportError("decode MysqlDbSystemSpecAnalyticsCluster", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MysqlDbSystemSpecBackupPolicyCodec struct {
}

func (MysqlDbSystemSpecBackupPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MysqlDbSystemSpecBackupPolicy)(ptr) == nil
}

func (MysqlDbSystemSpecBackupPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MysqlDbSystemSpecBackupPolicy)(ptr)
	var objs []MysqlDbSystemSpecBackupPolicy
	if obj != nil {
		objs = []MysqlDbSystemSpecBackupPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecBackupPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MysqlDbSystemSpecBackupPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MysqlDbSystemSpecBackupPolicy)(ptr) = MysqlDbSystemSpecBackupPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MysqlDbSystemSpecBackupPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecBackupPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MysqlDbSystemSpecBackupPolicy)(ptr) = objs[0]
			} else {
				*(*MysqlDbSystemSpecBackupPolicy)(ptr) = MysqlDbSystemSpecBackupPolicy{}
			}
		} else {
			*(*MysqlDbSystemSpecBackupPolicy)(ptr) = MysqlDbSystemSpecBackupPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MysqlDbSystemSpecBackupPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecBackupPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MysqlDbSystemSpecBackupPolicy)(ptr) = obj
		} else {
			*(*MysqlDbSystemSpecBackupPolicy)(ptr) = MysqlDbSystemSpecBackupPolicy{}
		}
	default:
		iter.ReportError("decode MysqlDbSystemSpecBackupPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MysqlDbSystemSpecChannelsSourceCodec struct {
}

func (MysqlDbSystemSpecChannelsSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MysqlDbSystemSpecChannelsSource)(ptr) == nil
}

func (MysqlDbSystemSpecChannelsSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MysqlDbSystemSpecChannelsSource)(ptr)
	var objs []MysqlDbSystemSpecChannelsSource
	if obj != nil {
		objs = []MysqlDbSystemSpecChannelsSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecChannelsSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MysqlDbSystemSpecChannelsSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MysqlDbSystemSpecChannelsSource)(ptr) = MysqlDbSystemSpecChannelsSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MysqlDbSystemSpecChannelsSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecChannelsSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MysqlDbSystemSpecChannelsSource)(ptr) = objs[0]
			} else {
				*(*MysqlDbSystemSpecChannelsSource)(ptr) = MysqlDbSystemSpecChannelsSource{}
			}
		} else {
			*(*MysqlDbSystemSpecChannelsSource)(ptr) = MysqlDbSystemSpecChannelsSource{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MysqlDbSystemSpecChannelsSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecChannelsSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MysqlDbSystemSpecChannelsSource)(ptr) = obj
		} else {
			*(*MysqlDbSystemSpecChannelsSource)(ptr) = MysqlDbSystemSpecChannelsSource{}
		}
	default:
		iter.ReportError("decode MysqlDbSystemSpecChannelsSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MysqlDbSystemSpecChannelsSourceSslCaCertificateCodec struct {
}

func (MysqlDbSystemSpecChannelsSourceSslCaCertificateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MysqlDbSystemSpecChannelsSourceSslCaCertificate)(ptr) == nil
}

func (MysqlDbSystemSpecChannelsSourceSslCaCertificateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MysqlDbSystemSpecChannelsSourceSslCaCertificate)(ptr)
	var objs []MysqlDbSystemSpecChannelsSourceSslCaCertificate
	if obj != nil {
		objs = []MysqlDbSystemSpecChannelsSourceSslCaCertificate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecChannelsSourceSslCaCertificate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MysqlDbSystemSpecChannelsSourceSslCaCertificateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MysqlDbSystemSpecChannelsSourceSslCaCertificate)(ptr) = MysqlDbSystemSpecChannelsSourceSslCaCertificate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MysqlDbSystemSpecChannelsSourceSslCaCertificate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecChannelsSourceSslCaCertificate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MysqlDbSystemSpecChannelsSourceSslCaCertificate)(ptr) = objs[0]
			} else {
				*(*MysqlDbSystemSpecChannelsSourceSslCaCertificate)(ptr) = MysqlDbSystemSpecChannelsSourceSslCaCertificate{}
			}
		} else {
			*(*MysqlDbSystemSpecChannelsSourceSslCaCertificate)(ptr) = MysqlDbSystemSpecChannelsSourceSslCaCertificate{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MysqlDbSystemSpecChannelsSourceSslCaCertificate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecChannelsSourceSslCaCertificate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MysqlDbSystemSpecChannelsSourceSslCaCertificate)(ptr) = obj
		} else {
			*(*MysqlDbSystemSpecChannelsSourceSslCaCertificate)(ptr) = MysqlDbSystemSpecChannelsSourceSslCaCertificate{}
		}
	default:
		iter.ReportError("decode MysqlDbSystemSpecChannelsSourceSslCaCertificate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MysqlDbSystemSpecChannelsTargetCodec struct {
}

func (MysqlDbSystemSpecChannelsTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MysqlDbSystemSpecChannelsTarget)(ptr) == nil
}

func (MysqlDbSystemSpecChannelsTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MysqlDbSystemSpecChannelsTarget)(ptr)
	var objs []MysqlDbSystemSpecChannelsTarget
	if obj != nil {
		objs = []MysqlDbSystemSpecChannelsTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecChannelsTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MysqlDbSystemSpecChannelsTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MysqlDbSystemSpecChannelsTarget)(ptr) = MysqlDbSystemSpecChannelsTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MysqlDbSystemSpecChannelsTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecChannelsTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MysqlDbSystemSpecChannelsTarget)(ptr) = objs[0]
			} else {
				*(*MysqlDbSystemSpecChannelsTarget)(ptr) = MysqlDbSystemSpecChannelsTarget{}
			}
		} else {
			*(*MysqlDbSystemSpecChannelsTarget)(ptr) = MysqlDbSystemSpecChannelsTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MysqlDbSystemSpecChannelsTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecChannelsTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MysqlDbSystemSpecChannelsTarget)(ptr) = obj
		} else {
			*(*MysqlDbSystemSpecChannelsTarget)(ptr) = MysqlDbSystemSpecChannelsTarget{}
		}
	default:
		iter.ReportError("decode MysqlDbSystemSpecChannelsTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MysqlDbSystemSpecCurrentPlacementCodec struct {
}

func (MysqlDbSystemSpecCurrentPlacementCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MysqlDbSystemSpecCurrentPlacement)(ptr) == nil
}

func (MysqlDbSystemSpecCurrentPlacementCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MysqlDbSystemSpecCurrentPlacement)(ptr)
	var objs []MysqlDbSystemSpecCurrentPlacement
	if obj != nil {
		objs = []MysqlDbSystemSpecCurrentPlacement{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecCurrentPlacement{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MysqlDbSystemSpecCurrentPlacementCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MysqlDbSystemSpecCurrentPlacement)(ptr) = MysqlDbSystemSpecCurrentPlacement{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MysqlDbSystemSpecCurrentPlacement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecCurrentPlacement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MysqlDbSystemSpecCurrentPlacement)(ptr) = objs[0]
			} else {
				*(*MysqlDbSystemSpecCurrentPlacement)(ptr) = MysqlDbSystemSpecCurrentPlacement{}
			}
		} else {
			*(*MysqlDbSystemSpecCurrentPlacement)(ptr) = MysqlDbSystemSpecCurrentPlacement{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MysqlDbSystemSpecCurrentPlacement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecCurrentPlacement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MysqlDbSystemSpecCurrentPlacement)(ptr) = obj
		} else {
			*(*MysqlDbSystemSpecCurrentPlacement)(ptr) = MysqlDbSystemSpecCurrentPlacement{}
		}
	default:
		iter.ReportError("decode MysqlDbSystemSpecCurrentPlacement", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MysqlDbSystemSpecHeatWaveClusterCodec struct {
}

func (MysqlDbSystemSpecHeatWaveClusterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MysqlDbSystemSpecHeatWaveCluster)(ptr) == nil
}

func (MysqlDbSystemSpecHeatWaveClusterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MysqlDbSystemSpecHeatWaveCluster)(ptr)
	var objs []MysqlDbSystemSpecHeatWaveCluster
	if obj != nil {
		objs = []MysqlDbSystemSpecHeatWaveCluster{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecHeatWaveCluster{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MysqlDbSystemSpecHeatWaveClusterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MysqlDbSystemSpecHeatWaveCluster)(ptr) = MysqlDbSystemSpecHeatWaveCluster{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MysqlDbSystemSpecHeatWaveCluster

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecHeatWaveCluster{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MysqlDbSystemSpecHeatWaveCluster)(ptr) = objs[0]
			} else {
				*(*MysqlDbSystemSpecHeatWaveCluster)(ptr) = MysqlDbSystemSpecHeatWaveCluster{}
			}
		} else {
			*(*MysqlDbSystemSpecHeatWaveCluster)(ptr) = MysqlDbSystemSpecHeatWaveCluster{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MysqlDbSystemSpecHeatWaveCluster

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecHeatWaveCluster{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MysqlDbSystemSpecHeatWaveCluster)(ptr) = obj
		} else {
			*(*MysqlDbSystemSpecHeatWaveCluster)(ptr) = MysqlDbSystemSpecHeatWaveCluster{}
		}
	default:
		iter.ReportError("decode MysqlDbSystemSpecHeatWaveCluster", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MysqlDbSystemSpecMaintenanceCodec struct {
}

func (MysqlDbSystemSpecMaintenanceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MysqlDbSystemSpecMaintenance)(ptr) == nil
}

func (MysqlDbSystemSpecMaintenanceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MysqlDbSystemSpecMaintenance)(ptr)
	var objs []MysqlDbSystemSpecMaintenance
	if obj != nil {
		objs = []MysqlDbSystemSpecMaintenance{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecMaintenance{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MysqlDbSystemSpecMaintenanceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MysqlDbSystemSpecMaintenance)(ptr) = MysqlDbSystemSpecMaintenance{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MysqlDbSystemSpecMaintenance

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecMaintenance{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MysqlDbSystemSpecMaintenance)(ptr) = objs[0]
			} else {
				*(*MysqlDbSystemSpecMaintenance)(ptr) = MysqlDbSystemSpecMaintenance{}
			}
		} else {
			*(*MysqlDbSystemSpecMaintenance)(ptr) = MysqlDbSystemSpecMaintenance{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MysqlDbSystemSpecMaintenance

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecMaintenance{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MysqlDbSystemSpecMaintenance)(ptr) = obj
		} else {
			*(*MysqlDbSystemSpecMaintenance)(ptr) = MysqlDbSystemSpecMaintenance{}
		}
	default:
		iter.ReportError("decode MysqlDbSystemSpecMaintenance", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MysqlDbSystemSpecSourceCodec struct {
}

func (MysqlDbSystemSpecSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MysqlDbSystemSpecSource)(ptr) == nil
}

func (MysqlDbSystemSpecSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MysqlDbSystemSpecSource)(ptr)
	var objs []MysqlDbSystemSpecSource
	if obj != nil {
		objs = []MysqlDbSystemSpecSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MysqlDbSystemSpecSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MysqlDbSystemSpecSource)(ptr) = MysqlDbSystemSpecSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MysqlDbSystemSpecSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MysqlDbSystemSpecSource)(ptr) = objs[0]
			} else {
				*(*MysqlDbSystemSpecSource)(ptr) = MysqlDbSystemSpecSource{}
			}
		} else {
			*(*MysqlDbSystemSpecSource)(ptr) = MysqlDbSystemSpecSource{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MysqlDbSystemSpecSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MysqlDbSystemSpecSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MysqlDbSystemSpecSource)(ptr) = obj
		} else {
			*(*MysqlDbSystemSpecSource)(ptr) = MysqlDbSystemSpecSource{}
		}
	default:
		iter.ReportError("decode MysqlDbSystemSpecSource", "unexpected JSON type")
	}
}
