/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecIssuerName{}).Type1()):                                          CertificateSpecIssuerNameCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecPublicKeyInfo{}).Type1()):                                       CertificateSpecPublicKeyInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecSubjectName{}).Type1()):                                         CertificateSpecSubjectNameCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HttpRedirectSpecTarget{}).Type1()):                                             HttpRedirectSpecTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecPolicyConfig{}).Type1()):                                         WaasPolicySpecPolicyConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecPolicyConfigHealthChecks{}).Type1()):                             WaasPolicySpecPolicyConfigHealthChecksCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecPolicyConfigLoadBalancingMethod{}).Type1()):                      WaasPolicySpecPolicyConfigLoadBalancingMethodCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfig{}).Type1()):                                            WaasPolicySpecWafConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigAddressRateLimiting{}).Type1()):                         WaasPolicySpecWafConfigAddressRateLimitingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigDeviceFingerprintChallenge{}).Type1()):                  WaasPolicySpecWafConfigDeviceFingerprintChallengeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings{}).Type1()): WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigHumanInteractionChallenge{}).Type1()):                   WaasPolicySpecWafConfigHumanInteractionChallengeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings{}).Type1()):  WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader{}).Type1()):      WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeaderCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigJsChallenge{}).Type1()):                                 WaasPolicySpecWafConfigJsChallengeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigJsChallengeChallengeSettings{}).Type1()):                WaasPolicySpecWafConfigJsChallengeChallengeSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigJsChallengeSetHTTPHeader{}).Type1()):                    WaasPolicySpecWafConfigJsChallengeSetHTTPHeaderCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigProtectionSettings{}).Type1()):                          WaasPolicySpecWafConfigProtectionSettingsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecIssuerName{}).Type1()):                                          CertificateSpecIssuerNameCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecPublicKeyInfo{}).Type1()):                                       CertificateSpecPublicKeyInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecSubjectName{}).Type1()):                                         CertificateSpecSubjectNameCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HttpRedirectSpecTarget{}).Type1()):                                             HttpRedirectSpecTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecPolicyConfig{}).Type1()):                                         WaasPolicySpecPolicyConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecPolicyConfigHealthChecks{}).Type1()):                             WaasPolicySpecPolicyConfigHealthChecksCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecPolicyConfigLoadBalancingMethod{}).Type1()):                      WaasPolicySpecPolicyConfigLoadBalancingMethodCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfig{}).Type1()):                                            WaasPolicySpecWafConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigAddressRateLimiting{}).Type1()):                         WaasPolicySpecWafConfigAddressRateLimitingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigDeviceFingerprintChallenge{}).Type1()):                  WaasPolicySpecWafConfigDeviceFingerprintChallengeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings{}).Type1()): WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigHumanInteractionChallenge{}).Type1()):                   WaasPolicySpecWafConfigHumanInteractionChallengeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings{}).Type1()):  WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader{}).Type1()):      WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeaderCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigJsChallenge{}).Type1()):                                 WaasPolicySpecWafConfigJsChallengeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigJsChallengeChallengeSettings{}).Type1()):                WaasPolicySpecWafConfigJsChallengeChallengeSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigJsChallengeSetHTTPHeader{}).Type1()):                    WaasPolicySpecWafConfigJsChallengeSetHTTPHeaderCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigProtectionSettings{}).Type1()):                          WaasPolicySpecWafConfigProtectionSettingsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type CertificateSpecIssuerNameCodec struct {
}

func (CertificateSpecIssuerNameCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateSpecIssuerName)(ptr) == nil
}

func (CertificateSpecIssuerNameCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateSpecIssuerName)(ptr)
	var objs []CertificateSpecIssuerName
	if obj != nil {
		objs = []CertificateSpecIssuerName{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecIssuerName{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateSpecIssuerNameCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateSpecIssuerName)(ptr) = CertificateSpecIssuerName{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateSpecIssuerName

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecIssuerName{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateSpecIssuerName)(ptr) = objs[0]
			} else {
				*(*CertificateSpecIssuerName)(ptr) = CertificateSpecIssuerName{}
			}
		} else {
			*(*CertificateSpecIssuerName)(ptr) = CertificateSpecIssuerName{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateSpecIssuerName

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecIssuerName{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateSpecIssuerName)(ptr) = obj
		} else {
			*(*CertificateSpecIssuerName)(ptr) = CertificateSpecIssuerName{}
		}
	default:
		iter.ReportError("decode CertificateSpecIssuerName", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateSpecPublicKeyInfoCodec struct {
}

func (CertificateSpecPublicKeyInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateSpecPublicKeyInfo)(ptr) == nil
}

func (CertificateSpecPublicKeyInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateSpecPublicKeyInfo)(ptr)
	var objs []CertificateSpecPublicKeyInfo
	if obj != nil {
		objs = []CertificateSpecPublicKeyInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecPublicKeyInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateSpecPublicKeyInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateSpecPublicKeyInfo)(ptr) = CertificateSpecPublicKeyInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateSpecPublicKeyInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecPublicKeyInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateSpecPublicKeyInfo)(ptr) = objs[0]
			} else {
				*(*CertificateSpecPublicKeyInfo)(ptr) = CertificateSpecPublicKeyInfo{}
			}
		} else {
			*(*CertificateSpecPublicKeyInfo)(ptr) = CertificateSpecPublicKeyInfo{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateSpecPublicKeyInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecPublicKeyInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateSpecPublicKeyInfo)(ptr) = obj
		} else {
			*(*CertificateSpecPublicKeyInfo)(ptr) = CertificateSpecPublicKeyInfo{}
		}
	default:
		iter.ReportError("decode CertificateSpecPublicKeyInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CertificateSpecSubjectNameCodec struct {
}

func (CertificateSpecSubjectNameCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CertificateSpecSubjectName)(ptr) == nil
}

func (CertificateSpecSubjectNameCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CertificateSpecSubjectName)(ptr)
	var objs []CertificateSpecSubjectName
	if obj != nil {
		objs = []CertificateSpecSubjectName{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecSubjectName{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CertificateSpecSubjectNameCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CertificateSpecSubjectName)(ptr) = CertificateSpecSubjectName{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CertificateSpecSubjectName

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecSubjectName{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CertificateSpecSubjectName)(ptr) = objs[0]
			} else {
				*(*CertificateSpecSubjectName)(ptr) = CertificateSpecSubjectName{}
			}
		} else {
			*(*CertificateSpecSubjectName)(ptr) = CertificateSpecSubjectName{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CertificateSpecSubjectName

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CertificateSpecSubjectName{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CertificateSpecSubjectName)(ptr) = obj
		} else {
			*(*CertificateSpecSubjectName)(ptr) = CertificateSpecSubjectName{}
		}
	default:
		iter.ReportError("decode CertificateSpecSubjectName", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HttpRedirectSpecTargetCodec struct {
}

func (HttpRedirectSpecTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HttpRedirectSpecTarget)(ptr) == nil
}

func (HttpRedirectSpecTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HttpRedirectSpecTarget)(ptr)
	var objs []HttpRedirectSpecTarget
	if obj != nil {
		objs = []HttpRedirectSpecTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HttpRedirectSpecTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HttpRedirectSpecTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HttpRedirectSpecTarget)(ptr) = HttpRedirectSpecTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HttpRedirectSpecTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HttpRedirectSpecTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HttpRedirectSpecTarget)(ptr) = objs[0]
			} else {
				*(*HttpRedirectSpecTarget)(ptr) = HttpRedirectSpecTarget{}
			}
		} else {
			*(*HttpRedirectSpecTarget)(ptr) = HttpRedirectSpecTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj HttpRedirectSpecTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HttpRedirectSpecTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*HttpRedirectSpecTarget)(ptr) = obj
		} else {
			*(*HttpRedirectSpecTarget)(ptr) = HttpRedirectSpecTarget{}
		}
	default:
		iter.ReportError("decode HttpRedirectSpecTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WaasPolicySpecPolicyConfigCodec struct {
}

func (WaasPolicySpecPolicyConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WaasPolicySpecPolicyConfig)(ptr) == nil
}

func (WaasPolicySpecPolicyConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WaasPolicySpecPolicyConfig)(ptr)
	var objs []WaasPolicySpecPolicyConfig
	if obj != nil {
		objs = []WaasPolicySpecPolicyConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecPolicyConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WaasPolicySpecPolicyConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WaasPolicySpecPolicyConfig)(ptr) = WaasPolicySpecPolicyConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WaasPolicySpecPolicyConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecPolicyConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WaasPolicySpecPolicyConfig)(ptr) = objs[0]
			} else {
				*(*WaasPolicySpecPolicyConfig)(ptr) = WaasPolicySpecPolicyConfig{}
			}
		} else {
			*(*WaasPolicySpecPolicyConfig)(ptr) = WaasPolicySpecPolicyConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WaasPolicySpecPolicyConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecPolicyConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WaasPolicySpecPolicyConfig)(ptr) = obj
		} else {
			*(*WaasPolicySpecPolicyConfig)(ptr) = WaasPolicySpecPolicyConfig{}
		}
	default:
		iter.ReportError("decode WaasPolicySpecPolicyConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WaasPolicySpecPolicyConfigHealthChecksCodec struct {
}

func (WaasPolicySpecPolicyConfigHealthChecksCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WaasPolicySpecPolicyConfigHealthChecks)(ptr) == nil
}

func (WaasPolicySpecPolicyConfigHealthChecksCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WaasPolicySpecPolicyConfigHealthChecks)(ptr)
	var objs []WaasPolicySpecPolicyConfigHealthChecks
	if obj != nil {
		objs = []WaasPolicySpecPolicyConfigHealthChecks{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecPolicyConfigHealthChecks{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WaasPolicySpecPolicyConfigHealthChecksCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WaasPolicySpecPolicyConfigHealthChecks)(ptr) = WaasPolicySpecPolicyConfigHealthChecks{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WaasPolicySpecPolicyConfigHealthChecks

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecPolicyConfigHealthChecks{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WaasPolicySpecPolicyConfigHealthChecks)(ptr) = objs[0]
			} else {
				*(*WaasPolicySpecPolicyConfigHealthChecks)(ptr) = WaasPolicySpecPolicyConfigHealthChecks{}
			}
		} else {
			*(*WaasPolicySpecPolicyConfigHealthChecks)(ptr) = WaasPolicySpecPolicyConfigHealthChecks{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WaasPolicySpecPolicyConfigHealthChecks

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecPolicyConfigHealthChecks{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WaasPolicySpecPolicyConfigHealthChecks)(ptr) = obj
		} else {
			*(*WaasPolicySpecPolicyConfigHealthChecks)(ptr) = WaasPolicySpecPolicyConfigHealthChecks{}
		}
	default:
		iter.ReportError("decode WaasPolicySpecPolicyConfigHealthChecks", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WaasPolicySpecPolicyConfigLoadBalancingMethodCodec struct {
}

func (WaasPolicySpecPolicyConfigLoadBalancingMethodCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WaasPolicySpecPolicyConfigLoadBalancingMethod)(ptr) == nil
}

func (WaasPolicySpecPolicyConfigLoadBalancingMethodCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WaasPolicySpecPolicyConfigLoadBalancingMethod)(ptr)
	var objs []WaasPolicySpecPolicyConfigLoadBalancingMethod
	if obj != nil {
		objs = []WaasPolicySpecPolicyConfigLoadBalancingMethod{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecPolicyConfigLoadBalancingMethod{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WaasPolicySpecPolicyConfigLoadBalancingMethodCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WaasPolicySpecPolicyConfigLoadBalancingMethod)(ptr) = WaasPolicySpecPolicyConfigLoadBalancingMethod{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WaasPolicySpecPolicyConfigLoadBalancingMethod

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecPolicyConfigLoadBalancingMethod{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WaasPolicySpecPolicyConfigLoadBalancingMethod)(ptr) = objs[0]
			} else {
				*(*WaasPolicySpecPolicyConfigLoadBalancingMethod)(ptr) = WaasPolicySpecPolicyConfigLoadBalancingMethod{}
			}
		} else {
			*(*WaasPolicySpecPolicyConfigLoadBalancingMethod)(ptr) = WaasPolicySpecPolicyConfigLoadBalancingMethod{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WaasPolicySpecPolicyConfigLoadBalancingMethod

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecPolicyConfigLoadBalancingMethod{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WaasPolicySpecPolicyConfigLoadBalancingMethod)(ptr) = obj
		} else {
			*(*WaasPolicySpecPolicyConfigLoadBalancingMethod)(ptr) = WaasPolicySpecPolicyConfigLoadBalancingMethod{}
		}
	default:
		iter.ReportError("decode WaasPolicySpecPolicyConfigLoadBalancingMethod", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WaasPolicySpecWafConfigCodec struct {
}

func (WaasPolicySpecWafConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WaasPolicySpecWafConfig)(ptr) == nil
}

func (WaasPolicySpecWafConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WaasPolicySpecWafConfig)(ptr)
	var objs []WaasPolicySpecWafConfig
	if obj != nil {
		objs = []WaasPolicySpecWafConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WaasPolicySpecWafConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WaasPolicySpecWafConfig)(ptr) = WaasPolicySpecWafConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WaasPolicySpecWafConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WaasPolicySpecWafConfig)(ptr) = objs[0]
			} else {
				*(*WaasPolicySpecWafConfig)(ptr) = WaasPolicySpecWafConfig{}
			}
		} else {
			*(*WaasPolicySpecWafConfig)(ptr) = WaasPolicySpecWafConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WaasPolicySpecWafConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WaasPolicySpecWafConfig)(ptr) = obj
		} else {
			*(*WaasPolicySpecWafConfig)(ptr) = WaasPolicySpecWafConfig{}
		}
	default:
		iter.ReportError("decode WaasPolicySpecWafConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WaasPolicySpecWafConfigAddressRateLimitingCodec struct {
}

func (WaasPolicySpecWafConfigAddressRateLimitingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WaasPolicySpecWafConfigAddressRateLimiting)(ptr) == nil
}

func (WaasPolicySpecWafConfigAddressRateLimitingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WaasPolicySpecWafConfigAddressRateLimiting)(ptr)
	var objs []WaasPolicySpecWafConfigAddressRateLimiting
	if obj != nil {
		objs = []WaasPolicySpecWafConfigAddressRateLimiting{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigAddressRateLimiting{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WaasPolicySpecWafConfigAddressRateLimitingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WaasPolicySpecWafConfigAddressRateLimiting)(ptr) = WaasPolicySpecWafConfigAddressRateLimiting{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WaasPolicySpecWafConfigAddressRateLimiting

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigAddressRateLimiting{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WaasPolicySpecWafConfigAddressRateLimiting)(ptr) = objs[0]
			} else {
				*(*WaasPolicySpecWafConfigAddressRateLimiting)(ptr) = WaasPolicySpecWafConfigAddressRateLimiting{}
			}
		} else {
			*(*WaasPolicySpecWafConfigAddressRateLimiting)(ptr) = WaasPolicySpecWafConfigAddressRateLimiting{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WaasPolicySpecWafConfigAddressRateLimiting

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigAddressRateLimiting{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WaasPolicySpecWafConfigAddressRateLimiting)(ptr) = obj
		} else {
			*(*WaasPolicySpecWafConfigAddressRateLimiting)(ptr) = WaasPolicySpecWafConfigAddressRateLimiting{}
		}
	default:
		iter.ReportError("decode WaasPolicySpecWafConfigAddressRateLimiting", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WaasPolicySpecWafConfigDeviceFingerprintChallengeCodec struct {
}

func (WaasPolicySpecWafConfigDeviceFingerprintChallengeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WaasPolicySpecWafConfigDeviceFingerprintChallenge)(ptr) == nil
}

func (WaasPolicySpecWafConfigDeviceFingerprintChallengeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WaasPolicySpecWafConfigDeviceFingerprintChallenge)(ptr)
	var objs []WaasPolicySpecWafConfigDeviceFingerprintChallenge
	if obj != nil {
		objs = []WaasPolicySpecWafConfigDeviceFingerprintChallenge{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigDeviceFingerprintChallenge{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WaasPolicySpecWafConfigDeviceFingerprintChallengeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WaasPolicySpecWafConfigDeviceFingerprintChallenge)(ptr) = WaasPolicySpecWafConfigDeviceFingerprintChallenge{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WaasPolicySpecWafConfigDeviceFingerprintChallenge

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigDeviceFingerprintChallenge{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WaasPolicySpecWafConfigDeviceFingerprintChallenge)(ptr) = objs[0]
			} else {
				*(*WaasPolicySpecWafConfigDeviceFingerprintChallenge)(ptr) = WaasPolicySpecWafConfigDeviceFingerprintChallenge{}
			}
		} else {
			*(*WaasPolicySpecWafConfigDeviceFingerprintChallenge)(ptr) = WaasPolicySpecWafConfigDeviceFingerprintChallenge{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WaasPolicySpecWafConfigDeviceFingerprintChallenge

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigDeviceFingerprintChallenge{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WaasPolicySpecWafConfigDeviceFingerprintChallenge)(ptr) = obj
		} else {
			*(*WaasPolicySpecWafConfigDeviceFingerprintChallenge)(ptr) = WaasPolicySpecWafConfigDeviceFingerprintChallenge{}
		}
	default:
		iter.ReportError("decode WaasPolicySpecWafConfigDeviceFingerprintChallenge", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettingsCodec struct {
}

func (WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings)(ptr) == nil
}

func (WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings)(ptr)
	var objs []WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings
	if obj != nil {
		objs = []WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings)(ptr) = WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings)(ptr) = objs[0]
			} else {
				*(*WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings)(ptr) = WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings{}
			}
		} else {
			*(*WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings)(ptr) = WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings)(ptr) = obj
		} else {
			*(*WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings)(ptr) = WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings{}
		}
	default:
		iter.ReportError("decode WaasPolicySpecWafConfigDeviceFingerprintChallengeChallengeSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WaasPolicySpecWafConfigHumanInteractionChallengeCodec struct {
}

func (WaasPolicySpecWafConfigHumanInteractionChallengeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WaasPolicySpecWafConfigHumanInteractionChallenge)(ptr) == nil
}

func (WaasPolicySpecWafConfigHumanInteractionChallengeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WaasPolicySpecWafConfigHumanInteractionChallenge)(ptr)
	var objs []WaasPolicySpecWafConfigHumanInteractionChallenge
	if obj != nil {
		objs = []WaasPolicySpecWafConfigHumanInteractionChallenge{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigHumanInteractionChallenge{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WaasPolicySpecWafConfigHumanInteractionChallengeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WaasPolicySpecWafConfigHumanInteractionChallenge)(ptr) = WaasPolicySpecWafConfigHumanInteractionChallenge{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WaasPolicySpecWafConfigHumanInteractionChallenge

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigHumanInteractionChallenge{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WaasPolicySpecWafConfigHumanInteractionChallenge)(ptr) = objs[0]
			} else {
				*(*WaasPolicySpecWafConfigHumanInteractionChallenge)(ptr) = WaasPolicySpecWafConfigHumanInteractionChallenge{}
			}
		} else {
			*(*WaasPolicySpecWafConfigHumanInteractionChallenge)(ptr) = WaasPolicySpecWafConfigHumanInteractionChallenge{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WaasPolicySpecWafConfigHumanInteractionChallenge

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigHumanInteractionChallenge{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WaasPolicySpecWafConfigHumanInteractionChallenge)(ptr) = obj
		} else {
			*(*WaasPolicySpecWafConfigHumanInteractionChallenge)(ptr) = WaasPolicySpecWafConfigHumanInteractionChallenge{}
		}
	default:
		iter.ReportError("decode WaasPolicySpecWafConfigHumanInteractionChallenge", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettingsCodec struct {
}

func (WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings)(ptr) == nil
}

func (WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings)(ptr)
	var objs []WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings
	if obj != nil {
		objs = []WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings)(ptr) = WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings)(ptr) = objs[0]
			} else {
				*(*WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings)(ptr) = WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings{}
			}
		} else {
			*(*WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings)(ptr) = WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings)(ptr) = obj
		} else {
			*(*WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings)(ptr) = WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings{}
		}
	default:
		iter.ReportError("decode WaasPolicySpecWafConfigHumanInteractionChallengeChallengeSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeaderCodec struct {
}

func (WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeaderCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader)(ptr) == nil
}

func (WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeaderCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader)(ptr)
	var objs []WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader
	if obj != nil {
		objs = []WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeaderCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader)(ptr) = WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader)(ptr) = objs[0]
			} else {
				*(*WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader)(ptr) = WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader{}
			}
		} else {
			*(*WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader)(ptr) = WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader)(ptr) = obj
		} else {
			*(*WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader)(ptr) = WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader{}
		}
	default:
		iter.ReportError("decode WaasPolicySpecWafConfigHumanInteractionChallengeSetHTTPHeader", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WaasPolicySpecWafConfigJsChallengeCodec struct {
}

func (WaasPolicySpecWafConfigJsChallengeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WaasPolicySpecWafConfigJsChallenge)(ptr) == nil
}

func (WaasPolicySpecWafConfigJsChallengeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WaasPolicySpecWafConfigJsChallenge)(ptr)
	var objs []WaasPolicySpecWafConfigJsChallenge
	if obj != nil {
		objs = []WaasPolicySpecWafConfigJsChallenge{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigJsChallenge{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WaasPolicySpecWafConfigJsChallengeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WaasPolicySpecWafConfigJsChallenge)(ptr) = WaasPolicySpecWafConfigJsChallenge{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WaasPolicySpecWafConfigJsChallenge

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigJsChallenge{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WaasPolicySpecWafConfigJsChallenge)(ptr) = objs[0]
			} else {
				*(*WaasPolicySpecWafConfigJsChallenge)(ptr) = WaasPolicySpecWafConfigJsChallenge{}
			}
		} else {
			*(*WaasPolicySpecWafConfigJsChallenge)(ptr) = WaasPolicySpecWafConfigJsChallenge{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WaasPolicySpecWafConfigJsChallenge

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigJsChallenge{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WaasPolicySpecWafConfigJsChallenge)(ptr) = obj
		} else {
			*(*WaasPolicySpecWafConfigJsChallenge)(ptr) = WaasPolicySpecWafConfigJsChallenge{}
		}
	default:
		iter.ReportError("decode WaasPolicySpecWafConfigJsChallenge", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WaasPolicySpecWafConfigJsChallengeChallengeSettingsCodec struct {
}

func (WaasPolicySpecWafConfigJsChallengeChallengeSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WaasPolicySpecWafConfigJsChallengeChallengeSettings)(ptr) == nil
}

func (WaasPolicySpecWafConfigJsChallengeChallengeSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WaasPolicySpecWafConfigJsChallengeChallengeSettings)(ptr)
	var objs []WaasPolicySpecWafConfigJsChallengeChallengeSettings
	if obj != nil {
		objs = []WaasPolicySpecWafConfigJsChallengeChallengeSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigJsChallengeChallengeSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WaasPolicySpecWafConfigJsChallengeChallengeSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WaasPolicySpecWafConfigJsChallengeChallengeSettings)(ptr) = WaasPolicySpecWafConfigJsChallengeChallengeSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WaasPolicySpecWafConfigJsChallengeChallengeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigJsChallengeChallengeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WaasPolicySpecWafConfigJsChallengeChallengeSettings)(ptr) = objs[0]
			} else {
				*(*WaasPolicySpecWafConfigJsChallengeChallengeSettings)(ptr) = WaasPolicySpecWafConfigJsChallengeChallengeSettings{}
			}
		} else {
			*(*WaasPolicySpecWafConfigJsChallengeChallengeSettings)(ptr) = WaasPolicySpecWafConfigJsChallengeChallengeSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WaasPolicySpecWafConfigJsChallengeChallengeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigJsChallengeChallengeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WaasPolicySpecWafConfigJsChallengeChallengeSettings)(ptr) = obj
		} else {
			*(*WaasPolicySpecWafConfigJsChallengeChallengeSettings)(ptr) = WaasPolicySpecWafConfigJsChallengeChallengeSettings{}
		}
	default:
		iter.ReportError("decode WaasPolicySpecWafConfigJsChallengeChallengeSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WaasPolicySpecWafConfigJsChallengeSetHTTPHeaderCodec struct {
}

func (WaasPolicySpecWafConfigJsChallengeSetHTTPHeaderCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WaasPolicySpecWafConfigJsChallengeSetHTTPHeader)(ptr) == nil
}

func (WaasPolicySpecWafConfigJsChallengeSetHTTPHeaderCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WaasPolicySpecWafConfigJsChallengeSetHTTPHeader)(ptr)
	var objs []WaasPolicySpecWafConfigJsChallengeSetHTTPHeader
	if obj != nil {
		objs = []WaasPolicySpecWafConfigJsChallengeSetHTTPHeader{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigJsChallengeSetHTTPHeader{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WaasPolicySpecWafConfigJsChallengeSetHTTPHeaderCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WaasPolicySpecWafConfigJsChallengeSetHTTPHeader)(ptr) = WaasPolicySpecWafConfigJsChallengeSetHTTPHeader{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WaasPolicySpecWafConfigJsChallengeSetHTTPHeader

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigJsChallengeSetHTTPHeader{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WaasPolicySpecWafConfigJsChallengeSetHTTPHeader)(ptr) = objs[0]
			} else {
				*(*WaasPolicySpecWafConfigJsChallengeSetHTTPHeader)(ptr) = WaasPolicySpecWafConfigJsChallengeSetHTTPHeader{}
			}
		} else {
			*(*WaasPolicySpecWafConfigJsChallengeSetHTTPHeader)(ptr) = WaasPolicySpecWafConfigJsChallengeSetHTTPHeader{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WaasPolicySpecWafConfigJsChallengeSetHTTPHeader

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigJsChallengeSetHTTPHeader{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WaasPolicySpecWafConfigJsChallengeSetHTTPHeader)(ptr) = obj
		} else {
			*(*WaasPolicySpecWafConfigJsChallengeSetHTTPHeader)(ptr) = WaasPolicySpecWafConfigJsChallengeSetHTTPHeader{}
		}
	default:
		iter.ReportError("decode WaasPolicySpecWafConfigJsChallengeSetHTTPHeader", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WaasPolicySpecWafConfigProtectionSettingsCodec struct {
}

func (WaasPolicySpecWafConfigProtectionSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WaasPolicySpecWafConfigProtectionSettings)(ptr) == nil
}

func (WaasPolicySpecWafConfigProtectionSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WaasPolicySpecWafConfigProtectionSettings)(ptr)
	var objs []WaasPolicySpecWafConfigProtectionSettings
	if obj != nil {
		objs = []WaasPolicySpecWafConfigProtectionSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigProtectionSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WaasPolicySpecWafConfigProtectionSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WaasPolicySpecWafConfigProtectionSettings)(ptr) = WaasPolicySpecWafConfigProtectionSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WaasPolicySpecWafConfigProtectionSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigProtectionSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WaasPolicySpecWafConfigProtectionSettings)(ptr) = objs[0]
			} else {
				*(*WaasPolicySpecWafConfigProtectionSettings)(ptr) = WaasPolicySpecWafConfigProtectionSettings{}
			}
		} else {
			*(*WaasPolicySpecWafConfigProtectionSettings)(ptr) = WaasPolicySpecWafConfigProtectionSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WaasPolicySpecWafConfigProtectionSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WaasPolicySpecWafConfigProtectionSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WaasPolicySpecWafConfigProtectionSettings)(ptr) = obj
		} else {
			*(*WaasPolicySpecWafConfigProtectionSettings)(ptr) = WaasPolicySpecWafConfigProtectionSettings{}
		}
	default:
		iter.ReportError("decode WaasPolicySpecWafConfigProtectionSettings", "unexpected JSON type")
	}
}
