/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecActionsBody{}).Type1()):                                             WebAppFirewallPolicySpecActionsBodyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestAccessControl{}).Type1()):                                    WebAppFirewallPolicySpecRequestAccessControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestProtection{}).Type1()):                                       WebAppFirewallPolicySpecRequestProtectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions{}).Type1()):  WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings{}).Type1()):      WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestRateLimiting{}).Type1()):                                     WebAppFirewallPolicySpecRequestRateLimitingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseAccessControl{}).Type1()):                                   WebAppFirewallPolicySpecResponseAccessControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseProtection{}).Type1()):                                      WebAppFirewallPolicySpecResponseProtectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions{}).Type1()): WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings{}).Type1()):     WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettingsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecActionsBody{}).Type1()):                                             WebAppFirewallPolicySpecActionsBodyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestAccessControl{}).Type1()):                                    WebAppFirewallPolicySpecRequestAccessControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestProtection{}).Type1()):                                       WebAppFirewallPolicySpecRequestProtectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions{}).Type1()):  WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings{}).Type1()):      WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestRateLimiting{}).Type1()):                                     WebAppFirewallPolicySpecRequestRateLimitingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseAccessControl{}).Type1()):                                   WebAppFirewallPolicySpecResponseAccessControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseProtection{}).Type1()):                                      WebAppFirewallPolicySpecResponseProtectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions{}).Type1()): WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings{}).Type1()):     WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettingsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type WebAppFirewallPolicySpecActionsBodyCodec struct {
}

func (WebAppFirewallPolicySpecActionsBodyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebAppFirewallPolicySpecActionsBody)(ptr) == nil
}

func (WebAppFirewallPolicySpecActionsBodyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebAppFirewallPolicySpecActionsBody)(ptr)
	var objs []WebAppFirewallPolicySpecActionsBody
	if obj != nil {
		objs = []WebAppFirewallPolicySpecActionsBody{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecActionsBody{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebAppFirewallPolicySpecActionsBodyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebAppFirewallPolicySpecActionsBody)(ptr) = WebAppFirewallPolicySpecActionsBody{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebAppFirewallPolicySpecActionsBody

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecActionsBody{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebAppFirewallPolicySpecActionsBody)(ptr) = objs[0]
			} else {
				*(*WebAppFirewallPolicySpecActionsBody)(ptr) = WebAppFirewallPolicySpecActionsBody{}
			}
		} else {
			*(*WebAppFirewallPolicySpecActionsBody)(ptr) = WebAppFirewallPolicySpecActionsBody{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WebAppFirewallPolicySpecActionsBody

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecActionsBody{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WebAppFirewallPolicySpecActionsBody)(ptr) = obj
		} else {
			*(*WebAppFirewallPolicySpecActionsBody)(ptr) = WebAppFirewallPolicySpecActionsBody{}
		}
	default:
		iter.ReportError("decode WebAppFirewallPolicySpecActionsBody", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebAppFirewallPolicySpecRequestAccessControlCodec struct {
}

func (WebAppFirewallPolicySpecRequestAccessControlCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebAppFirewallPolicySpecRequestAccessControl)(ptr) == nil
}

func (WebAppFirewallPolicySpecRequestAccessControlCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebAppFirewallPolicySpecRequestAccessControl)(ptr)
	var objs []WebAppFirewallPolicySpecRequestAccessControl
	if obj != nil {
		objs = []WebAppFirewallPolicySpecRequestAccessControl{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestAccessControl{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebAppFirewallPolicySpecRequestAccessControlCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebAppFirewallPolicySpecRequestAccessControl)(ptr) = WebAppFirewallPolicySpecRequestAccessControl{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebAppFirewallPolicySpecRequestAccessControl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestAccessControl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebAppFirewallPolicySpecRequestAccessControl)(ptr) = objs[0]
			} else {
				*(*WebAppFirewallPolicySpecRequestAccessControl)(ptr) = WebAppFirewallPolicySpecRequestAccessControl{}
			}
		} else {
			*(*WebAppFirewallPolicySpecRequestAccessControl)(ptr) = WebAppFirewallPolicySpecRequestAccessControl{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WebAppFirewallPolicySpecRequestAccessControl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestAccessControl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WebAppFirewallPolicySpecRequestAccessControl)(ptr) = obj
		} else {
			*(*WebAppFirewallPolicySpecRequestAccessControl)(ptr) = WebAppFirewallPolicySpecRequestAccessControl{}
		}
	default:
		iter.ReportError("decode WebAppFirewallPolicySpecRequestAccessControl", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebAppFirewallPolicySpecRequestProtectionCodec struct {
}

func (WebAppFirewallPolicySpecRequestProtectionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebAppFirewallPolicySpecRequestProtection)(ptr) == nil
}

func (WebAppFirewallPolicySpecRequestProtectionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebAppFirewallPolicySpecRequestProtection)(ptr)
	var objs []WebAppFirewallPolicySpecRequestProtection
	if obj != nil {
		objs = []WebAppFirewallPolicySpecRequestProtection{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestProtection{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebAppFirewallPolicySpecRequestProtectionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebAppFirewallPolicySpecRequestProtection)(ptr) = WebAppFirewallPolicySpecRequestProtection{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebAppFirewallPolicySpecRequestProtection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestProtection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebAppFirewallPolicySpecRequestProtection)(ptr) = objs[0]
			} else {
				*(*WebAppFirewallPolicySpecRequestProtection)(ptr) = WebAppFirewallPolicySpecRequestProtection{}
			}
		} else {
			*(*WebAppFirewallPolicySpecRequestProtection)(ptr) = WebAppFirewallPolicySpecRequestProtection{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WebAppFirewallPolicySpecRequestProtection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestProtection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WebAppFirewallPolicySpecRequestProtection)(ptr) = obj
		} else {
			*(*WebAppFirewallPolicySpecRequestProtection)(ptr) = WebAppFirewallPolicySpecRequestProtection{}
		}
	default:
		iter.ReportError("decode WebAppFirewallPolicySpecRequestProtection", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusionsCodec struct {
}

func (WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions)(ptr) == nil
}

func (WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions)(ptr)
	var objs []WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions
	if obj != nil {
		objs = []WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions)(ptr) = WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions)(ptr) = objs[0]
			} else {
				*(*WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions)(ptr) = WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions{}
			}
		} else {
			*(*WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions)(ptr) = WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions)(ptr) = obj
		} else {
			*(*WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions)(ptr) = WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions{}
		}
	default:
		iter.ReportError("decode WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitiesExclusions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettingsCodec struct {
}

func (WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings)(ptr) == nil
}

func (WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings)(ptr)
	var objs []WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings
	if obj != nil {
		objs = []WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings)(ptr) = WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings)(ptr) = objs[0]
			} else {
				*(*WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings)(ptr) = WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings{}
			}
		} else {
			*(*WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings)(ptr) = WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings)(ptr) = obj
		} else {
			*(*WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings)(ptr) = WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings{}
		}
	default:
		iter.ReportError("decode WebAppFirewallPolicySpecRequestProtectionRulesProtectionCapabilitySettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebAppFirewallPolicySpecRequestRateLimitingCodec struct {
}

func (WebAppFirewallPolicySpecRequestRateLimitingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebAppFirewallPolicySpecRequestRateLimiting)(ptr) == nil
}

func (WebAppFirewallPolicySpecRequestRateLimitingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebAppFirewallPolicySpecRequestRateLimiting)(ptr)
	var objs []WebAppFirewallPolicySpecRequestRateLimiting
	if obj != nil {
		objs = []WebAppFirewallPolicySpecRequestRateLimiting{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestRateLimiting{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebAppFirewallPolicySpecRequestRateLimitingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebAppFirewallPolicySpecRequestRateLimiting)(ptr) = WebAppFirewallPolicySpecRequestRateLimiting{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebAppFirewallPolicySpecRequestRateLimiting

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestRateLimiting{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebAppFirewallPolicySpecRequestRateLimiting)(ptr) = objs[0]
			} else {
				*(*WebAppFirewallPolicySpecRequestRateLimiting)(ptr) = WebAppFirewallPolicySpecRequestRateLimiting{}
			}
		} else {
			*(*WebAppFirewallPolicySpecRequestRateLimiting)(ptr) = WebAppFirewallPolicySpecRequestRateLimiting{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WebAppFirewallPolicySpecRequestRateLimiting

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecRequestRateLimiting{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WebAppFirewallPolicySpecRequestRateLimiting)(ptr) = obj
		} else {
			*(*WebAppFirewallPolicySpecRequestRateLimiting)(ptr) = WebAppFirewallPolicySpecRequestRateLimiting{}
		}
	default:
		iter.ReportError("decode WebAppFirewallPolicySpecRequestRateLimiting", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebAppFirewallPolicySpecResponseAccessControlCodec struct {
}

func (WebAppFirewallPolicySpecResponseAccessControlCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebAppFirewallPolicySpecResponseAccessControl)(ptr) == nil
}

func (WebAppFirewallPolicySpecResponseAccessControlCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebAppFirewallPolicySpecResponseAccessControl)(ptr)
	var objs []WebAppFirewallPolicySpecResponseAccessControl
	if obj != nil {
		objs = []WebAppFirewallPolicySpecResponseAccessControl{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseAccessControl{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebAppFirewallPolicySpecResponseAccessControlCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebAppFirewallPolicySpecResponseAccessControl)(ptr) = WebAppFirewallPolicySpecResponseAccessControl{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebAppFirewallPolicySpecResponseAccessControl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseAccessControl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebAppFirewallPolicySpecResponseAccessControl)(ptr) = objs[0]
			} else {
				*(*WebAppFirewallPolicySpecResponseAccessControl)(ptr) = WebAppFirewallPolicySpecResponseAccessControl{}
			}
		} else {
			*(*WebAppFirewallPolicySpecResponseAccessControl)(ptr) = WebAppFirewallPolicySpecResponseAccessControl{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WebAppFirewallPolicySpecResponseAccessControl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseAccessControl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WebAppFirewallPolicySpecResponseAccessControl)(ptr) = obj
		} else {
			*(*WebAppFirewallPolicySpecResponseAccessControl)(ptr) = WebAppFirewallPolicySpecResponseAccessControl{}
		}
	default:
		iter.ReportError("decode WebAppFirewallPolicySpecResponseAccessControl", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebAppFirewallPolicySpecResponseProtectionCodec struct {
}

func (WebAppFirewallPolicySpecResponseProtectionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebAppFirewallPolicySpecResponseProtection)(ptr) == nil
}

func (WebAppFirewallPolicySpecResponseProtectionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebAppFirewallPolicySpecResponseProtection)(ptr)
	var objs []WebAppFirewallPolicySpecResponseProtection
	if obj != nil {
		objs = []WebAppFirewallPolicySpecResponseProtection{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseProtection{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebAppFirewallPolicySpecResponseProtectionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebAppFirewallPolicySpecResponseProtection)(ptr) = WebAppFirewallPolicySpecResponseProtection{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebAppFirewallPolicySpecResponseProtection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseProtection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebAppFirewallPolicySpecResponseProtection)(ptr) = objs[0]
			} else {
				*(*WebAppFirewallPolicySpecResponseProtection)(ptr) = WebAppFirewallPolicySpecResponseProtection{}
			}
		} else {
			*(*WebAppFirewallPolicySpecResponseProtection)(ptr) = WebAppFirewallPolicySpecResponseProtection{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WebAppFirewallPolicySpecResponseProtection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseProtection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WebAppFirewallPolicySpecResponseProtection)(ptr) = obj
		} else {
			*(*WebAppFirewallPolicySpecResponseProtection)(ptr) = WebAppFirewallPolicySpecResponseProtection{}
		}
	default:
		iter.ReportError("decode WebAppFirewallPolicySpecResponseProtection", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusionsCodec struct {
}

func (WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions)(ptr) == nil
}

func (WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions)(ptr)
	var objs []WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions
	if obj != nil {
		objs = []WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions)(ptr) = WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions)(ptr) = objs[0]
			} else {
				*(*WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions)(ptr) = WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions{}
			}
		} else {
			*(*WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions)(ptr) = WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions)(ptr) = obj
		} else {
			*(*WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions)(ptr) = WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions{}
		}
	default:
		iter.ReportError("decode WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitiesExclusions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettingsCodec struct {
}

func (WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings)(ptr) == nil
}

func (WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings)(ptr)
	var objs []WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings
	if obj != nil {
		objs = []WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings)(ptr) = WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings)(ptr) = objs[0]
			} else {
				*(*WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings)(ptr) = WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings{}
			}
		} else {
			*(*WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings)(ptr) = WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings)(ptr) = obj
		} else {
			*(*WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings)(ptr) = WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings{}
		}
	default:
		iter.ReportError("decode WebAppFirewallPolicySpecResponseProtectionRulesProtectionCapabilitySettings", "unexpected JSON type")
	}
}
